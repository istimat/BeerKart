ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"util.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.__io_putchar,"ax",%progbits
  16              		.align	1
  17              		.global	__io_putchar
  18              		.arch armv7-m
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu softvfp
  24              	__io_putchar:
  25              	.LVL0:
  26              	.LFB66:
  27              		.file 1 "Src/util.c"
   1:Src/util.c    **** /**
   2:Src/util.c    ****   * This file is part of the hoverboard-firmware-hack project.
   3:Src/util.c    ****   *
   4:Src/util.c    ****   * Copyright (C) 2020-2021 Emanuel FERU <aerdronix@gmail.com>
   5:Src/util.c    ****   *
   6:Src/util.c    ****   * This program is free software: you can redistribute it and/or modify
   7:Src/util.c    ****   * it under the terms of the GNU General Public License as published by
   8:Src/util.c    ****   * the Free Software Foundation, either version 3 of the License, or
   9:Src/util.c    ****   * (at your option) any later version.
  10:Src/util.c    ****   *
  11:Src/util.c    ****   * This program is distributed in the hope that it will be useful,
  12:Src/util.c    ****   * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:Src/util.c    ****   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:Src/util.c    ****   * GNU General Public License for more details.
  15:Src/util.c    ****   *
  16:Src/util.c    ****   * You should have received a copy of the GNU General Public License
  17:Src/util.c    ****   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:Src/util.c    **** */
  19:Src/util.c    **** 
  20:Src/util.c    **** // Includes
  21:Src/util.c    **** #include <stdio.h>
  22:Src/util.c    **** #include <stdlib.h> // for abs()
  23:Src/util.c    **** #include <string.h>
  24:Src/util.c    **** #include "stm32f1xx_hal.h"
  25:Src/util.c    **** #include "defines.h"
  26:Src/util.c    **** #include "setup.h"
  27:Src/util.c    **** #include "config.h"
  28:Src/util.c    **** #include "eeprom.h"
  29:Src/util.c    **** #include "util.h"
  30:Src/util.c    **** #include "BLDC_controller.h"
  31:Src/util.c    **** #include "rtwtypes.h"
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 2


  32:Src/util.c    **** #include "comms.h"
  33:Src/util.c    **** 
  34:Src/util.c    **** #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
  35:Src/util.c    **** #include "hd44780.h"
  36:Src/util.c    **** #endif
  37:Src/util.c    **** 
  38:Src/util.c    **** /* =========================== Variable Definitions =========================== */
  39:Src/util.c    **** 
  40:Src/util.c    **** //------------------------------------------------------------------------
  41:Src/util.c    **** // Global variables set externally
  42:Src/util.c    **** //------------------------------------------------------------------------
  43:Src/util.c    **** extern volatile adc_buf_t adc_buffer;
  44:Src/util.c    **** extern I2C_HandleTypeDef hi2c2;
  45:Src/util.c    **** extern UART_HandleTypeDef huart2;
  46:Src/util.c    **** extern UART_HandleTypeDef huart3;
  47:Src/util.c    **** 
  48:Src/util.c    **** extern int16_t batVoltage;
  49:Src/util.c    **** extern uint8_t backwardDrive;
  50:Src/util.c    **** extern uint8_t buzzerCount;             // global variable for the buzzer counts. can be 1, 2, 3, 4
  51:Src/util.c    **** extern uint8_t buzzerFreq;              // global variable for the buzzer pitch. can be 1, 2, 3, 4,
  52:Src/util.c    **** extern uint8_t buzzerPattern;           // global variable for the buzzer pattern. can be 1, 2, 3, 
  53:Src/util.c    **** 
  54:Src/util.c    **** extern uint8_t enable;                  // global variable for motor enable
  55:Src/util.c    **** 
  56:Src/util.c    **** extern uint8_t nunchuk_data[6];
  57:Src/util.c    **** extern volatile uint32_t timeoutCntGen; // global counter for general timeout counter
  58:Src/util.c    **** extern volatile uint8_t  timeoutFlgGen; // global flag for general timeout counter
  59:Src/util.c    **** extern volatile uint32_t main_loop_counter;
  60:Src/util.c    **** 
  61:Src/util.c    **** #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
  62:Src/util.c    **** extern volatile uint16_t ppm_captured_value[PPM_NUM_CHANNELS+1];
  63:Src/util.c    **** #endif
  64:Src/util.c    **** 
  65:Src/util.c    **** #if defined(CONTROL_PWM_LEFT) || defined(CONTROL_PWM_RIGHT)
  66:Src/util.c    **** extern volatile uint16_t pwm_captured_ch1_value;
  67:Src/util.c    **** extern volatile uint16_t pwm_captured_ch2_value;
  68:Src/util.c    **** #endif
  69:Src/util.c    **** 
  70:Src/util.c    **** 
  71:Src/util.c    **** //------------------------------------------------------------------------
  72:Src/util.c    **** // Global variables set here in util.c
  73:Src/util.c    **** //------------------------------------------------------------------------
  74:Src/util.c    **** // Matlab defines - from auto-code generation
  75:Src/util.c    **** //---------------
  76:Src/util.c    **** RT_MODEL rtM_Left_;                     /* Real-time model */
  77:Src/util.c    **** RT_MODEL rtM_Right_;                    /* Real-time model */
  78:Src/util.c    **** RT_MODEL *const rtM_Left  = &rtM_Left_;
  79:Src/util.c    **** RT_MODEL *const rtM_Right = &rtM_Right_;
  80:Src/util.c    **** 
  81:Src/util.c    **** extern P rtP_Left;                      /* Block parameters (auto storage) */
  82:Src/util.c    **** DW       rtDW_Left;                     /* Observable states */
  83:Src/util.c    **** ExtU     rtU_Left;                      /* External inputs */
  84:Src/util.c    **** ExtY     rtY_Left;                      /* External outputs */
  85:Src/util.c    **** 
  86:Src/util.c    **** P        rtP_Right;                     /* Block parameters (auto storage) */
  87:Src/util.c    **** DW       rtDW_Right;                    /* Observable states */
  88:Src/util.c    **** ExtU     rtU_Right;                     /* External inputs */
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 3


  89:Src/util.c    **** ExtY     rtY_Right;                     /* External outputs */
  90:Src/util.c    **** //---------------
  91:Src/util.c    **** 
  92:Src/util.c    **** uint8_t  inIdx      = 0;
  93:Src/util.c    **** uint8_t  inIdx_prev = 0;
  94:Src/util.c    **** #if defined(PRI_INPUT1) && defined(PRI_INPUT2) && defined(AUX_INPUT1) && defined(AUX_INPUT2)
  95:Src/util.c    **** InputStruct input1[INPUTS_NR] = { {0, 0, 0, PRI_INPUT1}, {0, 0, 0, AUX_INPUT1} };
  96:Src/util.c    **** InputStruct input2[INPUTS_NR] = { {0, 0, 0, PRI_INPUT2}, {0, 0, 0, AUX_INPUT2} };
  97:Src/util.c    **** #else
  98:Src/util.c    **** InputStruct input1[INPUTS_NR] = { {0, 0, 0, PRI_INPUT1} };
  99:Src/util.c    **** InputStruct input2[INPUTS_NR] = { {0, 0, 0, PRI_INPUT2} };
 100:Src/util.c    **** #endif
 101:Src/util.c    **** 
 102:Src/util.c    **** int16_t  speedAvg;                      // average measured speed
 103:Src/util.c    **** int16_t  speedAvgAbs;                   // average measured speed in absolute
 104:Src/util.c    **** uint8_t  timeoutFlgADC    = 0;          // Timeout Flag for ADC Protection:    0 = OK, 1 = Problem 
 105:Src/util.c    **** uint8_t  timeoutFlgSerial = 0;          // Timeout Flag for Rx Serial command: 0 = OK, 1 = Problem 
 106:Src/util.c    **** 
 107:Src/util.c    **** uint8_t  ctrlModReqRaw = CTRL_MOD_REQ;
 108:Src/util.c    **** uint8_t  ctrlModReq    = CTRL_MOD_REQ;  // Final control mode request 
 109:Src/util.c    **** 
 110:Src/util.c    **** #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
 111:Src/util.c    **** LCD_PCF8574_HandleTypeDef lcd;
 112:Src/util.c    **** #endif
 113:Src/util.c    **** 
 114:Src/util.c    **** #if defined(CONTROL_NUNCHUK) || defined(SUPPORT_NUNCHUK)
 115:Src/util.c    **** uint8_t nunchuk_connected = 1;
 116:Src/util.c    **** #else
 117:Src/util.c    **** uint8_t nunchuk_connected = 0;
 118:Src/util.c    **** #endif
 119:Src/util.c    **** 
 120:Src/util.c    **** #ifdef VARIANT_TRANSPOTTER
 121:Src/util.c    **** float    setDistance;
 122:Src/util.c    **** uint16_t VirtAddVarTab[NB_OF_VAR] = {1337};       // Virtual address defined by the user: 0xFFFF va
 123:Src/util.c    **** static   uint16_t saveValue       = 0;
 124:Src/util.c    **** static   uint8_t  saveValue_valid = 0;
 125:Src/util.c    **** #elif !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 126:Src/util.c    **** uint16_t VirtAddVarTab[NB_OF_VAR] = {1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009,
 127:Src/util.c    ****                                      1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018};
 128:Src/util.c    **** #else
 129:Src/util.c    **** uint16_t VirtAddVarTab[NB_OF_VAR] = {1000};       // Dummy virtual address to avoid warnings
 130:Src/util.c    **** #endif
 131:Src/util.c    **** 
 132:Src/util.c    **** 
 133:Src/util.c    **** //------------------------------------------------------------------------
 134:Src/util.c    **** // Local variables
 135:Src/util.c    **** //------------------------------------------------------------------------
 136:Src/util.c    **** static int16_t INPUT_MAX;             // [-] Input target maximum limitation
 137:Src/util.c    **** static int16_t INPUT_MIN;             // [-] Input target minimum limitation
 138:Src/util.c    **** 
 139:Src/util.c    **** 
 140:Src/util.c    **** #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 141:Src/util.c    ****   static uint8_t  cur_spd_valid  = 0;
 142:Src/util.c    ****   static uint8_t  inp_cal_valid  = 0;
 143:Src/util.c    **** #endif
 144:Src/util.c    **** 
 145:Src/util.c    **** #if defined(CONTROL_ADC)
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 4


 146:Src/util.c    **** static uint16_t timeoutCntADC = ADC_PROTECT_TIMEOUT;  // Timeout counter for ADC Protection
 147:Src/util.c    **** #endif
 148:Src/util.c    **** 
 149:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USAR
 150:Src/util.c    **** static uint8_t  rx_buffer_L[SERIAL_BUFFER_SIZE];      // USART Rx DMA circular buffer
 151:Src/util.c    **** static uint32_t rx_buffer_L_len = ARRAY_LEN(rx_buffer_L);
 152:Src/util.c    **** #endif
 153:Src/util.c    **** #if defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART2)
 154:Src/util.c    **** static uint16_t timeoutCntSerial_L = SERIAL_TIMEOUT;  // Timeout counter for Rx Serial command
 155:Src/util.c    **** static uint8_t  timeoutFlgSerial_L = 0;               // Timeout Flag for Rx Serial command: 0 = OK
 156:Src/util.c    **** #endif
 157:Src/util.c    **** #if defined(SIDEBOARD_SERIAL_USART2)
 158:Src/util.c    **** SerialSideboard Sideboard_L;
 159:Src/util.c    **** SerialSideboard Sideboard_L_raw;
 160:Src/util.c    **** static uint32_t Sideboard_L_len = sizeof(Sideboard_L);
 161:Src/util.c    **** #endif
 162:Src/util.c    **** 
 163:Src/util.c    **** #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USAR
 164:Src/util.c    **** static uint8_t  rx_buffer_R[SERIAL_BUFFER_SIZE];      // USART Rx DMA circular buffer
 165:Src/util.c    **** static uint32_t rx_buffer_R_len = ARRAY_LEN(rx_buffer_R);
 166:Src/util.c    **** #endif
 167:Src/util.c    **** #if defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USART3)
 168:Src/util.c    **** static uint16_t timeoutCntSerial_R = SERIAL_TIMEOUT;  // Timeout counter for Rx Serial command
 169:Src/util.c    **** static uint8_t  timeoutFlgSerial_R = 0;               // Timeout Flag for Rx Serial command: 0 = OK
 170:Src/util.c    **** #endif
 171:Src/util.c    **** #if defined(SIDEBOARD_SERIAL_USART3)
 172:Src/util.c    **** SerialSideboard Sideboard_R;
 173:Src/util.c    **** SerialSideboard Sideboard_R_raw;
 174:Src/util.c    **** static uint32_t Sideboard_R_len = sizeof(Sideboard_R);
 175:Src/util.c    **** #endif
 176:Src/util.c    **** 
 177:Src/util.c    **** #if defined(CONTROL_SERIAL_USART2)
 178:Src/util.c    **** static SerialCommand commandL;
 179:Src/util.c    **** static SerialCommand commandL_raw;
 180:Src/util.c    **** static uint32_t commandL_len = sizeof(commandL);
 181:Src/util.c    ****   #ifdef CONTROL_IBUS
 182:Src/util.c    ****   static uint16_t ibusL_captured_value[IBUS_NUM_CHANNELS];
 183:Src/util.c    ****   #endif
 184:Src/util.c    **** #endif
 185:Src/util.c    **** 
 186:Src/util.c    **** #if defined(CONTROL_SERIAL_USART3)
 187:Src/util.c    **** static SerialCommand commandR;
 188:Src/util.c    **** static SerialCommand commandR_raw;
 189:Src/util.c    **** static uint32_t commandR_len = sizeof(commandR);
 190:Src/util.c    ****   #ifdef CONTROL_IBUS
 191:Src/util.c    ****   static uint16_t ibusR_captured_value[IBUS_NUM_CHANNELS];
 192:Src/util.c    ****   #endif
 193:Src/util.c    **** #endif
 194:Src/util.c    **** 
 195:Src/util.c    **** #if defined(SUPPORT_BUTTONS) || defined(SUPPORT_BUTTONS_LEFT) || defined(SUPPORT_BUTTONS_RIGHT)
 196:Src/util.c    **** static uint8_t button1;                 // Blue
 197:Src/util.c    **** static uint8_t button2;                 // Green
 198:Src/util.c    **** #endif
 199:Src/util.c    **** 
 200:Src/util.c    **** #ifdef VARIANT_HOVERCAR
 201:Src/util.c    **** static uint8_t brakePressed;
 202:Src/util.c    **** #endif
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 5


 203:Src/util.c    **** 
 204:Src/util.c    **** #if defined(CRUISE_CONTROL_SUPPORT) || (defined(STANDSTILL_HOLD_ENABLE) && (CTRL_TYP_SEL == FOC_CTR
 205:Src/util.c    **** static uint8_t cruiseCtrlAcv = 0;
 206:Src/util.c    **** static uint8_t standstillAcv = 0;
 207:Src/util.c    **** #endif
 208:Src/util.c    **** 
 209:Src/util.c    **** /* =========================== Retargeting printf =========================== */
 210:Src/util.c    **** /* retarget the C library printf function to the USART */
 211:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 212:Src/util.c    ****   #ifdef __GNUC__
 213:Src/util.c    ****     #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
 214:Src/util.c    ****   #else
 215:Src/util.c    ****     #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
 216:Src/util.c    ****   #endif
 217:Src/util.c    ****   PUTCHAR_PROTOTYPE {
  28              		.loc 1 217 21 view -0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 8
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		.loc 1 217 21 is_stmt 0 view .LVU1
  33 0000 00B5     		push	{lr}
  34              	.LCFI0:
  35              		.cfi_def_cfa_offset 4
  36              		.cfi_offset 14, -4
  37 0002 83B0     		sub	sp, sp, #12
  38              	.LCFI1:
  39              		.cfi_def_cfa_offset 16
  40 0004 0190     		str	r0, [sp, #4]
 218:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2)
 219:Src/util.c    ****       HAL_UART_Transmit(&huart2, (uint8_t *)&ch, 1, 1000);
 220:Src/util.c    ****     #elif defined(DEBUG_SERIAL_USART3)
 221:Src/util.c    ****       HAL_UART_Transmit(&huart3, (uint8_t *)&ch, 1, 1000);
  41              		.loc 1 221 7 is_stmt 1 view .LVU2
  42 0006 4FF47A73 		mov	r3, #1000
  43 000a 0122     		movs	r2, #1
  44 000c 01A9     		add	r1, sp, #4
  45 000e 0348     		ldr	r0, .L3
  46              	.LVL1:
  47              		.loc 1 221 7 is_stmt 0 view .LVU3
  48 0010 FFF7FEFF 		bl	HAL_UART_Transmit
  49              	.LVL2:
 222:Src/util.c    ****     #endif
 223:Src/util.c    ****     return ch;
  50              		.loc 1 223 5 is_stmt 1 view .LVU4
 224:Src/util.c    ****   }
  51              		.loc 1 224 3 is_stmt 0 view .LVU5
  52 0014 0198     		ldr	r0, [sp, #4]
  53 0016 03B0     		add	sp, sp, #12
  54              	.LCFI2:
  55              		.cfi_def_cfa_offset 4
  56              		@ sp needed
  57 0018 5DF804FB 		ldr	pc, [sp], #4
  58              	.L4:
  59              		.align	2
  60              	.L3:
  61 001c 00000000 		.word	huart3
  62              		.cfi_endproc
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 6


  63              	.LFE66:
  65              		.section	.text._write,"ax",%progbits
  66              		.align	1
  67              		.global	_write
  68              		.syntax unified
  69              		.thumb
  70              		.thumb_func
  71              		.fpu softvfp
  73              	_write:
  74              	.LVL3:
  75              	.LFB67:
 225:Src/util.c    ****   
 226:Src/util.c    ****   #ifdef __GNUC__
 227:Src/util.c    ****     int _write(int file, char *data, int len) {
  76              		.loc 1 227 47 is_stmt 1 view -0
  77              		.cfi_startproc
  78              		@ args = 0, pretend = 0, frame = 0
  79              		@ frame_needed = 0, uses_anonymous_args = 0
  80              		.loc 1 227 47 is_stmt 0 view .LVU7
  81 0000 70B5     		push	{r4, r5, r6, lr}
  82              	.LCFI3:
  83              		.cfi_def_cfa_offset 16
  84              		.cfi_offset 4, -16
  85              		.cfi_offset 5, -12
  86              		.cfi_offset 6, -8
  87              		.cfi_offset 14, -4
  88 0002 0C46     		mov	r4, r1
  89 0004 1646     		mov	r6, r2
 228:Src/util.c    ****       int i;
  90              		.loc 1 228 7 is_stmt 1 view .LVU8
 229:Src/util.c    ****       for (i = 0; i < len; i++) { __io_putchar( *data++ );}
  91              		.loc 1 229 7 view .LVU9
  92              	.LVL4:
  93              		.loc 1 229 14 is_stmt 0 view .LVU10
  94 0006 0025     		movs	r5, #0
  95              		.loc 1 229 7 view .LVU11
  96 0008 04E0     		b	.L6
  97              	.LVL5:
  98              	.L7:
  99              		.loc 1 229 35 is_stmt 1 discriminator 3 view .LVU12
 100              		.loc 1 229 35 is_stmt 0 discriminator 3 view .LVU13
 101 000a 14F8010B 		ldrb	r0, [r4], #1	@ zero_extendqisi2
 102              	.LVL6:
 103              		.loc 1 229 35 discriminator 3 view .LVU14
 104 000e FFF7FEFF 		bl	__io_putchar
 105              	.LVL7:
 106              		.loc 1 229 28 is_stmt 1 discriminator 3 view .LVU15
 107              		.loc 1 229 29 is_stmt 0 discriminator 3 view .LVU16
 108 0012 0135     		adds	r5, r5, #1
 109              	.LVL8:
 110              	.L6:
 111              		.loc 1 229 19 is_stmt 1 discriminator 1 view .LVU17
 112              		.loc 1 229 7 is_stmt 0 discriminator 1 view .LVU18
 113 0014 B542     		cmp	r5, r6
 114 0016 F8DB     		blt	.L7
 230:Src/util.c    ****       return len;
 115              		.loc 1 230 7 is_stmt 1 view .LVU19
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 7


 231:Src/util.c    ****     }
 116              		.loc 1 231 5 is_stmt 0 view .LVU20
 117 0018 3046     		mov	r0, r6
 118 001a 70BD     		pop	{r4, r5, r6, pc}
 119              		.loc 1 231 5 view .LVU21
 120              		.cfi_endproc
 121              	.LFE67:
 123              		.section	.text.BLDC_Init,"ax",%progbits
 124              		.align	1
 125              		.global	BLDC_Init
 126              		.syntax unified
 127              		.thumb
 128              		.thumb_func
 129              		.fpu softvfp
 131              	BLDC_Init:
 132              	.LFB68:
 232:Src/util.c    ****   #endif
 233:Src/util.c    **** #endif
 234:Src/util.c    **** 
 235:Src/util.c    ****  
 236:Src/util.c    **** /* =========================== Initialization Functions =========================== */
 237:Src/util.c    **** 
 238:Src/util.c    **** void BLDC_Init(void) {
 133              		.loc 1 238 22 is_stmt 1 view -0
 134              		.cfi_startproc
 135              		@ args = 0, pretend = 0, frame = 0
 136              		@ frame_needed = 0, uses_anonymous_args = 0
 137 0000 70B5     		push	{r4, r5, r6, lr}
 138              	.LCFI4:
 139              		.cfi_def_cfa_offset 16
 140              		.cfi_offset 4, -16
 141              		.cfi_offset 5, -12
 142              		.cfi_offset 6, -8
 143              		.cfi_offset 14, -4
 239:Src/util.c    ****   /* Set BLDC controller parameters */ 
 240:Src/util.c    ****   rtP_Left.b_angleMeasEna       = 0;            // Motor angle input: 0 = estimated angle, 1 = meas
 144              		.loc 1 240 3 view .LVU23
 145              		.loc 1 240 33 is_stmt 0 view .LVU24
 146 0002 204C     		ldr	r4, .L11
 147 0004 0023     		movs	r3, #0
 148 0006 84F8FB30 		strb	r3, [r4, #251]
 241:Src/util.c    ****   rtP_Left.z_selPhaCurMeasABC   = 0;            // Left motor measured current phases {Green, Blue}
 149              		.loc 1 241 3 is_stmt 1 view .LVU25
 150              		.loc 1 241 33 is_stmt 0 view .LVU26
 151 000a 84F8FA30 		strb	r3, [r4, #250]
 242:Src/util.c    ****   rtP_Left.z_ctrlTypSel         = CTRL_TYP_SEL;
 152              		.loc 1 242 3 is_stmt 1 view .LVU27
 153              		.loc 1 242 33 is_stmt 0 view .LVU28
 154 000e 0222     		movs	r2, #2
 155 0010 84F8F920 		strb	r2, [r4, #249]
 243:Src/util.c    ****   rtP_Left.b_diagEna            = DIAG_ENA;
 156              		.loc 1 243 3 is_stmt 1 view .LVU29
 157              		.loc 1 243 33 is_stmt 0 view .LVU30
 158 0014 0126     		movs	r6, #1
 159 0016 84F8FD60 		strb	r6, [r4, #253]
 244:Src/util.c    ****   rtP_Left.i_max                = (I_MOT_MAX * A2BIT_CONV) << 4;        // fixdt(1,16,4)
 160              		.loc 1 244 3 is_stmt 1 view .LVU31
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 8


 161              		.loc 1 244 33 is_stmt 0 view .LVU32
 162 001a 42F6E062 		movw	r2, #12000
 163 001e A4F8CE20 		strh	r2, [r4, #206]	@ movhi
 245:Src/util.c    ****   rtP_Left.n_max                = N_MOT_MAX << 4;                       // fixdt(1,16,4)
 164              		.loc 1 245 3 is_stmt 1 view .LVU33
 165              		.loc 1 245 33 is_stmt 0 view .LVU34
 166 0022 4FF47A51 		mov	r1, #16000
 167 0026 A4F8DA10 		strh	r1, [r4, #218]	@ movhi
 246:Src/util.c    ****   rtP_Left.b_fieldWeakEna       = FIELD_WEAK_ENA; 
 168              		.loc 1 246 3 is_stmt 1 view .LVU35
 169              		.loc 1 246 33 is_stmt 0 view .LVU36
 170 002a 84F8FE30 		strb	r3, [r4, #254]
 247:Src/util.c    ****   rtP_Left.id_fieldWeakMax      = (FIELD_WEAK_MAX * A2BIT_CONV) << 4;   // fixdt(1,16,4)
 171              		.loc 1 247 3 is_stmt 1 view .LVU37
 172              		.loc 1 247 33 is_stmt 0 view .LVU38
 173 002e 4FF47A63 		mov	r3, #4000
 174 0032 A4F8D030 		strh	r3, [r4, #208]	@ movhi
 248:Src/util.c    ****   rtP_Left.a_phaAdvMax          = PHASE_ADV_MAX << 4;                   // fixdt(1,16,4)
 175              		.loc 1 248 3 is_stmt 1 view .LVU39
 176              		.loc 1 248 33 is_stmt 0 view .LVU40
 177 0036 4FF4C873 		mov	r3, #400
 178 003a A4F8CC30 		strh	r3, [r4, #204]	@ movhi
 249:Src/util.c    ****   rtP_Left.r_fieldWeakHi        = FIELD_WEAK_HI << 4;                   // fixdt(1,16,4)
 179              		.loc 1 249 3 is_stmt 1 view .LVU41
 180              		.loc 1 249 33 is_stmt 0 view .LVU42
 181 003e A4F8E010 		strh	r1, [r4, #224]	@ movhi
 250:Src/util.c    ****   rtP_Left.r_fieldWeakLo        = FIELD_WEAK_LO << 4;                   // fixdt(1,16,4)
 182              		.loc 1 250 3 is_stmt 1 view .LVU43
 183              		.loc 1 250 33 is_stmt 0 view .LVU44
 184 0042 A4F8E220 		strh	r2, [r4, #226]	@ movhi
 251:Src/util.c    **** 
 252:Src/util.c    ****   rtP_Right                     = rtP_Left;     // Copy the Left motor parameters to the Right moto
 185              		.loc 1 252 3 is_stmt 1 view .LVU45
 186              		.loc 1 252 33 is_stmt 0 view .LVU46
 187 0046 104D     		ldr	r5, .L11+4
 188 0048 4FF48072 		mov	r2, #256
 189 004c 2146     		mov	r1, r4
 190 004e 2846     		mov	r0, r5
 191 0050 FFF7FEFF 		bl	memcpy
 192              	.LVL9:
 253:Src/util.c    ****   rtP_Right.z_selPhaCurMeasABC  = 1;            // Right motor measured current phases {Blue, Yello
 193              		.loc 1 253 3 is_stmt 1 view .LVU47
 194              		.loc 1 253 33 is_stmt 0 view .LVU48
 195 0054 85F8FA60 		strb	r6, [r5, #250]
 254:Src/util.c    **** 
 255:Src/util.c    ****   /* Pack LEFT motor data into RTM */
 256:Src/util.c    ****   rtM_Left->defaultParam        = &rtP_Left;
 196              		.loc 1 256 3 is_stmt 1 view .LVU49
 197              		.loc 1 256 33 is_stmt 0 view .LVU50
 198 0058 0C48     		ldr	r0, .L11+8
 199 005a 0460     		str	r4, [r0]
 257:Src/util.c    ****   rtM_Left->dwork               = &rtDW_Left;
 200              		.loc 1 257 3 is_stmt 1 view .LVU51
 201              		.loc 1 257 33 is_stmt 0 view .LVU52
 202 005c 0C4B     		ldr	r3, .L11+12
 203 005e C360     		str	r3, [r0, #12]
 258:Src/util.c    ****   rtM_Left->inputs              = &rtU_Left;
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 9


 204              		.loc 1 258 3 is_stmt 1 view .LVU53
 205              		.loc 1 258 33 is_stmt 0 view .LVU54
 206 0060 0C4B     		ldr	r3, .L11+16
 207 0062 4360     		str	r3, [r0, #4]
 259:Src/util.c    ****   rtM_Left->outputs             = &rtY_Left;
 208              		.loc 1 259 3 is_stmt 1 view .LVU55
 209              		.loc 1 259 33 is_stmt 0 view .LVU56
 210 0064 0C4B     		ldr	r3, .L11+20
 211 0066 8360     		str	r3, [r0, #8]
 260:Src/util.c    **** 
 261:Src/util.c    ****   /* Pack RIGHT motor data into RTM */
 262:Src/util.c    ****   rtM_Right->defaultParam       = &rtP_Right;
 212              		.loc 1 262 3 is_stmt 1 view .LVU57
 213              		.loc 1 262 33 is_stmt 0 view .LVU58
 214 0068 0C4C     		ldr	r4, .L11+24
 215 006a 2560     		str	r5, [r4]
 263:Src/util.c    ****   rtM_Right->dwork              = &rtDW_Right;
 216              		.loc 1 263 3 is_stmt 1 view .LVU59
 217              		.loc 1 263 33 is_stmt 0 view .LVU60
 218 006c 0C4B     		ldr	r3, .L11+28
 219 006e E360     		str	r3, [r4, #12]
 264:Src/util.c    ****   rtM_Right->inputs             = &rtU_Right;
 220              		.loc 1 264 3 is_stmt 1 view .LVU61
 221              		.loc 1 264 33 is_stmt 0 view .LVU62
 222 0070 0C4B     		ldr	r3, .L11+32
 223 0072 6360     		str	r3, [r4, #4]
 265:Src/util.c    ****   rtM_Right->outputs            = &rtY_Right;
 224              		.loc 1 265 3 is_stmt 1 view .LVU63
 225              		.loc 1 265 33 is_stmt 0 view .LVU64
 226 0074 0C4B     		ldr	r3, .L11+36
 227 0076 A360     		str	r3, [r4, #8]
 266:Src/util.c    **** 
 267:Src/util.c    ****   /* Initialize BLDC controllers */
 268:Src/util.c    ****   BLDC_controller_initialize(rtM_Left);
 228              		.loc 1 268 3 is_stmt 1 view .LVU65
 229 0078 FFF7FEFF 		bl	BLDC_controller_initialize
 230              	.LVL10:
 269:Src/util.c    ****   BLDC_controller_initialize(rtM_Right);
 231              		.loc 1 269 3 view .LVU66
 232 007c 2046     		mov	r0, r4
 233 007e FFF7FEFF 		bl	BLDC_controller_initialize
 234              	.LVL11:
 270:Src/util.c    **** }
 235              		.loc 1 270 1 is_stmt 0 view .LVU67
 236 0082 70BD     		pop	{r4, r5, r6, pc}
 237              	.L12:
 238              		.align	2
 239              	.L11:
 240 0084 00000000 		.word	rtP_Left
 241 0088 00000000 		.word	.LANCHOR0
 242 008c 00000000 		.word	.LANCHOR1
 243 0090 00000000 		.word	.LANCHOR2
 244 0094 00000000 		.word	.LANCHOR3
 245 0098 00000000 		.word	.LANCHOR4
 246 009c 00000000 		.word	.LANCHOR5
 247 00a0 00000000 		.word	.LANCHOR6
 248 00a4 00000000 		.word	.LANCHOR7
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 10


 249 00a8 00000000 		.word	.LANCHOR8
 250              		.cfi_endproc
 251              	.LFE68:
 253              		.section	.text.Input_Lim_Init,"ax",%progbits
 254              		.align	1
 255              		.global	Input_Lim_Init
 256              		.syntax unified
 257              		.thumb
 258              		.thumb_func
 259              		.fpu softvfp
 261              	Input_Lim_Init:
 262              	.LFB69:
 271:Src/util.c    **** 
 272:Src/util.c    **** void Input_Lim_Init(void) {     // Input Limitations - ! Do NOT touch !
 263              		.loc 1 272 27 is_stmt 1 view -0
 264              		.cfi_startproc
 265              		@ args = 0, pretend = 0, frame = 0
 266              		@ frame_needed = 0, uses_anonymous_args = 0
 267              		@ link register save eliminated.
 273:Src/util.c    ****   if (rtP_Left.b_fieldWeakEna || rtP_Right.b_fieldWeakEna) {
 268              		.loc 1 273 3 view .LVU69
 269              		.loc 1 273 15 is_stmt 0 view .LVU70
 270 0000 0C4B     		ldr	r3, .L17
 271 0002 93F8FE30 		ldrb	r3, [r3, #254]	@ zero_extendqisi2
 272              		.loc 1 273 6 view .LVU71
 273 0006 1BB9     		cbnz	r3, .L14
 274              		.loc 1 273 43 discriminator 1 view .LVU72
 275 0008 0B4B     		ldr	r3, .L17+4
 276 000a 93F8FE30 		ldrb	r3, [r3, #254]	@ zero_extendqisi2
 277              		.loc 1 273 31 discriminator 1 view .LVU73
 278 000e 43B1     		cbz	r3, .L15
 279              	.L14:
 274:Src/util.c    ****     INPUT_MAX = MAX( 1000, FIELD_WEAK_HI);
 280              		.loc 1 274 5 is_stmt 1 view .LVU74
 281              		.loc 1 274 15 is_stmt 0 view .LVU75
 282 0010 0A4B     		ldr	r3, .L17+8
 283 0012 4FF47A72 		mov	r2, #1000
 284 0016 1A80     		strh	r2, [r3]	@ movhi
 275:Src/util.c    ****     INPUT_MIN = MIN(-1000,-FIELD_WEAK_HI);
 285              		.loc 1 275 5 is_stmt 1 view .LVU76
 286              		.loc 1 275 15 is_stmt 0 view .LVU77
 287 0018 094B     		ldr	r3, .L17+12
 288 001a 4FF61842 		movw	r2, #64536
 289 001e 1A80     		strh	r2, [r3]	@ movhi
 290 0020 7047     		bx	lr
 291              	.L15:
 276:Src/util.c    ****   } else {
 277:Src/util.c    ****     INPUT_MAX =  1000;
 292              		.loc 1 277 5 is_stmt 1 view .LVU78
 293              		.loc 1 277 15 is_stmt 0 view .LVU79
 294 0022 064B     		ldr	r3, .L17+8
 295 0024 4FF47A72 		mov	r2, #1000
 296 0028 1A80     		strh	r2, [r3]	@ movhi
 278:Src/util.c    ****     INPUT_MIN = -1000;
 297              		.loc 1 278 5 is_stmt 1 view .LVU80
 298              		.loc 1 278 15 is_stmt 0 view .LVU81
 299 002a 054B     		ldr	r3, .L17+12
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 11


 300 002c 4FF61842 		movw	r2, #64536
 301 0030 1A80     		strh	r2, [r3]	@ movhi
 279:Src/util.c    ****   }
 280:Src/util.c    **** }
 302              		.loc 1 280 1 view .LVU82
 303 0032 7047     		bx	lr
 304              	.L18:
 305              		.align	2
 306              	.L17:
 307 0034 00000000 		.word	rtP_Left
 308 0038 00000000 		.word	.LANCHOR0
 309 003c 00000000 		.word	.LANCHOR9
 310 0040 00000000 		.word	.LANCHOR10
 311              		.cfi_endproc
 312              	.LFE69:
 314              		.section	.text.UART_DisableRxErrors,"ax",%progbits
 315              		.align	1
 316              		.global	UART_DisableRxErrors
 317              		.syntax unified
 318              		.thumb
 319              		.thumb_func
 320              		.fpu softvfp
 322              	UART_DisableRxErrors:
 323              	.LVL12:
 324              	.LFB71:
 281:Src/util.c    **** 
 282:Src/util.c    **** void Input_Init(void) {
 283:Src/util.c    ****   #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
 284:Src/util.c    ****     PPM_Init();
 285:Src/util.c    ****   #endif
 286:Src/util.c    **** 
 287:Src/util.c    ****  #if defined(CONTROL_PWM_LEFT) || defined(CONTROL_PWM_RIGHT)
 288:Src/util.c    ****     PWM_Init();
 289:Src/util.c    ****   #endif
 290:Src/util.c    **** 
 291:Src/util.c    ****   #ifdef CONTROL_NUNCHUK
 292:Src/util.c    ****     I2C_Init();
 293:Src/util.c    ****     Nunchuk_Init();
 294:Src/util.c    ****   #endif
 295:Src/util.c    **** 
 296:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(FEEDBACK_SERIAL_USA
 297:Src/util.c    ****     UART2_Init();
 298:Src/util.c    ****   #endif
 299:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(FEEDBACK_SERIAL_USA
 300:Src/util.c    ****     UART3_Init();
 301:Src/util.c    ****   #endif
 302:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
 303:Src/util.c    ****     HAL_UART_Receive_DMA(&huart2, (uint8_t *)rx_buffer_L, sizeof(rx_buffer_L));
 304:Src/util.c    ****     UART_DisableRxErrors(&huart2);
 305:Src/util.c    ****   #endif
 306:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
 307:Src/util.c    ****     HAL_UART_Receive_DMA(&huart3, (uint8_t *)rx_buffer_R, sizeof(rx_buffer_R));
 308:Src/util.c    ****     UART_DisableRxErrors(&huart3);
 309:Src/util.c    ****   #endif
 310:Src/util.c    **** 
 311:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 312:Src/util.c    ****     uint16_t writeCheck, readVal;
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 12


 313:Src/util.c    ****     HAL_FLASH_Unlock();
 314:Src/util.c    ****     EE_Init();            /* EEPROM Init */
 315:Src/util.c    ****     EE_ReadVariable(VirtAddVarTab[0], &writeCheck);
 316:Src/util.c    ****     if (writeCheck == FLASH_WRITE_KEY) {
 317:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[1] , &readVal); rtP_Left.i_max = rtP_Right.i_max = (int16_t)rea
 318:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 319:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 320:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 321:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 322:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 323:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 324:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 325:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 326:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 327:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 328:Src/util.c    ****       }
 329:Src/util.c    ****     } else {
 330:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 331:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 332:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 333:Src/util.c    ****         } else {
 334:Src/util.c    ****           input1[i].typ = input1[i].typDef;
 335:Src/util.c    ****         }
 336:Src/util.c    ****         if (input2[i].typDef == 3) {
 337:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 338:Src/util.c    ****         } else {
 339:Src/util.c    ****           input2[i].typ = input2[i].typDef;
 340:Src/util.c    ****         }
 341:Src/util.c    ****       }
 342:Src/util.c    ****     }
 343:Src/util.c    ****     HAL_FLASH_Lock();
 344:Src/util.c    ****   #endif
 345:Src/util.c    **** 
 346:Src/util.c    ****   #ifdef VARIANT_TRANSPOTTER
 347:Src/util.c    ****     enable = 1;
 348:Src/util.c    **** 
 349:Src/util.c    ****     HAL_FLASH_Unlock();
 350:Src/util.c    ****     EE_Init();            /* EEPROM Init */
 351:Src/util.c    ****     EE_ReadVariable(VirtAddVarTab[0], &saveValue);
 352:Src/util.c    ****     HAL_FLASH_Lock();
 353:Src/util.c    **** 
 354:Src/util.c    ****     setDistance = saveValue / 1000.0;
 355:Src/util.c    ****     if (setDistance < 0.2) {
 356:Src/util.c    ****       setDistance = 1.0;
 357:Src/util.c    ****     }
 358:Src/util.c    ****   #endif
 359:Src/util.c    **** 
 360:Src/util.c    ****   #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
 361:Src/util.c    ****     I2C_Init();
 362:Src/util.c    ****     HAL_Delay(50);
 363:Src/util.c    ****     lcd.pcf8574.PCF_I2C_ADDRESS = 0x27;
 364:Src/util.c    ****     lcd.pcf8574.PCF_I2C_TIMEOUT = 5;
 365:Src/util.c    ****     lcd.pcf8574.i2c             = hi2c2;
 366:Src/util.c    ****     lcd.NUMBER_OF_LINES         = NUMBER_OF_LINES_2;
 367:Src/util.c    ****     lcd.type                    = TYPE0;
 368:Src/util.c    **** 
 369:Src/util.c    ****     if(LCD_Init(&lcd)!=LCD_OK) {
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 13


 370:Src/util.c    ****         // error occured
 371:Src/util.c    ****         //TODO while(1);
 372:Src/util.c    ****     }
 373:Src/util.c    **** 
 374:Src/util.c    ****     LCD_ClearDisplay(&lcd);
 375:Src/util.c    ****     HAL_Delay(5);
 376:Src/util.c    ****     LCD_SetLocation(&lcd, 0, 0);
 377:Src/util.c    ****     #ifdef VARIANT_TRANSPOTTER
 378:Src/util.c    ****       LCD_WriteString(&lcd, "TranspOtter V2.1");
 379:Src/util.c    ****     #else
 380:Src/util.c    ****       LCD_WriteString(&lcd, "Hover V2.0");
 381:Src/util.c    ****     #endif
 382:Src/util.c    ****     LCD_SetLocation(&lcd,  0, 1); LCD_WriteString(&lcd, "Initializing...");
 383:Src/util.c    ****   #endif
 384:Src/util.c    **** 
 385:Src/util.c    ****   #if defined(VARIANT_TRANSPOTTER) && defined(SUPPORT_LCD)
 386:Src/util.c    ****     LCD_ClearDisplay(&lcd);
 387:Src/util.c    ****     HAL_Delay(5);
 388:Src/util.c    ****     LCD_SetLocation(&lcd,  0, 1); LCD_WriteString(&lcd, "Bat:");
 389:Src/util.c    ****     LCD_SetLocation(&lcd,  8, 1); LCD_WriteString(&lcd, "V");
 390:Src/util.c    ****     LCD_SetLocation(&lcd, 15, 1); LCD_WriteString(&lcd, "A");
 391:Src/util.c    ****     LCD_SetLocation(&lcd,  0, 0); LCD_WriteString(&lcd, "Len:");
 392:Src/util.c    ****     LCD_SetLocation(&lcd,  8, 0); LCD_WriteString(&lcd, "m(");
 393:Src/util.c    ****     LCD_SetLocation(&lcd, 14, 0); LCD_WriteString(&lcd, "m)");
 394:Src/util.c    ****   #endif
 395:Src/util.c    **** }
 396:Src/util.c    **** 
 397:Src/util.c    **** /**
 398:Src/util.c    ****   * @brief  Disable Rx Errors detection interrupts on UART peripheral (since we do not want DMA to 
 399:Src/util.c    ****   *         The incorrect data will be filtered based on the START_FRAME and checksum.
 400:Src/util.c    ****   * @param  huart: UART handle.
 401:Src/util.c    ****   * @retval None
 402:Src/util.c    ****   */
 403:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USAR
 404:Src/util.c    ****     defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USAR
 405:Src/util.c    **** void UART_DisableRxErrors(UART_HandleTypeDef *huart)
 406:Src/util.c    **** {  
 325              		.loc 1 406 1 is_stmt 1 view -0
 326              		.cfi_startproc
 327              		@ args = 0, pretend = 0, frame = 0
 328              		@ frame_needed = 0, uses_anonymous_args = 0
 329              		@ link register save eliminated.
 407:Src/util.c    ****   CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);    /* Disable PE (Parity Error) interrupts */  
 330              		.loc 1 407 3 view .LVU84
 331 0000 0268     		ldr	r2, [r0]
 332 0002 D368     		ldr	r3, [r2, #12]
 333 0004 23F48073 		bic	r3, r3, #256
 334 0008 D360     		str	r3, [r2, #12]
 408:Src/util.c    ****   CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);     /* Disable EIE (Frame error, noise error, ove
 335              		.loc 1 408 3 view .LVU85
 336 000a 0268     		ldr	r2, [r0]
 337 000c 5369     		ldr	r3, [r2, #20]
 338 000e 23F00103 		bic	r3, r3, #1
 339 0012 5361     		str	r3, [r2, #20]
 409:Src/util.c    **** }
 340              		.loc 1 409 1 is_stmt 0 view .LVU86
 341 0014 7047     		bx	lr
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 14


 342              		.cfi_endproc
 343              	.LFE71:
 345              		.section	.text.poweronMelody,"ax",%progbits
 346              		.align	1
 347              		.global	poweronMelody
 348              		.syntax unified
 349              		.thumb
 350              		.thumb_func
 351              		.fpu softvfp
 353              	poweronMelody:
 354              	.LFB72:
 410:Src/util.c    **** #endif
 411:Src/util.c    **** 
 412:Src/util.c    **** 
 413:Src/util.c    **** /* =========================== General Functions =========================== */
 414:Src/util.c    **** 
 415:Src/util.c    **** void poweronMelody(void) {
 355              		.loc 1 415 26 is_stmt 1 view -0
 356              		.cfi_startproc
 357              		@ args = 0, pretend = 0, frame = 0
 358              		@ frame_needed = 0, uses_anonymous_args = 0
 359 0000 10B5     		push	{r4, lr}
 360              	.LCFI5:
 361              		.cfi_def_cfa_offset 8
 362              		.cfi_offset 4, -8
 363              		.cfi_offset 14, -4
 416:Src/util.c    ****     buzzerCount = 0;  // prevent interraction with beep counter
 364              		.loc 1 416 5 view .LVU88
 365              		.loc 1 416 17 is_stmt 0 view .LVU89
 366 0002 084B     		ldr	r3, .L24
 367 0004 0022     		movs	r2, #0
 368 0006 1A70     		strb	r2, [r3]
 417:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 369              		.loc 1 417 5 is_stmt 1 view .LVU90
 370              	.LBB2:
 371              		.loc 1 417 10 view .LVU91
 372              	.LVL13:
 373              		.loc 1 417 14 is_stmt 0 view .LVU92
 374 0008 0824     		movs	r4, #8
 375              		.loc 1 417 5 view .LVU93
 376 000a 05E0     		b	.L21
 377              	.LVL14:
 378              	.L22:
 418:Src/util.c    ****       buzzerFreq = (uint8_t)i;
 379              		.loc 1 418 7 is_stmt 1 discriminator 3 view .LVU94
 380              		.loc 1 418 18 is_stmt 0 discriminator 3 view .LVU95
 381 000c 064B     		ldr	r3, .L24+4
 382 000e 1C70     		strb	r4, [r3]
 419:Src/util.c    ****       HAL_Delay(100);
 383              		.loc 1 419 7 is_stmt 1 discriminator 3 view .LVU96
 384 0010 6420     		movs	r0, #100
 385 0012 FFF7FEFF 		bl	HAL_Delay
 386              	.LVL15:
 417:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 387              		.loc 1 417 29 discriminator 3 view .LVU97
 417:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 388              		.loc 1 417 30 is_stmt 0 discriminator 3 view .LVU98
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 15


 389 0016 013C     		subs	r4, r4, #1
 390              	.LVL16:
 391              	.L21:
 417:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 392              		.loc 1 417 21 is_stmt 1 discriminator 1 view .LVU99
 417:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 393              		.loc 1 417 5 is_stmt 0 discriminator 1 view .LVU100
 394 0018 002C     		cmp	r4, #0
 395 001a F7DA     		bge	.L22
 396              	.LBE2:
 420:Src/util.c    ****     }
 421:Src/util.c    ****     buzzerFreq = 0;
 397              		.loc 1 421 5 is_stmt 1 view .LVU101
 398              		.loc 1 421 16 is_stmt 0 view .LVU102
 399 001c 024B     		ldr	r3, .L24+4
 400 001e 0022     		movs	r2, #0
 401 0020 1A70     		strb	r2, [r3]
 422:Src/util.c    **** }
 402              		.loc 1 422 1 view .LVU103
 403 0022 10BD     		pop	{r4, pc}
 404              	.LVL17:
 405              	.L25:
 406              		.loc 1 422 1 view .LVU104
 407              		.align	2
 408              	.L24:
 409 0024 00000000 		.word	buzzerCount
 410 0028 00000000 		.word	buzzerFreq
 411              		.cfi_endproc
 412              	.LFE72:
 414              		.section	.text.beepCount,"ax",%progbits
 415              		.align	1
 416              		.global	beepCount
 417              		.syntax unified
 418              		.thumb
 419              		.thumb_func
 420              		.fpu softvfp
 422              	beepCount:
 423              	.LVL18:
 424              	.LFB73:
 423:Src/util.c    **** 
 424:Src/util.c    **** void beepCount(uint8_t cnt, uint8_t freq, uint8_t pattern) {
 425              		.loc 1 424 60 is_stmt 1 view -0
 426              		.cfi_startproc
 427              		@ args = 0, pretend = 0, frame = 0
 428              		@ frame_needed = 0, uses_anonymous_args = 0
 429              		@ link register save eliminated.
 425:Src/util.c    ****     buzzerCount   = cnt;
 430              		.loc 1 425 5 view .LVU106
 431              		.loc 1 425 19 is_stmt 0 view .LVU107
 432 0000 034B     		ldr	r3, .L27
 433 0002 1870     		strb	r0, [r3]
 426:Src/util.c    ****     buzzerFreq    = freq;
 434              		.loc 1 426 5 is_stmt 1 view .LVU108
 435              		.loc 1 426 19 is_stmt 0 view .LVU109
 436 0004 034B     		ldr	r3, .L27+4
 437 0006 1970     		strb	r1, [r3]
 427:Src/util.c    ****     buzzerPattern = pattern;
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 16


 438              		.loc 1 427 5 is_stmt 1 view .LVU110
 439              		.loc 1 427 19 is_stmt 0 view .LVU111
 440 0008 034B     		ldr	r3, .L27+8
 441 000a 1A70     		strb	r2, [r3]
 428:Src/util.c    **** }
 442              		.loc 1 428 1 view .LVU112
 443 000c 7047     		bx	lr
 444              	.L28:
 445 000e 00BF     		.align	2
 446              	.L27:
 447 0010 00000000 		.word	buzzerCount
 448 0014 00000000 		.word	buzzerFreq
 449 0018 00000000 		.word	buzzerPattern
 450              		.cfi_endproc
 451              	.LFE73:
 453              		.section	.text.beepLong,"ax",%progbits
 454              		.align	1
 455              		.global	beepLong
 456              		.syntax unified
 457              		.thumb
 458              		.thumb_func
 459              		.fpu softvfp
 461              	beepLong:
 462              	.LVL19:
 463              	.LFB74:
 429:Src/util.c    **** 
 430:Src/util.c    **** void beepLong(uint8_t freq) {
 464              		.loc 1 430 29 is_stmt 1 view -0
 465              		.cfi_startproc
 466              		@ args = 0, pretend = 0, frame = 0
 467              		@ frame_needed = 0, uses_anonymous_args = 0
 468              		.loc 1 430 29 is_stmt 0 view .LVU114
 469 0000 38B5     		push	{r3, r4, r5, lr}
 470              	.LCFI6:
 471              		.cfi_def_cfa_offset 16
 472              		.cfi_offset 3, -16
 473              		.cfi_offset 4, -12
 474              		.cfi_offset 5, -8
 475              		.cfi_offset 14, -4
 431:Src/util.c    ****     buzzerCount = 0;  // prevent interraction with beep counter
 476              		.loc 1 431 5 is_stmt 1 view .LVU115
 477              		.loc 1 431 17 is_stmt 0 view .LVU116
 478 0002 0025     		movs	r5, #0
 479 0004 044B     		ldr	r3, .L31
 480 0006 1D70     		strb	r5, [r3]
 432:Src/util.c    ****     buzzerFreq = freq;
 481              		.loc 1 432 5 is_stmt 1 view .LVU117
 482              		.loc 1 432 16 is_stmt 0 view .LVU118
 483 0008 044C     		ldr	r4, .L31+4
 484 000a 2070     		strb	r0, [r4]
 433:Src/util.c    ****     HAL_Delay(500);
 485              		.loc 1 433 5 is_stmt 1 view .LVU119
 486 000c 4FF4FA70 		mov	r0, #500
 487              	.LVL20:
 488              		.loc 1 433 5 is_stmt 0 view .LVU120
 489 0010 FFF7FEFF 		bl	HAL_Delay
 490              	.LVL21:
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 17


 434:Src/util.c    ****     buzzerFreq = 0;
 491              		.loc 1 434 5 is_stmt 1 view .LVU121
 492              		.loc 1 434 16 is_stmt 0 view .LVU122
 493 0014 2570     		strb	r5, [r4]
 435:Src/util.c    **** }
 494              		.loc 1 435 1 view .LVU123
 495 0016 38BD     		pop	{r3, r4, r5, pc}
 496              	.L32:
 497              		.align	2
 498              	.L31:
 499 0018 00000000 		.word	buzzerCount
 500 001c 00000000 		.word	buzzerFreq
 501              		.cfi_endproc
 502              	.LFE74:
 504              		.section	.text.beepShort,"ax",%progbits
 505              		.align	1
 506              		.global	beepShort
 507              		.syntax unified
 508              		.thumb
 509              		.thumb_func
 510              		.fpu softvfp
 512              	beepShort:
 513              	.LVL22:
 514              	.LFB75:
 436:Src/util.c    **** 
 437:Src/util.c    **** void beepShort(uint8_t freq) {
 515              		.loc 1 437 30 is_stmt 1 view -0
 516              		.cfi_startproc
 517              		@ args = 0, pretend = 0, frame = 0
 518              		@ frame_needed = 0, uses_anonymous_args = 0
 519              		.loc 1 437 30 is_stmt 0 view .LVU125
 520 0000 38B5     		push	{r3, r4, r5, lr}
 521              	.LCFI7:
 522              		.cfi_def_cfa_offset 16
 523              		.cfi_offset 3, -16
 524              		.cfi_offset 4, -12
 525              		.cfi_offset 5, -8
 526              		.cfi_offset 14, -4
 438:Src/util.c    ****     buzzerCount = 0;  // prevent interraction with beep counter
 527              		.loc 1 438 5 is_stmt 1 view .LVU126
 528              		.loc 1 438 17 is_stmt 0 view .LVU127
 529 0002 0025     		movs	r5, #0
 530 0004 044B     		ldr	r3, .L35
 531 0006 1D70     		strb	r5, [r3]
 439:Src/util.c    ****     buzzerFreq = freq;
 532              		.loc 1 439 5 is_stmt 1 view .LVU128
 533              		.loc 1 439 16 is_stmt 0 view .LVU129
 534 0008 044C     		ldr	r4, .L35+4
 535 000a 2070     		strb	r0, [r4]
 440:Src/util.c    ****     HAL_Delay(100);
 536              		.loc 1 440 5 is_stmt 1 view .LVU130
 537 000c 6420     		movs	r0, #100
 538              	.LVL23:
 539              		.loc 1 440 5 is_stmt 0 view .LVU131
 540 000e FFF7FEFF 		bl	HAL_Delay
 541              	.LVL24:
 441:Src/util.c    ****     buzzerFreq = 0;
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 18


 542              		.loc 1 441 5 is_stmt 1 view .LVU132
 543              		.loc 1 441 16 is_stmt 0 view .LVU133
 544 0012 2570     		strb	r5, [r4]
 442:Src/util.c    **** }
 545              		.loc 1 442 1 view .LVU134
 546 0014 38BD     		pop	{r3, r4, r5, pc}
 547              	.L36:
 548 0016 00BF     		.align	2
 549              	.L35:
 550 0018 00000000 		.word	buzzerCount
 551 001c 00000000 		.word	buzzerFreq
 552              		.cfi_endproc
 553              	.LFE75:
 555              		.section	.text.beepShortMany,"ax",%progbits
 556              		.align	1
 557              		.global	beepShortMany
 558              		.syntax unified
 559              		.thumb
 560              		.thumb_func
 561              		.fpu softvfp
 563              	beepShortMany:
 564              	.LVL25:
 565              	.LFB76:
 443:Src/util.c    **** 
 444:Src/util.c    **** void beepShortMany(uint8_t cnt, int8_t dir) {
 566              		.loc 1 444 45 is_stmt 1 view -0
 567              		.cfi_startproc
 568              		@ args = 0, pretend = 0, frame = 0
 569              		@ frame_needed = 0, uses_anonymous_args = 0
 570              		.loc 1 444 45 is_stmt 0 view .LVU136
 571 0000 38B5     		push	{r3, r4, r5, lr}
 572              	.LCFI8:
 573              		.cfi_def_cfa_offset 16
 574              		.cfi_offset 3, -16
 575              		.cfi_offset 4, -12
 576              		.cfi_offset 5, -8
 577              		.cfi_offset 14, -4
 578 0002 0446     		mov	r4, r0
 445:Src/util.c    ****     if (dir >= 0) {   // increasing tone
 579              		.loc 1 445 5 is_stmt 1 view .LVU137
 580              		.loc 1 445 8 is_stmt 0 view .LVU138
 581 0004 0029     		cmp	r1, #0
 582 0006 15DB     		blt	.L43
 446:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 583              		.loc 1 446 7 is_stmt 1 view .LVU139
 584              	.LBB3:
 585              		.loc 1 446 11 view .LVU140
 586              		.loc 1 446 19 is_stmt 0 view .LVU141
 587 0008 4400     		lsls	r4, r0, #1
 588 000a E4B2     		uxtb	r4, r4
 589              	.LVL26:
 590              		.loc 1 446 7 view .LVU142
 591 000c 05E0     		b	.L39
 592              	.LVL27:
 593              	.L40:
 447:Src/util.c    ****         beepShort(i + 3);
 594              		.loc 1 447 9 is_stmt 1 discriminator 3 view .LVU143
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 19


 595 000e E01C     		adds	r0, r4, #3
 596 0010 C0B2     		uxtb	r0, r0
 597 0012 FFF7FEFF 		bl	beepShort
 598              	.LVL28:
 446:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 599              		.loc 1 446 38 discriminator 3 view .LVU144
 446:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 600              		.loc 1 446 39 is_stmt 0 discriminator 3 view .LVU145
 601 0016 023C     		subs	r4, r4, #2
 602              	.LVL29:
 446:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 603              		.loc 1 446 39 discriminator 3 view .LVU146
 604 0018 E4B2     		uxtb	r4, r4
 605              	.LVL30:
 606              	.L39:
 446:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 607              		.loc 1 446 30 is_stmt 1 discriminator 1 view .LVU147
 446:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 608              		.loc 1 446 7 is_stmt 0 discriminator 1 view .LVU148
 609 001a 012C     		cmp	r4, #1
 610 001c F7D8     		bhi	.L40
 611              	.LVL31:
 612              	.L37:
 446:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 613              		.loc 1 446 7 discriminator 1 view .LVU149
 614              	.LBE3:
 448:Src/util.c    ****       }
 449:Src/util.c    ****     } else {          // decreasing tone
 450:Src/util.c    ****       for(uint8_t i = 2; i <= 2*cnt; i=i+2) {
 451:Src/util.c    ****         beepShort(i + 3);
 452:Src/util.c    ****       }
 453:Src/util.c    ****     }
 454:Src/util.c    **** }
 615              		.loc 1 454 1 view .LVU150
 616 001e 38BD     		pop	{r3, r4, r5, pc}
 617              	.LVL32:
 618              	.L42:
 619              	.LBB4:
 451:Src/util.c    ****       }
 620              		.loc 1 451 9 is_stmt 1 discriminator 3 view .LVU151
 621 0020 E81C     		adds	r0, r5, #3
 622 0022 C0B2     		uxtb	r0, r0
 623 0024 FFF7FEFF 		bl	beepShort
 624              	.LVL33:
 450:Src/util.c    ****         beepShort(i + 3);
 625              		.loc 1 450 38 discriminator 3 view .LVU152
 450:Src/util.c    ****         beepShort(i + 3);
 626              		.loc 1 450 39 is_stmt 0 discriminator 3 view .LVU153
 627 0028 0235     		adds	r5, r5, #2
 628              	.LVL34:
 450:Src/util.c    ****         beepShort(i + 3);
 629              		.loc 1 450 39 discriminator 3 view .LVU154
 630 002a EDB2     		uxtb	r5, r5
 631              	.LVL35:
 632              	.L38:
 450:Src/util.c    ****         beepShort(i + 3);
 633              		.loc 1 450 26 is_stmt 1 discriminator 1 view .LVU155
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 20


 450:Src/util.c    ****         beepShort(i + 3);
 634              		.loc 1 450 7 is_stmt 0 discriminator 1 view .LVU156
 635 002c B5EB440F 		cmp	r5, r4, lsl #1
 636 0030 F6DD     		ble	.L42
 637 0032 F4E7     		b	.L37
 638              	.LVL36:
 639              	.L43:
 450:Src/util.c    ****         beepShort(i + 3);
 640              		.loc 1 450 19 view .LVU157
 641 0034 0225     		movs	r5, #2
 642 0036 F9E7     		b	.L38
 643              	.LBE4:
 644              		.cfi_endproc
 645              	.LFE76:
 647              		.section	.text.calcAvgSpeed,"ax",%progbits
 648              		.align	1
 649              		.global	calcAvgSpeed
 650              		.syntax unified
 651              		.thumb
 652              		.thumb_func
 653              		.fpu softvfp
 655              	calcAvgSpeed:
 656              	.LFB77:
 455:Src/util.c    **** 
 456:Src/util.c    **** void calcAvgSpeed(void) {
 657              		.loc 1 456 25 is_stmt 1 view -0
 658              		.cfi_startproc
 659              		@ args = 0, pretend = 0, frame = 0
 660              		@ frame_needed = 0, uses_anonymous_args = 0
 661              		@ link register save eliminated.
 457:Src/util.c    ****     // Calculate measured average speed. The minus sign (-) is because motors spin in opposite dire
 458:Src/util.c    ****     #if   !defined(INVERT_L_DIRECTION) && !defined(INVERT_R_DIRECTION)
 459:Src/util.c    ****       speedAvg    = ( rtY_Left.n_mot - rtY_Right.n_mot) / 2;
 662              		.loc 1 459 7 view .LVU159
 663              		.loc 1 459 31 is_stmt 0 view .LVU160
 664 0000 094B     		ldr	r3, .L46
 665 0002 B3F90830 		ldrsh	r3, [r3, #8]
 666              		.loc 1 459 49 view .LVU161
 667 0006 094A     		ldr	r2, .L46+4
 668 0008 B2F90820 		ldrsh	r2, [r2, #8]
 669              		.loc 1 459 38 view .LVU162
 670 000c 9B1A     		subs	r3, r3, r2
 671              		.loc 1 459 57 view .LVU163
 672 000e 03EBD373 		add	r3, r3, r3, lsr #31
 673              		.loc 1 459 19 view .LVU164
 674 0012 43F34F03 		sbfx	r3, r3, #1, #16
 675 0016 064A     		ldr	r2, .L46+8
 676 0018 1380     		strh	r3, [r2]	@ movhi
 460:Src/util.c    ****     #elif !defined(INVERT_L_DIRECTION) &&  defined(INVERT_R_DIRECTION)
 461:Src/util.c    ****       speedAvg    = ( rtY_Left.n_mot + rtY_Right.n_mot) / 2;
 462:Src/util.c    ****     #elif  defined(INVERT_L_DIRECTION) && !defined(INVERT_R_DIRECTION)
 463:Src/util.c    ****       speedAvg    = (-rtY_Left.n_mot - rtY_Right.n_mot) / 2;
 464:Src/util.c    ****     #elif  defined(INVERT_L_DIRECTION) &&  defined(INVERT_R_DIRECTION)
 465:Src/util.c    ****       speedAvg    = (-rtY_Left.n_mot + rtY_Right.n_mot) / 2;
 466:Src/util.c    ****     #endif
 467:Src/util.c    **** 
 468:Src/util.c    ****     // Handle the case when SPEED_COEFFICIENT sign is negative (which is when most significant bit 
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 21


 469:Src/util.c    ****     if (SPEED_COEFFICIENT & (1 << 16)) {
 677              		.loc 1 469 5 is_stmt 1 view .LVU165
 470:Src/util.c    ****       speedAvg    = -speedAvg;
 471:Src/util.c    ****     } 
 472:Src/util.c    ****     speedAvgAbs   = abs(speedAvg);
 678              		.loc 1 472 5 view .LVU166
 679              		.loc 1 472 21 is_stmt 0 view .LVU167
 680 001a 002B     		cmp	r3, #0
 681 001c B8BF     		it	lt
 682 001e 5B42     		rsblt	r3, r3, #0
 683              		.loc 1 472 19 view .LVU168
 684 0020 044A     		ldr	r2, .L46+12
 685 0022 1380     		strh	r3, [r2]	@ movhi
 473:Src/util.c    **** }
 686              		.loc 1 473 1 view .LVU169
 687 0024 7047     		bx	lr
 688              	.L47:
 689 0026 00BF     		.align	2
 690              	.L46:
 691 0028 00000000 		.word	.LANCHOR4
 692 002c 00000000 		.word	.LANCHOR8
 693 0030 00000000 		.word	.LANCHOR11
 694 0034 00000000 		.word	.LANCHOR12
 695              		.cfi_endproc
 696              	.LFE77:
 698              		.section	.text.standstillHold,"ax",%progbits
 699              		.align	1
 700              		.global	standstillHold
 701              		.syntax unified
 702              		.thumb
 703              		.thumb_func
 704              		.fpu softvfp
 706              	standstillHold:
 707              	.LFB80:
 474:Src/util.c    **** 
 475:Src/util.c    ****  /*
 476:Src/util.c    ****  * Auto-calibration of the ADC Limits
 477:Src/util.c    ****  * This function finds the Minimum, Maximum, and Middle for the ADC input
 478:Src/util.c    ****  * Procedure:
 479:Src/util.c    ****  * - press the power button for more than 5 sec and release after the beep sound
 480:Src/util.c    ****  * - move the potentiometers freely to the min and max limits repeatedly
 481:Src/util.c    ****  * - release potentiometers to the resting postion
 482:Src/util.c    ****  * - press the power button to confirm or wait for the 20 sec timeout
 483:Src/util.c    ****  * The Values will be saved to flash. Values are persistent if you flash with platformio. To erase 
 484:Src/util.c    ****  */
 485:Src/util.c    **** void adcCalibLim(void) {
 486:Src/util.c    **** #ifdef AUTO_CALIBRATION_ENA
 487:Src/util.c    ****   calcAvgSpeed();
 488:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 489:Src/util.c    ****     return;
 490:Src/util.c    ****   }
 491:Src/util.c    **** 
 492:Src/util.c    **** #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 493:Src/util.c    **** 
 494:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 495:Src/util.c    ****   printf("Input calibration started...\r\n");
 496:Src/util.c    ****   #endif
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 22


 497:Src/util.c    **** 
 498:Src/util.c    ****   readInputRaw();
 499:Src/util.c    ****   // Inititalization: MIN = a high value, MAX = a low value
 500:Src/util.c    ****   int32_t  input1_fixdt = input1[inIdx].raw << 16;
 501:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 502:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 503:Src/util.c    ****   int16_t  INPUT1_MID_temp = 0;
 504:Src/util.c    ****   int16_t  INPUT1_MAX_temp = MIN_int16_T;
 505:Src/util.c    ****   int16_t  INPUT2_MIN_temp = MAX_int16_T;
 506:Src/util.c    ****   int16_t  INPUT2_MID_temp = 0;
 507:Src/util.c    ****   int16_t  INPUT2_MAX_temp = MIN_int16_T;
 508:Src/util.c    ****   int16_t  input_margin    = 0;
 509:Src/util.c    ****   uint16_t input_cal_timeout = 0;
 510:Src/util.c    ****   
 511:Src/util.c    ****   #ifdef CONTROL_ADC
 512:Src/util.c    ****   if (inIdx == CONTROL_ADC) {
 513:Src/util.c    ****     input_margin = ADC_MARGIN;
 514:Src/util.c    ****   }
 515:Src/util.c    ****   #endif
 516:Src/util.c    **** 
 517:Src/util.c    ****   // Extract MIN, MAX and MID from ADC while the power button is not pressed
 518:Src/util.c    ****   while (!HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN) && input_cal_timeout++ < 4000) {   // 20 sec ti
 519:Src/util.c    ****     readInputRaw();
 520:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 521:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 522:Src/util.c    ****     
 523:Src/util.c    ****     INPUT1_MID_temp = (int16_t)(input1_fixdt >> 16);// CLAMP(input1_fixdt >> 16, INPUT1_MIN, INPUT1
 524:Src/util.c    ****     INPUT2_MID_temp = (int16_t)(input2_fixdt >> 16);// CLAMP(input2_fixdt >> 16, INPUT2_MIN, INPUT2
 525:Src/util.c    ****     INPUT1_MIN_temp = MIN(INPUT1_MIN_temp, INPUT1_MID_temp);
 526:Src/util.c    ****     INPUT1_MAX_temp = MAX(INPUT1_MAX_temp, INPUT1_MID_temp);
 527:Src/util.c    ****     INPUT2_MIN_temp = MIN(INPUT2_MIN_temp, INPUT2_MID_temp);
 528:Src/util.c    ****     INPUT2_MAX_temp = MAX(INPUT2_MAX_temp, INPUT2_MID_temp);
 529:Src/util.c    ****     HAL_Delay(5);
 530:Src/util.c    ****   }
 531:Src/util.c    **** 
 532:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 533:Src/util.c    ****   printf("Input1 is ");
 534:Src/util.c    ****   #endif
 535:Src/util.c    ****   input1[inIdx].typ = checkInputType(INPUT1_MIN_temp, INPUT1_MID_temp, INPUT1_MAX_temp);
 536:Src/util.c    ****   if (input1[inIdx].typ == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibrat
 537:Src/util.c    ****     input1[inIdx].min = INPUT1_MIN_temp + input_margin;
 538:Src/util.c    ****     input1[inIdx].mid = INPUT1_MID_temp;
 539:Src/util.c    ****     input1[inIdx].max = INPUT1_MAX_temp - input_margin;
 540:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 541:Src/util.c    ****     printf("..OK\r\n");
 542:Src/util.c    ****     #endif
 543:Src/util.c    ****   } else {
 544:Src/util.c    ****     input1[inIdx].typ = 0; // Disable input
 545:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 546:Src/util.c    ****     printf("..NOK\r\n");
 547:Src/util.c    ****     #endif
 548:Src/util.c    ****   }
 549:Src/util.c    **** 
 550:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 551:Src/util.c    ****   printf("Input2 is ");
 552:Src/util.c    ****   #endif
 553:Src/util.c    ****   input2[inIdx].typ = checkInputType(INPUT2_MIN_temp, INPUT2_MID_temp, INPUT2_MAX_temp);
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 23


 554:Src/util.c    ****   if (input2[inIdx].typ == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibrat
 555:Src/util.c    ****     input2[inIdx].min = INPUT2_MIN_temp + input_margin;
 556:Src/util.c    ****     input2[inIdx].mid = INPUT2_MID_temp;
 557:Src/util.c    ****     input2[inIdx].max = INPUT2_MAX_temp - input_margin;
 558:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 559:Src/util.c    ****     printf("..OK\r\n");
 560:Src/util.c    ****     #endif
 561:Src/util.c    ****   } else {
 562:Src/util.c    ****     input2[inIdx].typ = 0; // Disable input
 563:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 564:Src/util.c    ****     printf("..NOK\r\n");
 565:Src/util.c    ****     #endif
 566:Src/util.c    ****   }
 567:Src/util.c    ****   inp_cal_valid = 1;    // Mark calibration to be saved in Flash at shutdown
 568:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 569:Src/util.c    ****   printf("Limits Input1: TYP:%i MIN:%i MID:%i MAX:%i\r\nLimits Input2: TYP:%i MIN:%i MID:%i MAX:%i\
 570:Src/util.c    ****           input1[inIdx].typ, input1[inIdx].min, input1[inIdx].mid, input1[inIdx].max,
 571:Src/util.c    ****           input2[inIdx].typ, input2[inIdx].min, input2[inIdx].mid, input2[inIdx].max);
 572:Src/util.c    ****   #endif
 573:Src/util.c    **** 
 574:Src/util.c    **** #endif
 575:Src/util.c    **** #endif  // AUTO_CALIBRATION_ENA
 576:Src/util.c    **** }
 577:Src/util.c    ****  /*
 578:Src/util.c    ****  * Update Maximum Motor Current Limit (via ADC1) and Maximum Speed Limit (via ADC2)
 579:Src/util.c    ****  * Procedure:
 580:Src/util.c    ****  * - press the power button for more than 5 sec and immediatelly after the beep sound press one mor
 581:Src/util.c    ****  * - move and hold the pots to a desired limit position for Current and Speed
 582:Src/util.c    ****  * - press the power button to confirm or wait for the 10 sec timeout
 583:Src/util.c    ****  */
 584:Src/util.c    **** void updateCurSpdLim(void) {
 585:Src/util.c    ****   calcAvgSpeed();
 586:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 587:Src/util.c    ****     return;
 588:Src/util.c    ****   }
 589:Src/util.c    **** 
 590:Src/util.c    **** #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 591:Src/util.c    **** 
 592:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 593:Src/util.c    ****   printf("Torque and Speed limits update started...\r\n");
 594:Src/util.c    ****   #endif
 595:Src/util.c    **** 
 596:Src/util.c    ****   int32_t  input1_fixdt = input1[inIdx].raw << 16;
 597:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 598:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 599:Src/util.c    ****   uint16_t spd_factor;    // fixdt(0,16,16)
 600:Src/util.c    ****   uint16_t cur_spd_timeout = 0;
 601:Src/util.c    ****   cur_spd_valid = 0;
 602:Src/util.c    **** 
 603:Src/util.c    ****   // Wait for the power button press
 604:Src/util.c    ****   while (!HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN) && cur_spd_timeout++ < 2000) {  // 10 sec timeo
 605:Src/util.c    ****     readInputRaw();
 606:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 607:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 608:Src/util.c    ****     HAL_Delay(5);
 609:Src/util.c    ****   }
 610:Src/util.c    ****   // Calculate scaling factors
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 24


 611:Src/util.c    ****   cur_factor = CLAMP((input1_fixdt - (input1[inIdx].min << 16)) / (input1[inIdx].max - input1[inIdx
 612:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 613:Src/util.c    ****       
 614:Src/util.c    ****   if (input1[inIdx].typ != 0){
 615:Src/util.c    ****     // Update current limit
 616:Src/util.c    ****     rtP_Left.i_max = rtP_Right.i_max  = (int16_t)((I_MOT_MAX * A2BIT_CONV * cur_factor) >> 12);    
 617:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 618:Src/util.c    ****   }
 619:Src/util.c    **** 
 620:Src/util.c    ****   if (input2[inIdx].typ != 0){
 621:Src/util.c    ****     // Update speed limit
 622:Src/util.c    ****     rtP_Left.n_max = rtP_Right.n_max  = (int16_t)((N_MOT_MAX * spd_factor) >> 12);                 
 623:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 624:Src/util.c    ****   }
 625:Src/util.c    **** 
 626:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 627:Src/util.c    ****   // cur_spd_valid: 0 = No limit changed, 1 = Current limit changed, 2 = Speed limit changed, 3 = B
 628:Src/util.c    ****   printf("Limits (%i)\r\nCurrent: fixdt:%li factor%i i_max:%i \r\nSpeed: fixdt:%li factor:%i n_max:
 629:Src/util.c    ****           cur_spd_valid, input1_fixdt, cur_factor, rtP_Left.i_max, input2_fixdt, spd_factor, rtP_Le
 630:Src/util.c    ****   #endif
 631:Src/util.c    **** 
 632:Src/util.c    **** #endif
 633:Src/util.c    **** }
 634:Src/util.c    **** 
 635:Src/util.c    ****  /*
 636:Src/util.c    ****  * Standstill Hold Function
 637:Src/util.c    ****  * This function uses Cruise Control to provide an anti-roll functionality at standstill.
 638:Src/util.c    ****  * Only available and makes sense for FOC VOLTAGE or FOC TORQUE mode.
 639:Src/util.c    ****  * 
 640:Src/util.c    ****  * Input:  none
 641:Src/util.c    ****  * Output: standstillAcv
 642:Src/util.c    ****  */
 643:Src/util.c    **** void standstillHold(void) {
 708              		.loc 1 643 27 is_stmt 1 view -0
 709              		.cfi_startproc
 710              		@ args = 0, pretend = 0, frame = 0
 711              		@ frame_needed = 0, uses_anonymous_args = 0
 712              		@ link register save eliminated.
 644:Src/util.c    ****   #if defined(STANDSTILL_HOLD_ENABLE) && (CTRL_TYP_SEL == FOC_CTRL) && (CTRL_MOD_REQ != SPD_MODE)
 645:Src/util.c    ****     if (!rtP_Left.b_cruiseCtrlEna) {                                  // If Stanstill in NOT Active
 646:Src/util.c    ****       if (((input1[inIdx].cmd > 50 || input2[inIdx].cmd < -50) && speedAvgAbs < 30) // Check if Bra
 647:Src/util.c    ****           || (input2[inIdx].cmd < 20 && speedAvgAbs < 5)) {           // OR Throttle is small AND m
 648:Src/util.c    ****         rtP_Left.n_cruiseMotTgt   = 0;
 649:Src/util.c    ****         rtP_Right.n_cruiseMotTgt  = 0;
 650:Src/util.c    ****         rtP_Left.b_cruiseCtrlEna  = 1;
 651:Src/util.c    ****         rtP_Right.b_cruiseCtrlEna = 1;
 652:Src/util.c    ****         standstillAcv = 1;
 653:Src/util.c    ****       } 
 654:Src/util.c    ****     }
 655:Src/util.c    ****     else {                                                            // If Stanstill is Active -> 
 656:Src/util.c    ****       if (input1[inIdx].cmd < 20 && input2[inIdx].cmd > 50 && !cruiseCtrlAcv) { // Check if Brake i
 657:Src/util.c    ****         rtP_Left.b_cruiseCtrlEna  = 0;
 658:Src/util.c    ****         rtP_Right.b_cruiseCtrlEna = 0;
 659:Src/util.c    ****         standstillAcv = 0;
 660:Src/util.c    ****       }
 661:Src/util.c    ****     }
 662:Src/util.c    ****   #endif
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 25


 663:Src/util.c    **** }
 713              		.loc 1 663 1 view .LVU171
 714 0000 7047     		bx	lr
 715              		.cfi_endproc
 716              	.LFE80:
 718              		.section	.text.electricBrake,"ax",%progbits
 719              		.align	1
 720              		.global	electricBrake
 721              		.syntax unified
 722              		.thumb
 723              		.thumb_func
 724              		.fpu softvfp
 726              	electricBrake:
 727              	.LVL37:
 728              	.LFB81:
 664:Src/util.c    **** 
 665:Src/util.c    ****  /*
 666:Src/util.c    ****  * Electric Brake Function
 667:Src/util.c    ****  * In case of TORQUE mode, this function replaces the motor "freewheel" with a constant braking whe
 668:Src/util.c    ****  * This is useful when a small amount of motor braking is desired instead of "freewheel".
 669:Src/util.c    ****  * 
 670:Src/util.c    ****  * Input: speedBlend = fixdt(0,16,15), reverseDir = {0, 1}
 671:Src/util.c    ****  * Output: input2.cmd (Throtle) with brake component included
 672:Src/util.c    ****  */
 673:Src/util.c    **** void electricBrake(uint16_t speedBlend, uint8_t reverseDir) {
 729              		.loc 1 673 61 view -0
 730              		.cfi_startproc
 731              		@ args = 0, pretend = 0, frame = 0
 732              		@ frame_needed = 0, uses_anonymous_args = 0
 733              		@ link register save eliminated.
 674:Src/util.c    ****   #if defined(ELECTRIC_BRAKE_ENABLE) && (CTRL_TYP_SEL == FOC_CTRL) && (CTRL_MOD_REQ == TRQ_MODE)
 675:Src/util.c    ****     int16_t brakeVal;
 676:Src/util.c    **** 
 677:Src/util.c    ****     // Make sure the Brake pedal is opposite to the direction of motion AND it goes to 0 as we reac
 678:Src/util.c    ****     if (speedAvg > 0) {
 679:Src/util.c    ****       brakeVal = (int16_t)((-ELECTRIC_BRAKE_MAX * speedBlend) >> 15);
 680:Src/util.c    ****     } else {
 681:Src/util.c    ****       brakeVal = (int16_t)(( ELECTRIC_BRAKE_MAX * speedBlend) >> 15);
 682:Src/util.c    ****     }
 683:Src/util.c    **** 
 684:Src/util.c    ****     // Check if direction is reversed
 685:Src/util.c    ****     if (reverseDir) {
 686:Src/util.c    ****       brakeVal = -brakeVal;
 687:Src/util.c    ****     }
 688:Src/util.c    **** 
 689:Src/util.c    ****     // Calculate the new input2.cmd with brake component included
 690:Src/util.c    ****     if (input2[inIdx].cmd >= 0 && input2[inIdx].cmd < ELECTRIC_BRAKE_THRES) {
 691:Src/util.c    ****       input2[inIdx].cmd = MAX(brakeVal, ((ELECTRIC_BRAKE_THRES - input2[inIdx].cmd) * brakeVal) / E
 692:Src/util.c    ****     } else if (input2[inIdx].cmd >= -ELECTRIC_BRAKE_THRES && input2[inIdx].cmd < 0) {
 693:Src/util.c    ****       input2[inIdx].cmd = MIN(brakeVal, ((ELECTRIC_BRAKE_THRES + input2[inIdx].cmd) * brakeVal) / E
 694:Src/util.c    ****     } else if (input2[inIdx].cmd >= ELECTRIC_BRAKE_THRES) {
 695:Src/util.c    ****       input2[inIdx].cmd = MAX(brakeVal, ((input2[inIdx].cmd - ELECTRIC_BRAKE_THRES) * INPUT_MAX) / 
 696:Src/util.c    ****     } else {  // when (input2.cmd < -ELECTRIC_BRAKE_THRES)
 697:Src/util.c    ****       input2[inIdx].cmd = MIN(brakeVal, ((input2[inIdx].cmd + ELECTRIC_BRAKE_THRES) * INPUT_MIN) / 
 698:Src/util.c    ****     }
 699:Src/util.c    ****   #endif
 700:Src/util.c    **** }
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 26


 734              		.loc 1 700 1 view .LVU173
 735 0000 7047     		bx	lr
 736              		.cfi_endproc
 737              	.LFE81:
 739              		.section	.text.cruiseControl,"ax",%progbits
 740              		.align	1
 741              		.global	cruiseControl
 742              		.syntax unified
 743              		.thumb
 744              		.thumb_func
 745              		.fpu softvfp
 747              	cruiseControl:
 748              	.LVL38:
 749              	.LFB82:
 701:Src/util.c    **** 
 702:Src/util.c    ****  /*
 703:Src/util.c    ****  * Cruise Control Function
 704:Src/util.c    ****  * This function activates/deactivates cruise control.
 705:Src/util.c    ****  * 
 706:Src/util.c    ****  * Input: button (as a pulse)
 707:Src/util.c    ****  * Output: cruiseCtrlAcv
 708:Src/util.c    ****  */
 709:Src/util.c    **** void cruiseControl(uint8_t button) {
 750              		.loc 1 709 36 view -0
 751              		.cfi_startproc
 752              		@ args = 0, pretend = 0, frame = 0
 753              		@ frame_needed = 0, uses_anonymous_args = 0
 754              		@ link register save eliminated.
 710:Src/util.c    ****   #ifdef CRUISE_CONTROL_SUPPORT
 711:Src/util.c    ****     if (button && !rtP_Left.b_cruiseCtrlEna) {                          // Cruise control activated
 712:Src/util.c    ****       rtP_Left.n_cruiseMotTgt   = rtY_Left.n_mot;
 713:Src/util.c    ****       rtP_Right.n_cruiseMotTgt  = rtY_Right.n_mot;
 714:Src/util.c    ****       rtP_Left.b_cruiseCtrlEna  = 1;
 715:Src/util.c    ****       rtP_Right.b_cruiseCtrlEna = 1;
 716:Src/util.c    ****       cruiseCtrlAcv = 1;
 717:Src/util.c    ****       beepShortMany(2, 1);                                              // 200 ms beep delay. Acts 
 718:Src/util.c    ****     } else if (button && rtP_Left.b_cruiseCtrlEna && !standstillAcv) {  // Cruise control deactivat
 719:Src/util.c    ****       rtP_Left.b_cruiseCtrlEna  = 0;
 720:Src/util.c    ****       rtP_Right.b_cruiseCtrlEna = 0;
 721:Src/util.c    ****       cruiseCtrlAcv = 0;
 722:Src/util.c    ****       beepShortMany(2, -1);
 723:Src/util.c    ****     }
 724:Src/util.c    ****   #endif
 725:Src/util.c    **** }
 755              		.loc 1 725 1 view .LVU175
 756 0000 7047     		bx	lr
 757              		.cfi_endproc
 758              	.LFE82:
 760              		.section	.rodata.checkInputType.str1.4,"aMS",%progbits,1
 761              		.align	2
 762              	.LC0:
 763 0000 69676E6F 		.ascii	"ignored\000"
 763      72656400 
 764              		.align	2
 765              	.LC1:
 766 0008 61206E6F 		.ascii	"a normal pot\000"
 766      726D616C 
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 27


 766      20706F74 
 766      00
 767 0015 000000   		.align	2
 768              	.LC2:
 769 0018 61206D69 		.ascii	"a mid-resting pot\000"
 769      642D7265 
 769      7374696E 
 769      6720706F 
 769      7400
 770 002a 0000     		.align	2
 771              	.LC3:
 772 002c 20414E44 		.ascii	" AND protected\000"
 772      2070726F 
 772      74656374 
 772      656400
 773              		.section	.text.checkInputType,"ax",%progbits
 774              		.align	1
 775              		.global	checkInputType
 776              		.syntax unified
 777              		.thumb
 778              		.thumb_func
 779              		.fpu softvfp
 781              	checkInputType:
 782              	.LVL39:
 783              	.LFB83:
 726:Src/util.c    **** 
 727:Src/util.c    ****  /*
 728:Src/util.c    ****  * Check Input Type
 729:Src/util.c    ****  * This function identifies the input type: 0: Disabled, 1: Normal Pot, 2: Middle Resting Pot
 730:Src/util.c    ****  */
 731:Src/util.c    **** int checkInputType(int16_t min, int16_t mid, int16_t max){
 784              		.loc 1 731 58 view -0
 785              		.cfi_startproc
 786              		@ args = 0, pretend = 0, frame = 0
 787              		@ frame_needed = 0, uses_anonymous_args = 0
 788              		.loc 1 731 58 is_stmt 0 view .LVU177
 789 0000 70B5     		push	{r4, r5, r6, lr}
 790              	.LCFI9:
 791              		.cfi_def_cfa_offset 16
 792              		.cfi_offset 4, -16
 793              		.cfi_offset 5, -12
 794              		.cfi_offset 6, -8
 795              		.cfi_offset 14, -4
 796 0002 0546     		mov	r5, r0
 797 0004 1446     		mov	r4, r2
 732:Src/util.c    **** 
 733:Src/util.c    ****   int type = 0;  
 798              		.loc 1 733 3 is_stmt 1 view .LVU178
 799              	.LVL40:
 734:Src/util.c    ****   #ifdef CONTROL_ADC
 735:Src/util.c    ****   int16_t threshold = 400;      // Threshold to define if values are too close
 800              		.loc 1 735 3 view .LVU179
 736:Src/util.c    ****   #else
 737:Src/util.c    ****   int16_t threshold = 200;
 738:Src/util.c    ****   #endif
 739:Src/util.c    **** 
 740:Src/util.c    ****   if ((min / threshold) == (max / threshold) || (mid / threshold) == (max / threshold) || min > max
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 28


 801              		.loc 1 740 3 view .LVU180
 802              		.loc 1 740 12 is_stmt 0 view .LVU181
 803 0006 1B4B     		ldr	r3, .L59
 804 0008 83FB0502 		smull	r0, r2, r3, r5
 805              	.LVL41:
 806              		.loc 1 740 12 view .LVU182
 807 000c E817     		asrs	r0, r5, #31
 808 000e C0EBE210 		rsb	r0, r0, r2, asr #7
 809              		.loc 1 740 33 view .LVU183
 810 0012 83FB0423 		smull	r2, r3, r3, r4
 811 0016 E217     		asrs	r2, r4, #31
 812 0018 C2EBE313 		rsb	r3, r2, r3, asr #7
 813              		.loc 1 740 6 view .LVU184
 814 001c 9842     		cmp	r0, r3
 815 001e 0BD0     		beq	.L52
 816              		.loc 1 740 54 discriminator 1 view .LVU185
 817 0020 144A     		ldr	r2, .L59
 818 0022 82FB012C 		smull	r2, ip, r2, r1
 819 0026 CA17     		asrs	r2, r1, #31
 820 0028 C2EBEC12 		rsb	r2, r2, ip, asr #7
 821              		.loc 1 740 46 discriminator 1 view .LVU186
 822 002c 9342     		cmp	r3, r2
 823 002e 03D0     		beq	.L52
 824              		.loc 1 740 88 discriminator 2 view .LVU187
 825 0030 A542     		cmp	r5, r4
 826 0032 01DC     		bgt	.L52
 827              		.loc 1 740 101 discriminator 3 view .LVU188
 828 0034 8C42     		cmp	r4, r1
 829 0036 05DA     		bge	.L53
 830              	.L52:
 741:Src/util.c    ****     type = 0;
 831              		.loc 1 741 5 is_stmt 1 view .LVU189
 742:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 743:Src/util.c    ****     printf("ignored");                // (MIN and MAX) OR (MID and MAX) are close, disable input
 832              		.loc 1 743 5 view .LVU190
 833 0038 0F48     		ldr	r0, .L59+4
 834 003a FFF7FEFF 		bl	printf
 835              	.LVL42:
 741:Src/util.c    ****     type = 0;
 836              		.loc 1 741 10 is_stmt 0 view .LVU191
 837 003e 0026     		movs	r6, #0
 838              	.LVL43:
 839              	.L51:
 744:Src/util.c    ****     #endif
 745:Src/util.c    ****   } else {
 746:Src/util.c    ****     if ((min / threshold) == (mid / threshold)){
 747:Src/util.c    ****       type = 1;
 748:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 749:Src/util.c    ****       printf("a normal pot");        // MIN and MID are close, it's a normal pot
 750:Src/util.c    ****       #endif
 751:Src/util.c    ****     } else {
 752:Src/util.c    ****       type = 2;
 753:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 754:Src/util.c    ****       printf("a mid-resting pot");   // it's a mid resting pot
 755:Src/util.c    ****       #endif
 756:Src/util.c    ****     }
 757:Src/util.c    **** 
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 29


 758:Src/util.c    ****     #ifdef CONTROL_ADC
 759:Src/util.c    ****     if ((min + ADC_MARGIN - ADC_PROTECT_THRESH) > 0 && (max - ADC_MARGIN + ADC_PROTECT_THRESH) < 40
 760:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 761:Src/util.c    ****       printf(" AND protected");
 762:Src/util.c    ****       #endif
 763:Src/util.c    ****       beepLong(2); // Indicate protection by a beep
 764:Src/util.c    ****     }
 765:Src/util.c    ****     #endif
 766:Src/util.c    ****   }
 767:Src/util.c    **** 
 768:Src/util.c    ****   return type;
 769:Src/util.c    **** }
 840              		.loc 1 769 1 view .LVU192
 841 0040 3046     		mov	r0, r6
 842 0042 70BD     		pop	{r4, r5, r6, pc}
 843              	.LVL44:
 844              	.L53:
 746:Src/util.c    ****       type = 1;
 845              		.loc 1 746 5 is_stmt 1 view .LVU193
 746:Src/util.c    ****       type = 1;
 846              		.loc 1 746 8 is_stmt 0 view .LVU194
 847 0044 9042     		cmp	r0, r2
 848 0046 10D0     		beq	.L58
 752:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 849              		.loc 1 752 7 is_stmt 1 view .LVU195
 850              	.LVL45:
 754:Src/util.c    ****       #endif
 851              		.loc 1 754 7 view .LVU196
 852 0048 0C48     		ldr	r0, .L59+8
 853 004a FFF7FEFF 		bl	printf
 854              	.LVL46:
 752:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 855              		.loc 1 752 12 is_stmt 0 view .LVU197
 856 004e 0226     		movs	r6, #2
 857              	.LVL47:
 858              	.L56:
 759:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 859              		.loc 1 759 5 is_stmt 1 view .LVU198
 759:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 860              		.loc 1 759 8 is_stmt 0 view .LVU199
 861 0050 642D     		cmp	r5, #100
 862 0052 F5DD     		ble	.L51
 759:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 863              		.loc 1 759 53 discriminator 1 view .LVU200
 864 0054 40F69A73 		movw	r3, #3994
 865 0058 9C42     		cmp	r4, r3
 866 005a F1DC     		bgt	.L51
 761:Src/util.c    ****       #endif
 867              		.loc 1 761 7 is_stmt 1 view .LVU201
 868 005c 0848     		ldr	r0, .L59+12
 869 005e FFF7FEFF 		bl	printf
 870              	.LVL48:
 763:Src/util.c    ****     }
 871              		.loc 1 763 7 view .LVU202
 872 0062 0220     		movs	r0, #2
 873 0064 FFF7FEFF 		bl	beepLong
 874              	.LVL49:
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 30


 768:Src/util.c    **** }
 875              		.loc 1 768 3 view .LVU203
 768:Src/util.c    **** }
 876              		.loc 1 768 10 is_stmt 0 view .LVU204
 877 0068 EAE7     		b	.L51
 878              	.LVL50:
 879              	.L58:
 747:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 880              		.loc 1 747 7 is_stmt 1 view .LVU205
 749:Src/util.c    ****       #endif
 881              		.loc 1 749 7 view .LVU206
 882 006a 0648     		ldr	r0, .L59+16
 883 006c FFF7FEFF 		bl	printf
 884              	.LVL51:
 747:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 885              		.loc 1 747 12 is_stmt 0 view .LVU207
 886 0070 0126     		movs	r6, #1
 887 0072 EDE7     		b	.L56
 888              	.L60:
 889              		.align	2
 890              	.L59:
 891 0074 1F85EB51 		.word	1374389535
 892 0078 00000000 		.word	.LC0
 893 007c 18000000 		.word	.LC2
 894 0080 2C000000 		.word	.LC3
 895 0084 08000000 		.word	.LC1
 896              		.cfi_endproc
 897              	.LFE83:
 899              		.section	.text.Input_Init,"ax",%progbits
 900              		.align	1
 901              		.global	Input_Init
 902              		.syntax unified
 903              		.thumb
 904              		.thumb_func
 905              		.fpu softvfp
 907              	Input_Init:
 908              	.LFB70:
 282:Src/util.c    ****   #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
 909              		.loc 1 282 23 is_stmt 1 view -0
 910              		.cfi_startproc
 911              		@ args = 0, pretend = 0, frame = 8
 912              		@ frame_needed = 0, uses_anonymous_args = 0
 913 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 914              	.LCFI10:
 915              		.cfi_def_cfa_offset 28
 916              		.cfi_offset 4, -28
 917              		.cfi_offset 5, -24
 918              		.cfi_offset 6, -20
 919              		.cfi_offset 7, -16
 920              		.cfi_offset 8, -12
 921              		.cfi_offset 9, -8
 922              		.cfi_offset 14, -4
 923 0004 83B0     		sub	sp, sp, #12
 924              	.LCFI11:
 925              		.cfi_def_cfa_offset 40
 300:Src/util.c    ****   #endif
 926              		.loc 1 300 5 view .LVU209
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 31


 927 0006 FFF7FEFF 		bl	UART3_Init
 928              	.LVL52:
 307:Src/util.c    ****     UART_DisableRxErrors(&huart3);
 929              		.loc 1 307 5 view .LVU210
 930 000a 6B4C     		ldr	r4, .L76
 931 000c 4022     		movs	r2, #64
 932 000e 6B49     		ldr	r1, .L76+4
 933 0010 2046     		mov	r0, r4
 934 0012 FFF7FEFF 		bl	HAL_UART_Receive_DMA
 935              	.LVL53:
 308:Src/util.c    ****   #endif
 936              		.loc 1 308 5 view .LVU211
 937 0016 2046     		mov	r0, r4
 938 0018 FFF7FEFF 		bl	UART_DisableRxErrors
 939              	.LVL54:
 312:Src/util.c    ****     HAL_FLASH_Unlock();
 940              		.loc 1 312 5 view .LVU212
 313:Src/util.c    ****     EE_Init();            /* EEPROM Init */
 941              		.loc 1 313 5 view .LVU213
 942 001c FFF7FEFF 		bl	HAL_FLASH_Unlock
 943              	.LVL55:
 314:Src/util.c    ****     EE_ReadVariable(VirtAddVarTab[0], &writeCheck);
 944              		.loc 1 314 5 view .LVU214
 945 0020 FFF7FEFF 		bl	EE_Init
 946              	.LVL56:
 315:Src/util.c    ****     if (writeCheck == FLASH_WRITE_KEY) {
 947              		.loc 1 315 5 view .LVU215
 948 0024 0DF10601 		add	r1, sp, #6
 949 0028 654B     		ldr	r3, .L76+8
 950 002a 1888     		ldrh	r0, [r3]
 951 002c FFF7FEFF 		bl	EE_ReadVariable
 952              	.LVL57:
 316:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[1] , &readVal); rtP_Left.i_max = rtP_Right.i_max = (int16_t)rea
 953              		.loc 1 316 5 view .LVU216
 316:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[1] , &readVal); rtP_Left.i_max = rtP_Right.i_max = (int16_t)rea
 954              		.loc 1 316 20 is_stmt 0 view .LVU217
 955 0030 BDF80620 		ldrh	r2, [sp, #6]
 316:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[1] , &readVal); rtP_Left.i_max = rtP_Right.i_max = (int16_t)rea
 956              		.loc 1 316 8 view .LVU218
 957 0034 41F20103 		movw	r3, #4097
 958 0038 9A42     		cmp	r2, r3
 959 003a 01D0     		beq	.L73
 960              	.LBB5:
 330:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 961              		.loc 1 330 20 view .LVU219
 962 003c 0024     		movs	r4, #0
 963 003e 93E0     		b	.L62
 964              	.L73:
 965              	.LBE5:
 317:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 966              		.loc 1 317 7 is_stmt 1 view .LVU220
 967 0040 5F4E     		ldr	r6, .L76+8
 968 0042 01A9     		add	r1, sp, #4
 969 0044 7088     		ldrh	r0, [r6, #2]
 970 0046 FFF7FEFF 		bl	EE_ReadVariable
 971              	.LVL58:
 317:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 32


 972              		.loc 1 317 53 view .LVU221
 317:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 973              		.loc 1 317 88 is_stmt 0 view .LVU222
 974 004a BDF90430 		ldrsh	r3, [sp, #4]
 317:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 975              		.loc 1 317 86 view .LVU223
 976 004e 5D4D     		ldr	r5, .L76+12
 977 0050 A5F8CE30 		strh	r3, [r5, #206]	@ movhi
 317:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 978              		.loc 1 317 68 view .LVU224
 979 0054 5C4C     		ldr	r4, .L76+16
 980 0056 A4F8CE30 		strh	r3, [r4, #206]	@ movhi
 318:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 981              		.loc 1 318 7 is_stmt 1 view .LVU225
 982 005a 01A9     		add	r1, sp, #4
 983 005c B088     		ldrh	r0, [r6, #4]
 984 005e FFF7FEFF 		bl	EE_ReadVariable
 985              	.LVL59:
 318:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 986              		.loc 1 318 53 view .LVU226
 318:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 987              		.loc 1 318 88 is_stmt 0 view .LVU227
 988 0062 BDF90430 		ldrsh	r3, [sp, #4]
 318:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 989              		.loc 1 318 86 view .LVU228
 990 0066 A5F8DA30 		strh	r3, [r5, #218]	@ movhi
 318:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 991              		.loc 1 318 68 view .LVU229
 992 006a A4F8DA30 		strh	r3, [r4, #218]	@ movhi
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 993              		.loc 1 319 7 is_stmt 1 view .LVU230
 994              	.LBB6:
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 995              		.loc 1 319 12 view .LVU231
 996              	.LVL60:
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 997              		.loc 1 319 20 is_stmt 0 view .LVU232
 998 006e 0025     		movs	r5, #0
 999              	.LVL61:
 1000              	.L63:
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 1001              		.loc 1 319 25 is_stmt 1 discriminator 1 view .LVU233
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 1002              		.loc 1 319 7 is_stmt 0 discriminator 1 view .LVU234
 1003 0070 002D     		cmp	r5, #0
 1004 0072 7BD1     		bne	.L65
 320:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 1005              		.loc 1 320 9 is_stmt 1 discriminator 3 view .LVU235
 320:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 1006              		.loc 1 320 43 is_stmt 0 discriminator 3 view .LVU236
 1007 0074 EC00     		lsls	r4, r5, #3
 320:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 1008              		.loc 1 320 41 discriminator 3 view .LVU237
 1009 0076 E31C     		adds	r3, r4, #3
 320:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 1010              		.loc 1 320 9 discriminator 3 view .LVU238
 1011 0078 514E     		ldr	r6, .L76+8
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 33


 1012 007a 01A9     		add	r1, sp, #4
 1013 007c 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1014 0080 FFF7FEFF 		bl	EE_ReadVariable
 1015              	.LVL62:
 320:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 1016              		.loc 1 320 60 is_stmt 1 discriminator 3 view .LVU239
 320:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 1017              		.loc 1 320 76 is_stmt 0 discriminator 3 view .LVU240
 1018 0084 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 320:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 1019              		.loc 1 320 74 discriminator 3 view .LVU241
 1020 0088 621B     		subs	r2, r4, r5
 1021 008a 504F     		ldr	r7, .L76+20
 1022 008c 07EB4207 		add	r7, r7, r2, lsl #1
 1023 0090 3B71     		strb	r3, [r7, #4]
 321:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 1024              		.loc 1 321 9 is_stmt 1 discriminator 3 view .LVU242
 321:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 1025              		.loc 1 321 41 is_stmt 0 discriminator 3 view .LVU243
 1026 0092 231D     		adds	r3, r4, #4
 321:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 1027              		.loc 1 321 9 discriminator 3 view .LVU244
 1028 0094 01A9     		add	r1, sp, #4
 1029 0096 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1030 009a FFF7FEFF 		bl	EE_ReadVariable
 1031              	.LVL63:
 321:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 1032              		.loc 1 321 60 is_stmt 1 discriminator 3 view .LVU245
 321:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 1033              		.loc 1 321 76 is_stmt 0 discriminator 3 view .LVU246
 1034 009e BDF90430 		ldrsh	r3, [sp, #4]
 321:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 1035              		.loc 1 321 74 discriminator 3 view .LVU247
 1036 00a2 FB80     		strh	r3, [r7, #6]	@ movhi
 322:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 1037              		.loc 1 322 9 is_stmt 1 discriminator 3 view .LVU248
 322:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 1038              		.loc 1 322 41 is_stmt 0 discriminator 3 view .LVU249
 1039 00a4 631D     		adds	r3, r4, #5
 322:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 1040              		.loc 1 322 9 discriminator 3 view .LVU250
 1041 00a6 01A9     		add	r1, sp, #4
 1042 00a8 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1043 00ac FFF7FEFF 		bl	EE_ReadVariable
 1044              	.LVL64:
 322:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 1045              		.loc 1 322 60 is_stmt 1 discriminator 3 view .LVU251
 322:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 1046              		.loc 1 322 76 is_stmt 0 discriminator 3 view .LVU252
 1047 00b0 BDF90430 		ldrsh	r3, [sp, #4]
 322:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 1048              		.loc 1 322 74 discriminator 3 view .LVU253
 1049 00b4 3B81     		strh	r3, [r7, #8]	@ movhi
 323:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 1050              		.loc 1 323 9 is_stmt 1 discriminator 3 view .LVU254
 323:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 1051              		.loc 1 323 41 is_stmt 0 discriminator 3 view .LVU255
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 34


 1052 00b6 A31D     		adds	r3, r4, #6
 323:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 1053              		.loc 1 323 9 discriminator 3 view .LVU256
 1054 00b8 01A9     		add	r1, sp, #4
 1055 00ba 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1056 00be FFF7FEFF 		bl	EE_ReadVariable
 1057              	.LVL65:
 323:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 1058              		.loc 1 323 60 is_stmt 1 discriminator 3 view .LVU257
 323:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 1059              		.loc 1 323 76 is_stmt 0 discriminator 3 view .LVU258
 1060 00c2 BDF90430 		ldrsh	r3, [sp, #4]
 323:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 1061              		.loc 1 323 74 discriminator 3 view .LVU259
 1062 00c6 7B81     		strh	r3, [r7, #10]	@ movhi
 324:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 1063              		.loc 1 324 9 is_stmt 1 discriminator 3 view .LVU260
 324:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 1064              		.loc 1 324 41 is_stmt 0 discriminator 3 view .LVU261
 1065 00c8 E31D     		adds	r3, r4, #7
 324:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 1066              		.loc 1 324 9 discriminator 3 view .LVU262
 1067 00ca 01A9     		add	r1, sp, #4
 1068 00cc 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1069 00d0 FFF7FEFF 		bl	EE_ReadVariable
 1070              	.LVL66:
 324:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 1071              		.loc 1 324 60 is_stmt 1 discriminator 3 view .LVU263
 324:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 1072              		.loc 1 324 76 is_stmt 0 discriminator 3 view .LVU264
 1073 00d4 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 324:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 1074              		.loc 1 324 74 discriminator 3 view .LVU265
 1075 00d8 DFF8F480 		ldr	r8, .L76+24
 1076 00dc 671B     		subs	r7, r4, r5
 1077 00de 08EB4707 		add	r7, r8, r7, lsl #1
 1078 00e2 3B71     		strb	r3, [r7, #4]
 325:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 1079              		.loc 1 325 9 is_stmt 1 discriminator 3 view .LVU266
 325:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 1080              		.loc 1 325 41 is_stmt 0 discriminator 3 view .LVU267
 1081 00e4 05F10109 		add	r9, r5, #1
 1082 00e8 4FEAC903 		lsl	r3, r9, #3
 325:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 1083              		.loc 1 325 9 discriminator 3 view .LVU268
 1084 00ec 01A9     		add	r1, sp, #4
 1085 00ee 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1086 00f2 FFF7FEFF 		bl	EE_ReadVariable
 1087              	.LVL67:
 325:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 1088              		.loc 1 325 60 is_stmt 1 discriminator 3 view .LVU269
 325:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 1089              		.loc 1 325 76 is_stmt 0 discriminator 3 view .LVU270
 1090 00f6 BDF90430 		ldrsh	r3, [sp, #4]
 325:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 1091              		.loc 1 325 74 discriminator 3 view .LVU271
 1092 00fa FB80     		strh	r3, [r7, #6]	@ movhi
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 35


 326:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 1093              		.loc 1 326 9 is_stmt 1 discriminator 3 view .LVU272
 326:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 1094              		.loc 1 326 41 is_stmt 0 discriminator 3 view .LVU273
 1095 00fc 04F10903 		add	r3, r4, #9
 326:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 1096              		.loc 1 326 9 discriminator 3 view .LVU274
 1097 0100 01A9     		add	r1, sp, #4
 1098 0102 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1099 0106 FFF7FEFF 		bl	EE_ReadVariable
 1100              	.LVL68:
 326:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 1101              		.loc 1 326 60 is_stmt 1 discriminator 3 view .LVU275
 326:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 1102              		.loc 1 326 76 is_stmt 0 discriminator 3 view .LVU276
 1103 010a BDF90430 		ldrsh	r3, [sp, #4]
 326:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 1104              		.loc 1 326 74 discriminator 3 view .LVU277
 1105 010e 3B81     		strh	r3, [r7, #8]	@ movhi
 327:Src/util.c    ****       }
 1106              		.loc 1 327 9 is_stmt 1 discriminator 3 view .LVU278
 327:Src/util.c    ****       }
 1107              		.loc 1 327 41 is_stmt 0 discriminator 3 view .LVU279
 1108 0110 04F10A03 		add	r3, r4, #10
 327:Src/util.c    ****       }
 1109              		.loc 1 327 9 discriminator 3 view .LVU280
 1110 0114 01A9     		add	r1, sp, #4
 1111 0116 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1112 011a FFF7FEFF 		bl	EE_ReadVariable
 1113              	.LVL69:
 327:Src/util.c    ****       }
 1114              		.loc 1 327 60 is_stmt 1 discriminator 3 view .LVU281
 327:Src/util.c    ****       }
 1115              		.loc 1 327 76 is_stmt 0 discriminator 3 view .LVU282
 1116 011e BDF90430 		ldrsh	r3, [sp, #4]
 327:Src/util.c    ****       }
 1117              		.loc 1 327 74 discriminator 3 view .LVU283
 1118 0122 7B81     		strh	r3, [r7, #10]	@ movhi
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 1119              		.loc 1 319 38 is_stmt 1 discriminator 3 view .LVU284
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 1120              		.loc 1 319 39 is_stmt 0 discriminator 3 view .LVU285
 1121 0124 5FFA89F5 		uxtb	r5, r9
 1122              	.LVL70:
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 1123              		.loc 1 319 39 discriminator 3 view .LVU286
 1124 0128 A2E7     		b	.L63
 1125              	.LVL71:
 1126              	.L70:
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 1127              		.loc 1 319 39 discriminator 3 view .LVU287
 1128              	.LBE6:
 1129              	.LBB7:
 331:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 1130              		.loc 1 331 9 is_stmt 1 view .LVU288
 331:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 1131              		.loc 1 331 22 is_stmt 0 view .LVU289
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 36


 1132 012a 2546     		mov	r5, r4
 1133 012c C4EBC403 		rsb	r3, r4, r4, lsl #3
 1134 0130 264A     		ldr	r2, .L76+20
 1135 0132 02EB4303 		add	r3, r2, r3, lsl #1
 1136 0136 5979     		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 331:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 1137              		.loc 1 331 12 view .LVU290
 1138 0138 0329     		cmp	r1, #3
 1139 013a 1CD0     		beq	.L74
 334:Src/util.c    ****         }
 1140              		.loc 1 334 11 is_stmt 1 view .LVU291
 334:Src/util.c    ****         }
 1141              		.loc 1 334 25 is_stmt 0 view .LVU292
 1142 013c C4EBC403 		rsb	r3, r4, r4, lsl #3
 1143 0140 224A     		ldr	r2, .L76+20
 1144 0142 02EB4303 		add	r3, r2, r3, lsl #1
 1145 0146 1971     		strb	r1, [r3, #4]
 1146              	.L67:
 336:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 1147              		.loc 1 336 9 is_stmt 1 view .LVU293
 336:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 1148              		.loc 1 336 22 is_stmt 0 view .LVU294
 1149 0148 C5EBC503 		rsb	r3, r5, r5, lsl #3
 1150 014c 204A     		ldr	r2, .L76+24
 1151 014e 02EB4303 		add	r3, r2, r3, lsl #1
 1152 0152 5A79     		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 336:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 1153              		.loc 1 336 12 view .LVU295
 1154 0154 032A     		cmp	r2, #3
 1155 0156 1CD0     		beq	.L75
 339:Src/util.c    ****         }
 1156              		.loc 1 339 11 is_stmt 1 view .LVU296
 339:Src/util.c    ****         }
 1157              		.loc 1 339 25 is_stmt 0 view .LVU297
 1158 0158 C5EBC505 		rsb	r5, r5, r5, lsl #3
 1159 015c 1C4B     		ldr	r3, .L76+24
 1160 015e 03EB4505 		add	r5, r3, r5, lsl #1
 1161 0162 2A71     		strb	r2, [r5, #4]
 1162              	.L69:
 330:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1163              		.loc 1 330 38 is_stmt 1 discriminator 2 view .LVU298
 330:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1164              		.loc 1 330 39 is_stmt 0 discriminator 2 view .LVU299
 1165 0164 0134     		adds	r4, r4, #1
 1166              	.LVL72:
 330:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1167              		.loc 1 330 39 discriminator 2 view .LVU300
 1168 0166 E4B2     		uxtb	r4, r4
 1169              	.LVL73:
 1170              	.L62:
 330:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1171              		.loc 1 330 25 is_stmt 1 discriminator 1 view .LVU301
 330:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1172              		.loc 1 330 7 is_stmt 0 discriminator 1 view .LVU302
 1173 0168 002C     		cmp	r4, #0
 1174 016a DED0     		beq	.L70
 1175              	.LVL74:
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 37


 1176              	.L65:
 330:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1177              		.loc 1 330 7 discriminator 1 view .LVU303
 1178              	.LBE7:
 343:Src/util.c    ****   #endif
 1179              		.loc 1 343 5 is_stmt 1 view .LVU304
 1180 016c FFF7FEFF 		bl	HAL_FLASH_Lock
 1181              	.LVL75:
 395:Src/util.c    **** 
 1182              		.loc 1 395 1 is_stmt 0 view .LVU305
 1183 0170 03B0     		add	sp, sp, #12
 1184              	.LCFI12:
 1185              		.cfi_remember_state
 1186              		.cfi_def_cfa_offset 28
 1187              		@ sp needed
 1188 0172 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 1189              	.LVL76:
 1190              	.L74:
 1191              	.LCFI13:
 1192              		.cfi_restore_state
 1193              	.LBB8:
 332:Src/util.c    ****         } else {
 1194              		.loc 1 332 11 is_stmt 1 view .LVU306
 332:Src/util.c    ****         } else {
 1195              		.loc 1 332 27 is_stmt 0 view .LVU307
 1196 0176 C4EBC406 		rsb	r6, r4, r4, lsl #3
 1197 017a 02EB4606 		add	r6, r2, r6, lsl #1
 1198 017e B6F90A20 		ldrsh	r2, [r6, #10]
 1199 0182 B6F90810 		ldrsh	r1, [r6, #8]
 1200 0186 B6F90600 		ldrsh	r0, [r6, #6]
 1201 018a FFF7FEFF 		bl	checkInputType
 1202              	.LVL77:
 332:Src/util.c    ****         } else {
 1203              		.loc 1 332 25 view .LVU308
 1204 018e 3071     		strb	r0, [r6, #4]
 1205 0190 DAE7     		b	.L67
 1206              	.L75:
 337:Src/util.c    ****         } else {
 1207              		.loc 1 337 11 is_stmt 1 view .LVU309
 337:Src/util.c    ****         } else {
 1208              		.loc 1 337 27 is_stmt 0 view .LVU310
 1209 0192 0F4E     		ldr	r6, .L76+24
 1210 0194 EF00     		lsls	r7, r5, #3
 1211 0196 C5EBC503 		rsb	r3, r5, r5, lsl #3
 1212 019a 06EB4303 		add	r3, r6, r3, lsl #1
 1213 019e B3F90A20 		ldrsh	r2, [r3, #10]
 1214 01a2 B3F90810 		ldrsh	r1, [r3, #8]
 1215 01a6 B3F90600 		ldrsh	r0, [r3, #6]
 1216 01aa FFF7FEFF 		bl	checkInputType
 1217              	.LVL78:
 337:Src/util.c    ****         } else {
 1218              		.loc 1 337 25 view .LVU311
 1219 01ae 7D1B     		subs	r5, r7, r5
 1220 01b0 06EB4506 		add	r6, r6, r5, lsl #1
 1221 01b4 3071     		strb	r0, [r6, #4]
 1222 01b6 D5E7     		b	.L69
 1223              	.L77:
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 38


 1224              		.align	2
 1225              	.L76:
 1226 01b8 00000000 		.word	huart3
 1227 01bc 00000000 		.word	.LANCHOR13
 1228 01c0 00000000 		.word	.LANCHOR14
 1229 01c4 00000000 		.word	.LANCHOR0
 1230 01c8 00000000 		.word	rtP_Left
 1231 01cc 00000000 		.word	.LANCHOR15
 1232 01d0 00000000 		.word	.LANCHOR16
 1233              	.LBE8:
 1234              		.cfi_endproc
 1235              	.LFE70:
 1237              		.section	.text.calcInputCmd,"ax",%progbits
 1238              		.align	1
 1239              		.global	calcInputCmd
 1240              		.syntax unified
 1241              		.thumb
 1242              		.thumb_func
 1243              		.fpu softvfp
 1245              	calcInputCmd:
 1246              	.LVL79:
 1247              	.LFB84:
 770:Src/util.c    **** 
 771:Src/util.c    **** 
 772:Src/util.c    **** 
 773:Src/util.c    **** /* =========================== Input Functions =========================== */
 774:Src/util.c    **** 
 775:Src/util.c    ****  /*
 776:Src/util.c    ****  * Calculate Input Command
 777:Src/util.c    ****  * This function realizes dead-band around 0 and scales the input between [out_min, out_max]
 778:Src/util.c    ****  */
 779:Src/util.c    **** void calcInputCmd(InputStruct *in, int16_t out_min, int16_t out_max) {
 1248              		.loc 1 779 70 is_stmt 1 view -0
 1249              		.cfi_startproc
 1250              		@ args = 0, pretend = 0, frame = 0
 1251              		@ frame_needed = 0, uses_anonymous_args = 0
 780:Src/util.c    ****   switch (in->typ){
 1252              		.loc 1 780 3 view .LVU313
 1253              		.loc 1 780 13 is_stmt 0 view .LVU314
 1254 0000 90F804C0 		ldrb	ip, [r0, #4]	@ zero_extendqisi2
 1255              		.loc 1 780 3 view .LVU315
 1256 0004 BCF1010F 		cmp	ip, #1
 1257 0008 05D0     		beq	.L79
 1258 000a BCF1020F 		cmp	ip, #2
 1259 000e 17D0     		beq	.L80
 781:Src/util.c    ****     case 1: // Input is a normal pot
 782:Src/util.c    ****       in->cmd = CLAMP(MAP(in->raw, in->min, in->max, 0, out_max), 0, out_max);
 783:Src/util.c    ****       break;
 784:Src/util.c    ****     case 2: // Input is a mid resting pot
 785:Src/util.c    ****       if( in->raw > in->mid - in->dband && in->raw < in->mid + in->dband ) {
 786:Src/util.c    ****         in->cmd = 0;
 787:Src/util.c    ****       } else if(in->raw > in->mid) {
 788:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid + in->dband, in->max, 0, out_max), 0, out_max);
 789:Src/util.c    ****       } else {
 790:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid - in->dband, in->min, 0, out_min), out_min, 0);
 791:Src/util.c    ****       }
 792:Src/util.c    ****       break;
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 39


 793:Src/util.c    ****     default: // Input is ignored
 794:Src/util.c    ****       in->cmd = 0;
 1260              		.loc 1 794 7 is_stmt 1 view .LVU316
 1261              		.loc 1 794 15 is_stmt 0 view .LVU317
 1262 0010 0023     		movs	r3, #0
 1263 0012 4380     		strh	r3, [r0, #2]	@ movhi
 795:Src/util.c    ****       break;
 1264              		.loc 1 795 7 is_stmt 1 view .LVU318
 1265 0014 7047     		bx	lr
 1266              	.L79:
 782:Src/util.c    ****       break;
 1267              		.loc 1 782 7 view .LVU319
 782:Src/util.c    ****       break;
 1268              		.loc 1 782 17 is_stmt 0 view .LVU320
 1269 0016 B0F90030 		ldrsh	r3, [r0]
 1270 001a B0F906C0 		ldrsh	ip, [r0, #6]
 1271 001e A3EB0C03 		sub	r3, r3, ip
 1272 0022 02FB03F3 		mul	r3, r2, r3
 1273 0026 B0F90A10 		ldrsh	r1, [r0, #10]
 1274              	.LVL80:
 782:Src/util.c    ****       break;
 1275              		.loc 1 782 17 view .LVU321
 1276 002a A1EB0C01 		sub	r1, r1, ip
 1277 002e 93FBF1F3 		sdiv	r3, r3, r1
 782:Src/util.c    ****       break;
 1278              		.loc 1 782 15 view .LVU322
 1279 0032 9A42     		cmp	r2, r3
 1280 0034 02DB     		blt	.L82
 782:Src/util.c    ****       break;
 1281              		.loc 1 782 17 discriminator 1 view .LVU323
 1282 0036 23EAE372 		bic	r2, r3, r3, asr #31
 1283              	.LVL81:
 782:Src/util.c    ****       break;
 1284              		.loc 1 782 15 discriminator 1 view .LVU324
 1285 003a 12B2     		sxth	r2, r2
 1286              	.L82:
 782:Src/util.c    ****       break;
 1287              		.loc 1 782 15 discriminator 4 view .LVU325
 1288 003c 4280     		strh	r2, [r0, #2]	@ movhi
 783:Src/util.c    ****     case 2: // Input is a mid resting pot
 1289              		.loc 1 783 7 is_stmt 1 discriminator 4 view .LVU326
 1290 003e 7047     		bx	lr
 1291              	.LVL82:
 1292              	.L80:
 779:Src/util.c    ****   switch (in->typ){
 1293              		.loc 1 779 70 is_stmt 0 view .LVU327
 1294 0040 30B5     		push	{r4, r5, lr}
 1295              	.LCFI14:
 1296              		.cfi_def_cfa_offset 12
 1297              		.cfi_offset 4, -12
 1298              		.cfi_offset 5, -8
 1299              		.cfi_offset 14, -4
 785:Src/util.c    ****         in->cmd = 0;
 1300              		.loc 1 785 7 is_stmt 1 view .LVU328
 785:Src/util.c    ****         in->cmd = 0;
 1301              		.loc 1 785 13 is_stmt 0 view .LVU329
 1302 0042 B0F90030 		ldrsh	r3, [r0]
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 40


 785:Src/util.c    ****         in->cmd = 0;
 1303              		.loc 1 785 23 view .LVU330
 1304 0046 B0F908C0 		ldrsh	ip, [r0, #8]
 785:Src/util.c    ****         in->cmd = 0;
 1305              		.loc 1 785 33 view .LVU331
 1306 004a B0F90CE0 		ldrsh	lr, [r0, #12]
 785:Src/util.c    ****         in->cmd = 0;
 1307              		.loc 1 785 29 view .LVU332
 1308 004e ACEB0E04 		sub	r4, ip, lr
 785:Src/util.c    ****         in->cmd = 0;
 1309              		.loc 1 785 9 view .LVU333
 1310 0052 A342     		cmp	r3, r4
 1311 0054 06DD     		ble	.L84
 785:Src/util.c    ****         in->cmd = 0;
 1312              		.loc 1 785 62 discriminator 1 view .LVU334
 1313 0056 0CEB0E05 		add	r5, ip, lr
 785:Src/util.c    ****         in->cmd = 0;
 1314              		.loc 1 785 41 discriminator 1 view .LVU335
 1315 005a AB42     		cmp	r3, r5
 1316 005c 02DA     		bge	.L84
 786:Src/util.c    ****       } else if(in->raw > in->mid) {
 1317              		.loc 1 786 9 is_stmt 1 view .LVU336
 786:Src/util.c    ****       } else if(in->raw > in->mid) {
 1318              		.loc 1 786 17 is_stmt 0 view .LVU337
 1319 005e 0023     		movs	r3, #0
 1320 0060 4380     		strh	r3, [r0, #2]	@ movhi
 1321 0062 12E0     		b	.L78
 1322              	.L84:
 787:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid + in->dband, in->max, 0, out_max), 0, out_max);
 1323              		.loc 1 787 14 is_stmt 1 view .LVU338
 787:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid + in->dband, in->max, 0, out_max), 0, out_max);
 1324              		.loc 1 787 16 is_stmt 0 view .LVU339
 1325 0064 6345     		cmp	r3, ip
 1326 0066 11DD     		ble	.L85
 788:Src/util.c    ****       } else {
 1327              		.loc 1 788 9 is_stmt 1 view .LVU340
 788:Src/util.c    ****       } else {
 1328              		.loc 1 788 19 is_stmt 0 view .LVU341
 1329 0068 F444     		add	ip, ip, lr
 1330 006a A3EB0C03 		sub	r3, r3, ip
 1331 006e 02FB03F3 		mul	r3, r2, r3
 1332 0072 B0F90A10 		ldrsh	r1, [r0, #10]
 1333              	.LVL83:
 788:Src/util.c    ****       } else {
 1334              		.loc 1 788 19 view .LVU342
 1335 0076 A1EB0C0C 		sub	ip, r1, ip
 1336 007a 93FBFCF3 		sdiv	r3, r3, ip
 788:Src/util.c    ****       } else {
 1337              		.loc 1 788 17 view .LVU343
 1338 007e 9A42     		cmp	r2, r3
 1339 0080 02DB     		blt	.L86
 788:Src/util.c    ****       } else {
 1340              		.loc 1 788 19 discriminator 1 view .LVU344
 1341 0082 23EAE372 		bic	r2, r3, r3, asr #31
 1342              	.LVL84:
 788:Src/util.c    ****       } else {
 1343              		.loc 1 788 17 discriminator 1 view .LVU345
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 41


 1344 0086 12B2     		sxth	r2, r2
 1345              	.L86:
 788:Src/util.c    ****       } else {
 1346              		.loc 1 788 17 discriminator 4 view .LVU346
 1347 0088 4280     		strh	r2, [r0, #2]	@ movhi
 1348              	.L78:
 796:Src/util.c    ****   }
 797:Src/util.c    **** }
 1349              		.loc 1 797 1 view .LVU347
 1350 008a 30BD     		pop	{r4, r5, pc}
 1351              	.LVL85:
 1352              	.L85:
 790:Src/util.c    ****       }
 1353              		.loc 1 790 9 is_stmt 1 view .LVU348
 790:Src/util.c    ****       }
 1354              		.loc 1 790 19 is_stmt 0 view .LVU349
 1355 008c 1B1B     		subs	r3, r3, r4
 1356 008e 01FB03F3 		mul	r3, r1, r3
 1357 0092 B0F90620 		ldrsh	r2, [r0, #6]
 1358              	.LVL86:
 790:Src/util.c    ****       }
 1359              		.loc 1 790 19 view .LVU350
 1360 0096 141B     		subs	r4, r2, r4
 1361 0098 93FBF4F3 		sdiv	r3, r3, r4
 790:Src/util.c    ****       }
 1362              		.loc 1 790 17 view .LVU351
 1363 009c 002B     		cmp	r3, #0
 1364 009e 02DD     		ble	.L93
 1365 00a0 0021     		movs	r1, #0
 1366              	.LVL87:
 1367              	.L87:
 790:Src/util.c    ****       }
 1368              		.loc 1 790 17 discriminator 4 view .LVU352
 1369 00a2 4180     		strh	r1, [r0, #2]	@ movhi
 1370 00a4 F1E7     		b	.L78
 1371              	.LVL88:
 1372              	.L93:
 790:Src/util.c    ****       }
 1373              		.loc 1 790 19 discriminator 1 view .LVU353
 1374 00a6 9942     		cmp	r1, r3
 1375 00a8 B8BF     		it	lt
 1376 00aa 1946     		movlt	r1, r3
 1377              	.LVL89:
 790:Src/util.c    ****       }
 1378              		.loc 1 790 17 discriminator 1 view .LVU354
 1379 00ac 09B2     		sxth	r1, r1
 1380 00ae F8E7     		b	.L87
 1381              		.cfi_endproc
 1382              	.LFE84:
 1384              		.section	.text.readInputRaw,"ax",%progbits
 1385              		.align	1
 1386              		.global	readInputRaw
 1387              		.syntax unified
 1388              		.thumb
 1389              		.thumb_func
 1390              		.fpu softvfp
 1392              	readInputRaw:
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 42


 1393              	.LFB85:
 798:Src/util.c    **** 
 799:Src/util.c    ****  /*
 800:Src/util.c    ****  * Function to read the Input Raw values from various input devices
 801:Src/util.c    ****  */
 802:Src/util.c    **** void readInputRaw(void) {
 1394              		.loc 1 802 25 is_stmt 1 view -0
 1395              		.cfi_startproc
 1396              		@ args = 0, pretend = 0, frame = 0
 1397              		@ frame_needed = 0, uses_anonymous_args = 0
 1398              		@ link register save eliminated.
 803:Src/util.c    ****     #ifdef CONTROL_ADC
 804:Src/util.c    ****     if (inIdx == CONTROL_ADC) {
 1399              		.loc 1 804 5 view .LVU356
 1400              		.loc 1 804 15 is_stmt 0 view .LVU357
 1401 0000 094B     		ldr	r3, .L96
 1402 0002 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1403              		.loc 1 804 8 view .LVU358
 1404 0004 73B9     		cbnz	r3, .L94
 805:Src/util.c    ****       #ifdef ADC_ALTERNATE_CONNECT
 806:Src/util.c    ****         input1[inIdx].raw = adc_buffer.l_rx2;
 807:Src/util.c    ****         input2[inIdx].raw = adc_buffer.l_tx2;
 808:Src/util.c    ****       #else
 809:Src/util.c    ****         input1[inIdx].raw = adc_buffer.l_tx2;
 1405              		.loc 1 809 9 is_stmt 1 view .LVU359
 1406              		.loc 1 809 39 is_stmt 0 view .LVU360
 1407 0006 094A     		ldr	r2, .L96+4
 1408 0008 B2F80EC0 		ldrh	ip, [r2, #14]
 1409              		.loc 1 809 27 view .LVU361
 1410 000c C3EBC300 		rsb	r0, r3, r3, lsl #3
 1411 0010 4100     		lsls	r1, r0, #1
 1412 0012 0748     		ldr	r0, .L96+8
 1413 0014 20F801C0 		strh	ip, [r0, r1]	@ movhi
 810:Src/util.c    ****         input2[inIdx].raw = adc_buffer.l_rx2;
 1414              		.loc 1 810 9 is_stmt 1 view .LVU362
 1415              		.loc 1 810 39 is_stmt 0 view .LVU363
 1416 0018 518A     		ldrh	r1, [r2, #18]
 1417              		.loc 1 810 27 view .LVU364
 1418 001a C3EBC303 		rsb	r3, r3, r3, lsl #3
 1419 001e 5A00     		lsls	r2, r3, #1
 1420 0020 044B     		ldr	r3, .L96+12
 1421 0022 9952     		strh	r1, [r3, r2]	@ movhi
 1422              	.L94:
 811:Src/util.c    ****       #endif
 812:Src/util.c    ****     }
 813:Src/util.c    ****     #endif
 814:Src/util.c    **** 
 815:Src/util.c    ****     #if defined(CONTROL_NUNCHUK) || defined(SUPPORT_NUNCHUK)
 816:Src/util.c    ****     if (nunchuk_connected) {
 817:Src/util.c    ****       Nunchuk_Read();
 818:Src/util.c    ****       if (inIdx == CONTROL_NUNCHUK) {
 819:Src/util.c    ****         input1[inIdx].raw = (nunchuk_data[0] - 127) * 8; // X axis 0-255
 820:Src/util.c    ****         input2[inIdx].raw = (nunchuk_data[1] - 128) * 8; // Y axis 0-255
 821:Src/util.c    ****       }
 822:Src/util.c    ****       #ifdef SUPPORT_BUTTONS
 823:Src/util.c    ****         button1 = (uint8_t)nunchuk_data[5] & 1;
 824:Src/util.c    ****         button2 = (uint8_t)(nunchuk_data[5] >> 1) & 1;
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 43


 825:Src/util.c    ****       #endif
 826:Src/util.c    ****     }
 827:Src/util.c    ****     #endif
 828:Src/util.c    **** 
 829:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART2)
 830:Src/util.c    ****     if (inIdx == CONTROL_SERIAL_USART2) {
 831:Src/util.c    ****       #ifdef CONTROL_IBUS
 832:Src/util.c    ****         for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i+=2) {
 833:Src/util.c    ****           ibusL_captured_value[(i/2)] = CLAMP(commandL.channels[i] + (commandL.channels[i+1] << 8) 
 834:Src/util.c    ****         }
 835:Src/util.c    ****         input1[inIdx].raw = (ibusL_captured_value[0] - 500) * 2;
 836:Src/util.c    ****         input2[inIdx].raw = (ibusL_captured_value[1] - 500) * 2; 
 837:Src/util.c    ****       #else
 838:Src/util.c    ****         input1[inIdx].raw = commandL.steer;
 839:Src/util.c    ****         input2[inIdx].raw = commandL.speed;
 840:Src/util.c    ****       #endif
 841:Src/util.c    ****     }
 842:Src/util.c    ****     #endif
 843:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART3)
 844:Src/util.c    ****     if (inIdx == CONTROL_SERIAL_USART3) {
 845:Src/util.c    ****       #ifdef CONTROL_IBUS
 846:Src/util.c    ****         for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i+=2) {
 847:Src/util.c    ****           ibusR_captured_value[(i/2)] = CLAMP(commandR.channels[i] + (commandR.channels[i+1] << 8) 
 848:Src/util.c    ****         }
 849:Src/util.c    ****         input1[inIdx].raw = (ibusR_captured_value[0] - 500) * 2;
 850:Src/util.c    ****         input2[inIdx].raw = (ibusR_captured_value[1] - 500) * 2; 
 851:Src/util.c    ****       #else
 852:Src/util.c    ****         input1[inIdx].raw = commandR.steer;
 853:Src/util.c    ****         input2[inIdx].raw = commandR.speed;
 854:Src/util.c    ****       #endif
 855:Src/util.c    ****     }
 856:Src/util.c    ****     #endif
 857:Src/util.c    **** 
 858:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART2)
 859:Src/util.c    ****     if (inIdx == SIDEBOARD_SERIAL_USART2) {
 860:Src/util.c    ****       input1[inIdx].raw = Sideboard_L.cmd1;
 861:Src/util.c    ****       input2[inIdx].raw = Sideboard_L.cmd2;
 862:Src/util.c    ****     }
 863:Src/util.c    ****     #endif
 864:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART3)
 865:Src/util.c    ****     if (inIdx == SIDEBOARD_SERIAL_USART3) {
 866:Src/util.c    ****       input1[inIdx].raw = Sideboard_R.cmd1;
 867:Src/util.c    ****       input2[inIdx].raw = Sideboard_R.cmd2;
 868:Src/util.c    ****     }
 869:Src/util.c    ****     #endif
 870:Src/util.c    **** 
 871:Src/util.c    ****     #if defined(CONTROL_PPM_LEFT)
 872:Src/util.c    ****     if (inIdx == CONTROL_PPM_LEFT) {
 873:Src/util.c    ****       input1[inIdx].raw = (ppm_captured_value[0] - 500) * 2;
 874:Src/util.c    ****       input2[inIdx].raw = (ppm_captured_value[1] - 500) * 2;
 875:Src/util.c    ****     }
 876:Src/util.c    ****     #endif
 877:Src/util.c    ****     #if defined(CONTROL_PPM_RIGHT)
 878:Src/util.c    ****     if (inIdx == CONTROL_PPM_RIGHT) {
 879:Src/util.c    ****       input1[inIdx].raw = (ppm_captured_value[0] - 500) * 2;
 880:Src/util.c    ****       input2[inIdx].raw = (ppm_captured_value[1] - 500) * 2;
 881:Src/util.c    ****     }
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 44


 882:Src/util.c    ****     #endif
 883:Src/util.c    ****     #if (defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)) && defined(SUPPORT_BUTTONS)
 884:Src/util.c    ****       button1 = ppm_captured_value[5] > 500;
 885:Src/util.c    ****       button2 = 0;
 886:Src/util.c    ****     #endif
 887:Src/util.c    **** 
 888:Src/util.c    ****     #if defined(CONTROL_PWM_LEFT)
 889:Src/util.c    ****     if (inIdx == CONTROL_PWM_LEFT) {
 890:Src/util.c    ****       input1[inIdx].raw = (pwm_captured_ch1_value - 500) * 2;
 891:Src/util.c    ****       input2[inIdx].raw = (pwm_captured_ch2_value - 500) * 2;
 892:Src/util.c    ****     }
 893:Src/util.c    ****     #endif
 894:Src/util.c    ****     #if defined(CONTROL_PWM_RIGHT)
 895:Src/util.c    ****     if (inIdx == CONTROL_PWM_RIGHT) {
 896:Src/util.c    ****       input1[inIdx].raw = (pwm_captured_ch1_value - 500) * 2;
 897:Src/util.c    ****       input2[inIdx].raw = (pwm_captured_ch2_value - 500) * 2;
 898:Src/util.c    ****     }
 899:Src/util.c    ****     #endif
 900:Src/util.c    **** 
 901:Src/util.c    ****     #ifdef VARIANT_TRANSPOTTER
 902:Src/util.c    ****       #ifdef GAMETRAK_CONNECTION_NORMAL
 903:Src/util.c    ****         input1[inIdx].cmd = adc_buffer.l_rx2;
 904:Src/util.c    ****         input2[inIdx].cmd = adc_buffer.l_tx2;
 905:Src/util.c    ****       #endif
 906:Src/util.c    ****       #ifdef GAMETRAK_CONNECTION_ALTERNATE
 907:Src/util.c    ****         input1[inIdx].cmd = adc_buffer.l_tx2;
 908:Src/util.c    ****         input2[inIdx].cmd = adc_buffer.l_rx2;
 909:Src/util.c    ****       #endif
 910:Src/util.c    ****     #endif
 911:Src/util.c    **** }
 1423              		.loc 1 911 1 view .LVU365
 1424 0024 7047     		bx	lr
 1425              	.L97:
 1426 0026 00BF     		.align	2
 1427              	.L96:
 1428 0028 00000000 		.word	.LANCHOR17
 1429 002c 00000000 		.word	adc_buffer
 1430 0030 00000000 		.word	.LANCHOR15
 1431 0034 00000000 		.word	.LANCHOR16
 1432              		.cfi_endproc
 1433              	.LFE85:
 1435              		.section	.text.handleTimeout,"ax",%progbits
 1436              		.align	1
 1437              		.global	handleTimeout
 1438              		.syntax unified
 1439              		.thumb
 1440              		.thumb_func
 1441              		.fpu softvfp
 1443              	handleTimeout:
 1444              	.LFB86:
 912:Src/util.c    **** 
 913:Src/util.c    ****  /*
 914:Src/util.c    ****  * Function to handle the ADC, UART and General timeout (Nunchuk, PPM, PWM)
 915:Src/util.c    ****  */
 916:Src/util.c    **** void handleTimeout(void) {
 1445              		.loc 1 916 26 is_stmt 1 view -0
 1446              		.cfi_startproc
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 45


 1447              		@ args = 0, pretend = 0, frame = 0
 1448              		@ frame_needed = 0, uses_anonymous_args = 0
 1449 0000 08B5     		push	{r3, lr}
 1450              	.LCFI15:
 1451              		.cfi_def_cfa_offset 8
 1452              		.cfi_offset 3, -8
 1453              		.cfi_offset 14, -4
 917:Src/util.c    ****     #ifdef CONTROL_ADC
 918:Src/util.c    ****     if (inIdx == CONTROL_ADC) {
 1454              		.loc 1 918 5 view .LVU367
 1455              		.loc 1 918 15 is_stmt 0 view .LVU368
 1456 0002 354B     		ldr	r3, .L109
 1457 0004 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1458              		.loc 1 918 8 view .LVU369
 1459 0006 002B     		cmp	r3, #0
 1460 0008 3BD1     		bne	.L99
 919:Src/util.c    ****       // If input1 or Input2 is either below MIN - Threshold or above MAX + Threshold, ADC protecti
 920:Src/util.c    ****       if (IN_RANGE(input1[inIdx].raw, input1[inIdx].min - ADC_PROTECT_THRESH, input1[inIdx].max + A
 1461              		.loc 1 920 7 is_stmt 1 view .LVU370
 1462              		.loc 1 920 11 is_stmt 0 view .LVU371
 1463 000a 3449     		ldr	r1, .L109+4
 1464 000c C3EBC300 		rsb	r0, r3, r3, lsl #3
 1465 0010 4200     		lsls	r2, r0, #1
 1466 0012 8818     		adds	r0, r1, r2
 1467 0014 895E     		ldrsh	r1, [r1, r2]
 1468 0016 B0F90620 		ldrsh	r2, [r0, #6]
 1469 001a C83A     		subs	r2, r2, #200
 1470              		.loc 1 920 10 view .LVU372
 1471 001c 9142     		cmp	r1, r2
 1472 001e 24DB     		blt	.L100
 1473              		.loc 1 920 11 discriminator 1 view .LVU373
 1474 0020 C3EBC302 		rsb	r2, r3, r3, lsl #3
 1475 0024 5000     		lsls	r0, r2, #1
 1476 0026 2D4A     		ldr	r2, .L109+4
 1477 0028 0244     		add	r2, r2, r0
 1478 002a B2F90A20 		ldrsh	r2, [r2, #10]
 1479 002e C832     		adds	r2, r2, #200
 1480 0030 9142     		cmp	r1, r2
 1481 0032 1ADC     		bgt	.L100
 921:Src/util.c    ****           IN_RANGE(input2[inIdx].raw, input2[inIdx].min - ADC_PROTECT_THRESH, input2[inIdx].max + A
 1482              		.loc 1 921 11 discriminator 2 view .LVU374
 1483 0034 2A49     		ldr	r1, .L109+8
 1484 0036 C3EBC300 		rsb	r0, r3, r3, lsl #3
 1485 003a 4200     		lsls	r2, r0, #1
 1486 003c 8818     		adds	r0, r1, r2
 1487 003e 895E     		ldrsh	r1, [r1, r2]
 1488 0040 B0F90620 		ldrsh	r2, [r0, #6]
 1489 0044 C83A     		subs	r2, r2, #200
 920:Src/util.c    ****           IN_RANGE(input2[inIdx].raw, input2[inIdx].min - ADC_PROTECT_THRESH, input2[inIdx].max + A
 1490              		.loc 1 920 119 discriminator 2 view .LVU375
 1491 0046 9142     		cmp	r1, r2
 1492 0048 0FDB     		blt	.L100
 1493              		.loc 1 921 11 view .LVU376
 1494 004a C3EBC302 		rsb	r2, r3, r3, lsl #3
 1495 004e 5000     		lsls	r0, r2, #1
 1496 0050 234A     		ldr	r2, .L109+8
 1497 0052 0244     		add	r2, r2, r0
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 46


 1498 0054 B2F90A20 		ldrsh	r2, [r2, #10]
 1499 0058 C832     		adds	r2, r2, #200
 1500 005a 9142     		cmp	r1, r2
 1501 005c 05DC     		bgt	.L100
 922:Src/util.c    ****           timeoutFlgADC = 0;                            // Reset the timeout flag
 1502              		.loc 1 922 11 is_stmt 1 view .LVU377
 1503              		.loc 1 922 25 is_stmt 0 view .LVU378
 1504 005e 0022     		movs	r2, #0
 1505 0060 2049     		ldr	r1, .L109+12
 1506 0062 0A70     		strb	r2, [r1]
 923:Src/util.c    ****           timeoutCntADC = 0;                            // Reset the timeout counter
 1507              		.loc 1 923 11 is_stmt 1 view .LVU379
 1508              		.loc 1 923 25 is_stmt 0 view .LVU380
 1509 0064 2049     		ldr	r1, .L109+16
 1510 0066 0A80     		strh	r2, [r1]	@ movhi
 1511 0068 0BE0     		b	.L99
 1512              	.L100:
 924:Src/util.c    ****       } else {
 925:Src/util.c    ****         if (timeoutCntADC++ >= ADC_PROTECT_TIMEOUT) {   // Timeout qualification
 1513              		.loc 1 925 9 is_stmt 1 view .LVU381
 1514              		.loc 1 925 26 is_stmt 0 view .LVU382
 1515 006a 1F49     		ldr	r1, .L109+16
 1516 006c 0A88     		ldrh	r2, [r1]
 1517 006e 501C     		adds	r0, r2, #1
 1518 0070 0880     		strh	r0, [r1]	@ movhi
 1519              		.loc 1 925 12 view .LVU383
 1520 0072 632A     		cmp	r2, #99
 1521 0074 05D9     		bls	.L99
 926:Src/util.c    ****           timeoutFlgADC = 1;                            // Timeout detected
 1522              		.loc 1 926 11 is_stmt 1 view .LVU384
 1523              		.loc 1 926 25 is_stmt 0 view .LVU385
 1524 0076 1B4A     		ldr	r2, .L109+12
 1525 0078 0121     		movs	r1, #1
 1526 007a 1170     		strb	r1, [r2]
 927:Src/util.c    ****           timeoutCntADC = ADC_PROTECT_TIMEOUT;          // Limit timout counter value
 1527              		.loc 1 927 11 is_stmt 1 view .LVU386
 1528              		.loc 1 927 25 is_stmt 0 view .LVU387
 1529 007c 1A4A     		ldr	r2, .L109+16
 1530 007e 6421     		movs	r1, #100
 1531 0080 1180     		strh	r1, [r2]	@ movhi
 1532              	.L99:
 928:Src/util.c    ****         }
 929:Src/util.c    ****       }
 930:Src/util.c    ****     }
 931:Src/util.c    ****     #endif
 932:Src/util.c    **** 
 933:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART2)
 934:Src/util.c    ****       if (timeoutCntSerial_L++ >= SERIAL_TIMEOUT) {     // Timeout qualification
 935:Src/util.c    ****         timeoutFlgSerial_L = 1;                         // Timeout detected
 936:Src/util.c    ****         timeoutCntSerial_L = SERIAL_TIMEOUT;            // Limit timout counter value
 937:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_SERIAL_USART2) && CONTROL_SERIAL_USART2 == 1)
 938:Src/util.c    ****           inIdx = 0;                                    // Switch to Primary input in case of Timeo
 939:Src/util.c    ****         #endif
 940:Src/util.c    ****       } else {                                          // No Timeout
 941:Src/util.c    ****         #if defined(DUAL_INPUTS) && defined(SIDEBOARD_SERIAL_USART2)
 942:Src/util.c    ****           if (Sideboard_L.sensors & SWA_SET) {          // If SWA is set, switch to Sideboard contr
 943:Src/util.c    ****             inIdx = SIDEBOARD_SERIAL_USART2;
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 47


 944:Src/util.c    ****           } else {
 945:Src/util.c    ****             inIdx = !SIDEBOARD_SERIAL_USART2;
 946:Src/util.c    ****           }
 947:Src/util.c    ****         #elif defined(DUAL_INPUTS) && (defined(CONTROL_SERIAL_USART2) && CONTROL_SERIAL_USART2 == 1
 948:Src/util.c    ****           inIdx = 1;                                    // Switch to Auxiliary input in case of NO 
 949:Src/util.c    ****         #endif
 950:Src/util.c    ****       }
 951:Src/util.c    ****       #if (defined(CONTROL_SERIAL_USART2) && CONTROL_SERIAL_USART2 == 0) || (defined(SIDEBOARD_SERI
 952:Src/util.c    ****         timeoutFlgSerial = timeoutFlgSerial_L;          // Report Timeout only on the Primary Input
 953:Src/util.c    ****       #endif
 954:Src/util.c    ****     #endif
 955:Src/util.c    **** 
 956:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USART3)
 957:Src/util.c    ****       if (timeoutCntSerial_R++ >= SERIAL_TIMEOUT) {     // Timeout qualification
 958:Src/util.c    ****         timeoutFlgSerial_R = 1;                         // Timeout detected
 959:Src/util.c    ****         timeoutCntSerial_R = SERIAL_TIMEOUT;            // Limit timout counter value
 960:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_SERIAL_USART3) && CONTROL_SERIAL_USART3 == 1)
 961:Src/util.c    ****           inIdx = 0;                                    // Switch to Primary input in case of Timeo
 962:Src/util.c    ****         #endif
 963:Src/util.c    ****       } else {                                          // No Timeout
 964:Src/util.c    ****         #if defined(DUAL_INPUTS) && defined(SIDEBOARD_SERIAL_USART3)
 965:Src/util.c    ****           if (Sideboard_R.sensors & SWA_SET) {          // If SWA is set, switch to Sideboard contr
 966:Src/util.c    ****             inIdx = SIDEBOARD_SERIAL_USART3;
 967:Src/util.c    ****           } else {
 968:Src/util.c    ****             inIdx = !SIDEBOARD_SERIAL_USART3;
 969:Src/util.c    ****           }
 970:Src/util.c    ****         #elif defined(DUAL_INPUTS) && (defined(CONTROL_SERIAL_USART3) && CONTROL_SERIAL_USART3 == 1
 971:Src/util.c    ****           inIdx = 1;                                    // Switch to Auxiliary input in case of NO 
 972:Src/util.c    ****         #endif
 973:Src/util.c    ****       }
 974:Src/util.c    ****       #if (defined(CONTROL_SERIAL_USART3) && CONTROL_SERIAL_USART3 == 0) || (defined(SIDEBOARD_SERI
 975:Src/util.c    ****         timeoutFlgSerial = timeoutFlgSerial_R;          // Report Timeout only on the Primary Input
 976:Src/util.c    ****       #endif
 977:Src/util.c    ****     #endif
 978:Src/util.c    **** 
 979:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART2) && defined(SIDEBOARD_SERIAL_USART3)
 980:Src/util.c    ****       timeoutFlgSerial = timeoutFlgSerial_L || timeoutFlgSerial_R;
 981:Src/util.c    ****     #endif
 982:Src/util.c    **** 
 983:Src/util.c    ****     #if defined(CONTROL_NUNCHUK) || defined(SUPPORT_NUNCHUK) || defined(VARIANT_TRANSPOTTER) || \
 984:Src/util.c    ****         defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT) || defined(CONTROL_PWM_LEFT) || def
 985:Src/util.c    ****       if (timeoutCntGen++ >= TIMEOUT) {                 // Timeout qualification
 986:Src/util.c    ****         #if defined(CONTROL_NUNCHUK) || defined(SUPPORT_NUNCHUK) || defined(VARIANT_TRANSPOTTER) ||
 987:Src/util.c    ****             (defined(CONTROL_PPM_LEFT) && CONTROL_PPM_LEFT == 0) || (defined(CONTROL_PPM_RIGHT) && 
 988:Src/util.c    ****             (defined(CONTROL_PWM_LEFT) && CONTROL_PWM_LEFT == 0) || (defined(CONTROL_PWM_RIGHT) && 
 989:Src/util.c    ****           timeoutFlgGen = 1;                            // Report Timeout only on the Primary Input
 990:Src/util.c    ****           timeoutCntGen = TIMEOUT;
 991:Src/util.c    ****         #endif
 992:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_PPM_LEFT)  && CONTROL_PPM_LEFT == 1) || (defi
 993:Src/util.c    ****                                      (defined(CONTROL_PWM_LEFT)  && CONTROL_PWM_LEFT == 1) || (defi
 994:Src/util.c    ****           inIdx = 0;                                    // Switch to Primary input in case of Timeo
 995:Src/util.c    ****         #endif
 996:Src/util.c    ****       } else {
 997:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_PPM_LEFT)  && CONTROL_PPM_LEFT == 1) || (defi
 998:Src/util.c    ****                                      (defined(CONTROL_PWM_LEFT)  && CONTROL_PWM_LEFT == 1) || (defi
 999:Src/util.c    ****           inIdx = 1;                                    // Switch to Auxiliary input in case of NO 
1000:Src/util.c    ****         #endif
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 48


1001:Src/util.c    ****       }
1002:Src/util.c    ****     #endif
1003:Src/util.c    **** 
1004:Src/util.c    ****     // In case of timeout bring the system to a Safe State
1005:Src/util.c    ****     if (timeoutFlgADC || timeoutFlgSerial || timeoutFlgGen) {
 1533              		.loc 1 1005 5 is_stmt 1 view .LVU388
 1534              		.loc 1 1005 9 is_stmt 0 view .LVU389
 1535 0082 184A     		ldr	r2, .L109+12
 1536 0084 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 1537              		.loc 1 1005 8 view .LVU390
 1538 0086 2AB9     		cbnz	r2, .L101
 1539              		.loc 1 1005 23 discriminator 1 view .LVU391
 1540 0088 184A     		ldr	r2, .L109+20
 1541 008a 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 1542 008c 12B9     		cbnz	r2, .L101
 1543              		.loc 1 1005 43 discriminator 2 view .LVU392
 1544 008e 184A     		ldr	r2, .L109+24
 1545 0090 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 1546 0092 A2B1     		cbz	r2, .L102
 1547              	.L101:
1006:Src/util.c    ****       ctrlModReq  = OPEN_MODE;                                          // Request OPEN_MODE. This 
 1548              		.loc 1 1006 7 is_stmt 1 view .LVU393
 1549              		.loc 1 1006 19 is_stmt 0 view .LVU394
 1550 0094 0021     		movs	r1, #0
 1551 0096 174A     		ldr	r2, .L109+28
 1552 0098 1170     		strb	r1, [r2]
1007:Src/util.c    ****       input1[inIdx].cmd  = 0;
 1553              		.loc 1 1007 7 is_stmt 1 view .LVU395
 1554              		.loc 1 1007 26 is_stmt 0 view .LVU396
 1555 009a C3EBC302 		rsb	r2, r3, r3, lsl #3
 1556 009e 5000     		lsls	r0, r2, #1
 1557 00a0 0E4A     		ldr	r2, .L109+4
 1558 00a2 0244     		add	r2, r2, r0
 1559 00a4 5180     		strh	r1, [r2, #2]	@ movhi
1008:Src/util.c    ****       input2[inIdx].cmd  = 0;
 1560              		.loc 1 1008 7 is_stmt 1 view .LVU397
 1561              		.loc 1 1008 26 is_stmt 0 view .LVU398
 1562 00a6 0E4A     		ldr	r2, .L109+8
 1563 00a8 0244     		add	r2, r2, r0
 1564 00aa 5180     		strh	r1, [r2, #2]	@ movhi
 1565              	.L103:
1009:Src/util.c    ****     } else {
1010:Src/util.c    ****       ctrlModReq  = ctrlModReqRaw;                                      // Follow the Mode request
1011:Src/util.c    ****     }
1012:Src/util.c    **** 
1013:Src/util.c    ****     // Beep in case of Input index change
1014:Src/util.c    ****     if (inIdx && !inIdx_prev) {                                         // rising edge
 1566              		.loc 1 1014 5 is_stmt 1 view .LVU399
 1567              		.loc 1 1014 8 is_stmt 0 view .LVU400
 1568 00ac 13B1     		cbz	r3, .L104
 1569              		.loc 1 1014 18 discriminator 1 view .LVU401
 1570 00ae 124A     		ldr	r2, .L109+32
 1571 00b0 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 1572              		.loc 1 1014 15 discriminator 1 view .LVU402
 1573 00b2 4AB1     		cbz	r2, .L107
 1574              	.L104:
1015:Src/util.c    ****       beepShort(8);
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 49


1016:Src/util.c    ****     } else if (!inIdx && inIdx_prev) {                                  // falling edge
 1575              		.loc 1 1016 12 is_stmt 1 view .LVU403
 1576              		.loc 1 1016 15 is_stmt 0 view .LVU404
 1577 00b4 13B9     		cbnz	r3, .L98
 1578              		.loc 1 1016 23 discriminator 1 view .LVU405
 1579 00b6 104B     		ldr	r3, .L109+32
 1580 00b8 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1581 00ba 4BB9     		cbnz	r3, .L108
 1582              	.L98:
1017:Src/util.c    ****       beepShort(18);
1018:Src/util.c    ****     }
1019:Src/util.c    **** }
 1583              		.loc 1 1019 1 view .LVU406
 1584 00bc 08BD     		pop	{r3, pc}
 1585              	.L102:
1010:Src/util.c    ****     }
 1586              		.loc 1 1010 7 is_stmt 1 view .LVU407
1010:Src/util.c    ****     }
 1587              		.loc 1 1010 19 is_stmt 0 view .LVU408
 1588 00be 0F4A     		ldr	r2, .L109+36
 1589 00c0 1178     		ldrb	r1, [r2]	@ zero_extendqisi2
 1590 00c2 0C4A     		ldr	r2, .L109+28
 1591 00c4 1170     		strb	r1, [r2]
 1592 00c6 F1E7     		b	.L103
 1593              	.L107:
1015:Src/util.c    ****       beepShort(8);
 1594              		.loc 1 1015 7 is_stmt 1 view .LVU409
 1595 00c8 0820     		movs	r0, #8
 1596 00ca FFF7FEFF 		bl	beepShort
 1597              	.LVL90:
 1598 00ce F5E7     		b	.L98
 1599              	.L108:
1017:Src/util.c    ****       beepShort(18);
 1600              		.loc 1 1017 7 view .LVU410
 1601 00d0 1220     		movs	r0, #18
 1602 00d2 FFF7FEFF 		bl	beepShort
 1603              	.LVL91:
 1604              		.loc 1 1019 1 is_stmt 0 view .LVU411
 1605 00d6 F1E7     		b	.L98
 1606              	.L110:
 1607              		.align	2
 1608              	.L109:
 1609 00d8 00000000 		.word	.LANCHOR17
 1610 00dc 00000000 		.word	.LANCHOR15
 1611 00e0 00000000 		.word	.LANCHOR16
 1612 00e4 00000000 		.word	.LANCHOR18
 1613 00e8 00000000 		.word	.LANCHOR19
 1614 00ec 00000000 		.word	.LANCHOR20
 1615 00f0 00000000 		.word	timeoutFlgGen
 1616 00f4 00000000 		.word	.LANCHOR21
 1617 00f8 00000000 		.word	.LANCHOR23
 1618 00fc 00000000 		.word	.LANCHOR22
 1619              		.cfi_endproc
 1620              	.LFE86:
 1622              		.section	.text.readCommand,"ax",%progbits
 1623              		.align	1
 1624              		.global	readCommand
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 50


 1625              		.syntax unified
 1626              		.thumb
 1627              		.thumb_func
 1628              		.fpu softvfp
 1630              	readCommand:
 1631              	.LFB87:
1020:Src/util.c    **** 
1021:Src/util.c    ****  /*
1022:Src/util.c    ****  * Function to calculate the command to the motors. This function also manages:
1023:Src/util.c    ****  * - timeout detection
1024:Src/util.c    ****  * - MIN/MAX limitations and deadband
1025:Src/util.c    ****  */
1026:Src/util.c    **** void readCommand(void) {
 1632              		.loc 1 1026 24 is_stmt 1 view -0
 1633              		.cfi_startproc
 1634              		@ args = 0, pretend = 0, frame = 0
 1635              		@ frame_needed = 0, uses_anonymous_args = 0
 1636 0000 70B5     		push	{r4, r5, r6, lr}
 1637              	.LCFI16:
 1638              		.cfi_def_cfa_offset 16
 1639              		.cfi_offset 4, -16
 1640              		.cfi_offset 5, -12
 1641              		.cfi_offset 6, -8
 1642              		.cfi_offset 14, -4
1027:Src/util.c    ****     readInputRaw();
 1643              		.loc 1 1027 5 view .LVU413
 1644 0002 FFF7FEFF 		bl	readInputRaw
 1645              	.LVL92:
1028:Src/util.c    **** 
1029:Src/util.c    ****     #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
1030:Src/util.c    ****       calcInputCmd(&input1[inIdx], INPUT_MIN, INPUT_MAX);
 1646              		.loc 1 1030 7 view .LVU414
 1647              		.loc 1 1030 27 is_stmt 0 view .LVU415
 1648 0006 0F4E     		ldr	r6, .L113
 1649 0008 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 1650              		.loc 1 1030 7 view .LVU416
 1651 000a 0F4D     		ldr	r5, .L113+4
 1652 000c 0F4C     		ldr	r4, .L113+8
 1653 000e C3EBC303 		rsb	r3, r3, r3, lsl #3
 1654 0012 5800     		lsls	r0, r3, #1
 1655 0014 B5F90020 		ldrsh	r2, [r5]
 1656 0018 B4F90010 		ldrsh	r1, [r4]
 1657 001c 0C4B     		ldr	r3, .L113+12
 1658 001e 1844     		add	r0, r0, r3
 1659 0020 FFF7FEFF 		bl	calcInputCmd
 1660              	.LVL93:
1031:Src/util.c    ****       #if !defined(VARIANT_SKATEBOARD)
1032:Src/util.c    ****         calcInputCmd(&input2[inIdx], INPUT_MIN, INPUT_MAX);
 1661              		.loc 1 1032 9 is_stmt 1 view .LVU417
 1662              		.loc 1 1032 29 is_stmt 0 view .LVU418
 1663 0024 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 1664              		.loc 1 1032 9 view .LVU419
 1665 0026 C3EBC303 		rsb	r3, r3, r3, lsl #3
 1666 002a 5800     		lsls	r0, r3, #1
 1667 002c B5F90020 		ldrsh	r2, [r5]
 1668 0030 B4F90010 		ldrsh	r1, [r4]
 1669 0034 074B     		ldr	r3, .L113+16
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 51


 1670 0036 1844     		add	r0, r0, r3
 1671 0038 FFF7FEFF 		bl	calcInputCmd
 1672              	.LVL94:
1033:Src/util.c    ****       #else
1034:Src/util.c    ****         calcInputCmd(&input2[inIdx], INPUT_BRK, INPUT_MAX);
1035:Src/util.c    ****       #endif
1036:Src/util.c    ****     #endif
1037:Src/util.c    **** 
1038:Src/util.c    ****     handleTimeout();
 1673              		.loc 1 1038 5 is_stmt 1 view .LVU420
 1674 003c FFF7FEFF 		bl	handleTimeout
 1675              	.LVL95:
1039:Src/util.c    **** 
1040:Src/util.c    ****     #ifdef VARIANT_HOVERCAR
1041:Src/util.c    ****     if (inIdx == CONTROL_ADC) {
1042:Src/util.c    ****       brakePressed = (uint8_t)(input1[inIdx].cmd > 50);
1043:Src/util.c    ****     }
1044:Src/util.c    ****     else {
1045:Src/util.c    ****       brakePressed = (uint8_t)(input2[inIdx].cmd < -50);
1046:Src/util.c    ****     }
1047:Src/util.c    ****     #endif
1048:Src/util.c    **** 
1049:Src/util.c    ****     #if defined(SUPPORT_BUTTONS_LEFT) || defined(SUPPORT_BUTTONS_RIGHT)
1050:Src/util.c    ****       button1 = !HAL_GPIO_ReadPin(BUTTON1_PORT, BUTTON1_PIN);
1051:Src/util.c    ****       button2 = !HAL_GPIO_ReadPin(BUTTON2_PORT, BUTTON2_PIN);
1052:Src/util.c    ****     #endif
1053:Src/util.c    **** 
1054:Src/util.c    ****     #if defined(CRUISE_CONTROL_SUPPORT) && (defined(SUPPORT_BUTTONS) || defined(SUPPORT_BUTTONS_LEF
1055:Src/util.c    ****       cruiseControl(button1);                                           // Cruise control activatio
1056:Src/util.c    ****     #endif
1057:Src/util.c    **** }
 1676              		.loc 1 1057 1 is_stmt 0 view .LVU421
 1677 0040 70BD     		pop	{r4, r5, r6, pc}
 1678              	.L114:
 1679 0042 00BF     		.align	2
 1680              	.L113:
 1681 0044 00000000 		.word	.LANCHOR17
 1682 0048 00000000 		.word	.LANCHOR9
 1683 004c 00000000 		.word	.LANCHOR10
 1684 0050 00000000 		.word	.LANCHOR15
 1685 0054 00000000 		.word	.LANCHOR16
 1686              		.cfi_endproc
 1687              	.LFE87:
 1689              		.section	.text.usart2_rx_check,"ax",%progbits
 1690              		.align	1
 1691              		.global	usart2_rx_check
 1692              		.syntax unified
 1693              		.thumb
 1694              		.thumb_func
 1695              		.fpu softvfp
 1697              	usart2_rx_check:
 1698              	.LFB88:
1058:Src/util.c    **** 
1059:Src/util.c    **** 
1060:Src/util.c    **** /*
1061:Src/util.c    ****  * Check for new data received on USART2 with DMA: refactored function from https://github.com/MaJe
1062:Src/util.c    ****  * - this function is called for every USART IDLE line detection, in the USART interrupt handler
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 52


1063:Src/util.c    ****  */
1064:Src/util.c    **** void usart2_rx_check(void)
1065:Src/util.c    **** {
 1699              		.loc 1 1065 1 is_stmt 1 view -0
 1700              		.cfi_startproc
 1701              		@ args = 0, pretend = 0, frame = 0
 1702              		@ frame_needed = 0, uses_anonymous_args = 0
 1703              		@ link register save eliminated.
1066:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
1067:Src/util.c    ****   static uint32_t old_pos;
1068:Src/util.c    ****   uint32_t pos;
1069:Src/util.c    ****   pos = rx_buffer_L_len - __HAL_DMA_GET_COUNTER(huart2.hdmarx);         // Calculate current positi
1070:Src/util.c    ****   #endif
1071:Src/util.c    **** 
1072:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2)
1073:Src/util.c    ****   uint8_t ptr[SERIAL_BUFFER_SIZE];
1074:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1075:Src/util.c    ****     if (pos > old_pos) {                                                // "Linear" buffer mode: ch
1076:Src/util.c    ****       usart_process_debug(&rx_buffer_L[old_pos], pos - old_pos);        // Process data
1077:Src/util.c    ****     } else {                                                            // "Overflow" buffer mode
1078:Src/util.c    ****       memcpy(&ptr[0], &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from
1079:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1080:Src/util.c    ****         memcpy(&ptr[rx_buffer_L_len - old_pos], &rx_buffer_L[0], pos);                             
1081:Src/util.c    ****       }
1082:Src/util.c    ****       usart_process_debug(ptr, rx_buffer_L_len - old_pos + pos);        // Process data
1083:Src/util.c    ****     }
1084:Src/util.c    ****   }
1085:Src/util.c    ****   #endif // DEBUG_SERIAL_USART2
1086:Src/util.c    **** 
1087:Src/util.c    ****   #ifdef CONTROL_SERIAL_USART2
1088:Src/util.c    ****   uint8_t *ptr;	
1089:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1090:Src/util.c    ****     ptr = (uint8_t *)&commandL_raw;                                     // Initialize the pointer w
1091:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == commandL_len) {             // "Linear" buffer mode: ch
1092:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], commandL_len);                 // Copy data. This is possi
1093:Src/util.c    ****       usart_process_command(&commandL_raw, &commandL, 2);               // Process data
1094:Src/util.c    ****     } else if ((rx_buffer_L_len - old_pos + pos) == commandL_len) {     // "Overflow" buffer mode: 
1095:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from the
1096:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1097:Src/util.c    ****         ptr += rx_buffer_L_len - old_pos;                               // Move to correct position
1098:Src/util.c    ****         memcpy(ptr, &rx_buffer_L[0], pos);                              // Copy remaining data
1099:Src/util.c    ****       }
1100:Src/util.c    ****       usart_process_command(&commandL_raw, &commandL, 2);               // Process data
1101:Src/util.c    ****     }
1102:Src/util.c    ****   }
1103:Src/util.c    ****   #endif // CONTROL_SERIAL_USART2
1104:Src/util.c    **** 
1105:Src/util.c    ****   #ifdef SIDEBOARD_SERIAL_USART2
1106:Src/util.c    ****   uint8_t *ptr;	
1107:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1108:Src/util.c    ****     ptr = (uint8_t *)&Sideboard_L_raw;                                  // Initialize the pointer w
1109:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == Sideboard_L_len) {          // "Linear" buffer mode: ch
1110:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], Sideboard_L_len);              // Copy data. This is possi
1111:Src/util.c    ****       usart_process_sideboard(&Sideboard_L_raw, &Sideboard_L, 2);       // Process data
1112:Src/util.c    ****     } else if ((rx_buffer_L_len - old_pos + pos) == Sideboard_L_len) {  // "Overflow" buffer mode: 
1113:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from the
1114:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 53


1115:Src/util.c    ****         ptr += rx_buffer_L_len - old_pos;                               // Move to correct position
1116:Src/util.c    ****         memcpy(ptr, &rx_buffer_L[0], pos);                              // Copy remaining data
1117:Src/util.c    ****       }
1118:Src/util.c    ****       usart_process_sideboard(&Sideboard_L_raw, &Sideboard_L, 2);       // Process data
1119:Src/util.c    ****     }
1120:Src/util.c    ****   }
1121:Src/util.c    ****   #endif // SIDEBOARD_SERIAL_USART2
1122:Src/util.c    **** 
1123:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
1124:Src/util.c    ****   old_pos = pos;                                                        // Update old position
1125:Src/util.c    ****   if (old_pos == rx_buffer_L_len) {                                     // Check and manually updat
1126:Src/util.c    ****     old_pos = 0;
1127:Src/util.c    ****   }
1128:Src/util.c    **** 	#endif
1129:Src/util.c    **** }
 1704              		.loc 1 1129 1 view .LVU423
 1705 0000 7047     		bx	lr
 1706              		.cfi_endproc
 1707              	.LFE88:
 1709              		.section	.text.usart3_rx_check,"ax",%progbits
 1710              		.align	1
 1711              		.global	usart3_rx_check
 1712              		.syntax unified
 1713              		.thumb
 1714              		.thumb_func
 1715              		.fpu softvfp
 1717              	usart3_rx_check:
 1718              	.LFB89:
1130:Src/util.c    **** 
1131:Src/util.c    **** 
1132:Src/util.c    **** /*
1133:Src/util.c    ****  * Check for new data received on USART3 with DMA: refactored function from https://github.com/MaJe
1134:Src/util.c    ****  * - this function is called for every USART IDLE line detection, in the USART interrupt handler
1135:Src/util.c    ****  */
1136:Src/util.c    **** void usart3_rx_check(void)
1137:Src/util.c    **** {
 1719              		.loc 1 1137 1 view -0
 1720              		.cfi_startproc
 1721              		@ args = 0, pretend = 0, frame = 64
 1722              		@ frame_needed = 0, uses_anonymous_args = 0
 1723 0000 30B5     		push	{r4, r5, lr}
 1724              	.LCFI17:
 1725              		.cfi_def_cfa_offset 12
 1726              		.cfi_offset 4, -12
 1727              		.cfi_offset 5, -8
 1728              		.cfi_offset 14, -4
 1729 0002 91B0     		sub	sp, sp, #68
 1730              	.LCFI18:
 1731              		.cfi_def_cfa_offset 80
1138:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
1139:Src/util.c    ****   static uint32_t old_pos;
 1732              		.loc 1 1139 3 view .LVU425
1140:Src/util.c    ****   uint32_t pos;  
 1733              		.loc 1 1140 3 view .LVU426
1141:Src/util.c    ****   pos = rx_buffer_R_len - __HAL_DMA_GET_COUNTER(huart3.hdmarx);         // Calculate current positi
 1734              		.loc 1 1141 3 view .LVU427
 1735              		.loc 1 1141 27 is_stmt 0 view .LVU428
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 54


 1736 0004 124B     		ldr	r3, .L123
 1737 0006 5B6B     		ldr	r3, [r3, #52]
 1738 0008 1B68     		ldr	r3, [r3]
 1739 000a 5C68     		ldr	r4, [r3, #4]
 1740              		.loc 1 1141 7 view .LVU429
 1741 000c C4F14004 		rsb	r4, r4, #64
 1742              	.LVL96:
1142:Src/util.c    ****   #endif
1143:Src/util.c    **** 
1144:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3)
1145:Src/util.c    ****   uint8_t ptr[SERIAL_BUFFER_SIZE];
 1743              		.loc 1 1145 3 is_stmt 1 view .LVU430
1146:Src/util.c    **** 
1147:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
 1744              		.loc 1 1147 3 view .LVU431
 1745              		.loc 1 1147 11 is_stmt 0 view .LVU432
 1746 0010 104B     		ldr	r3, .L123+4
 1747 0012 1B68     		ldr	r3, [r3]
 1748              		.loc 1 1147 6 view .LVU433
 1749 0014 A342     		cmp	r3, r4
 1750 0016 00D0     		beq	.L117
1148:Src/util.c    ****     if (pos > old_pos) {                                                // "Linear" buffer mode: ch
 1751              		.loc 1 1148 5 is_stmt 1 view .LVU434
 1752              		.loc 1 1148 8 is_stmt 0 view .LVU435
 1753 0018 05D2     		bcs	.L121
 1754              	.L117:
1149:Src/util.c    ****       usart_process_debug(&rx_buffer_R[old_pos], pos - old_pos);        // Process data
1150:Src/util.c    ****     } else {                                                            // "Overflow" buffer mode
1151:Src/util.c    ****       memcpy(&ptr[0], &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy data from
1152:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1153:Src/util.c    ****         memcpy(&ptr[rx_buffer_R_len - old_pos], &rx_buffer_R[0], pos);                             
1154:Src/util.c    ****       }
1155:Src/util.c    ****       usart_process_debug(ptr, rx_buffer_R_len - old_pos + pos);        // Process data
1156:Src/util.c    ****     }
1157:Src/util.c    ****   }
1158:Src/util.c    ****   #endif // DEBUG_SERIAL_USART3
1159:Src/util.c    **** 
1160:Src/util.c    ****   #ifdef CONTROL_SERIAL_USART3
1161:Src/util.c    ****   uint8_t *ptr;
1162:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1163:Src/util.c    ****     ptr = (uint8_t *)&commandR_raw;                                     // Initialize the pointer w
1164:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == commandR_len) {             // "Linear" buffer mode: ch
1165:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], commandR_len);                 // Copy data. This is possi
1166:Src/util.c    ****       usart_process_command(&commandR_raw, &commandR, 3);               // Process data
1167:Src/util.c    ****     } else if ((rx_buffer_R_len - old_pos + pos) == commandR_len) {     // "Overflow" buffer mode: 
1168:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy data from the
1169:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1170:Src/util.c    ****         ptr += rx_buffer_R_len - old_pos;                               // Move to correct position
1171:Src/util.c    ****         memcpy(ptr, &rx_buffer_R[0], pos);                              // Copy remaining data
1172:Src/util.c    ****       }
1173:Src/util.c    ****       usart_process_command(&commandR_raw, &commandR, 3);               // Process data
1174:Src/util.c    ****     }
1175:Src/util.c    ****   }
1176:Src/util.c    ****   #endif // CONTROL_SERIAL_USART3
1177:Src/util.c    **** 
1178:Src/util.c    ****   #ifdef SIDEBOARD_SERIAL_USART3
1179:Src/util.c    ****   uint8_t *ptr;
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 55


1180:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1181:Src/util.c    ****     ptr = (uint8_t *)&Sideboard_R_raw;                                  // Initialize the pointer w
1182:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == Sideboard_R_len) {          // "Linear" buffer mode: ch
1183:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], Sideboard_R_len);              // Copy data. This is possi
1184:Src/util.c    ****       usart_process_sideboard(&Sideboard_R_raw, &Sideboard_R, 3);       // Process data
1185:Src/util.c    ****     } else if ((rx_buffer_R_len - old_pos + pos) == Sideboard_R_len) {  // "Overflow" buffer mode: 
1186:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy data from the
1187:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1188:Src/util.c    ****         ptr += rx_buffer_R_len - old_pos;                               // Move to correct position
1189:Src/util.c    ****         memcpy(ptr, &rx_buffer_R[0], pos);                              // Copy remaining data
1190:Src/util.c    ****       }
1191:Src/util.c    ****       usart_process_sideboard(&Sideboard_R_raw, &Sideboard_R, 3);       // Process data
1192:Src/util.c    ****     }
1193:Src/util.c    ****   }
1194:Src/util.c    ****   #endif // SIDEBOARD_SERIAL_USART3
1195:Src/util.c    **** 
1196:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
1197:Src/util.c    ****   old_pos = pos;                                                        // Update old position
 1755              		.loc 1 1197 3 is_stmt 1 view .LVU436
 1756              		.loc 1 1197 11 is_stmt 0 view .LVU437
 1757 001a 0E4B     		ldr	r3, .L123+4
 1758 001c 1C60     		str	r4, [r3]
1198:Src/util.c    ****   if (old_pos == rx_buffer_R_len) {                                     // Check and manually updat
 1759              		.loc 1 1198 3 is_stmt 1 view .LVU438
 1760              		.loc 1 1198 6 is_stmt 0 view .LVU439
 1761 001e 402C     		cmp	r4, #64
 1762 0020 12D0     		beq	.L122
 1763              	.L116:
1199:Src/util.c    ****     old_pos = 0;
1200:Src/util.c    ****   }
1201:Src/util.c    ****   #endif
1202:Src/util.c    **** }
 1764              		.loc 1 1202 1 view .LVU440
 1765 0022 11B0     		add	sp, sp, #68
 1766              	.LCFI19:
 1767              		.cfi_remember_state
 1768              		.cfi_def_cfa_offset 12
 1769              		@ sp needed
 1770 0024 30BD     		pop	{r4, r5, pc}
 1771              	.LVL97:
 1772              	.L121:
 1773              	.LCFI20:
 1774              		.cfi_restore_state
1151:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
 1775              		.loc 1 1151 7 is_stmt 1 view .LVU441
1151:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
 1776              		.loc 1 1151 62 is_stmt 0 view .LVU442
 1777 0026 C3F14005 		rsb	r5, r3, #64
1151:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
 1778              		.loc 1 1151 7 view .LVU443
 1779 002a 2A46     		mov	r2, r5
 1780 002c 0A49     		ldr	r1, .L123+8
 1781 002e 1944     		add	r1, r1, r3
 1782 0030 6846     		mov	r0, sp
 1783 0032 FFF7FEFF 		bl	memcpy
 1784              	.LVL98:
1152:Src/util.c    ****         memcpy(&ptr[rx_buffer_R_len - old_pos], &rx_buffer_R[0], pos);                             
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 56


 1785              		.loc 1 1152 7 is_stmt 1 view .LVU444
1152:Src/util.c    ****         memcpy(&ptr[rx_buffer_R_len - old_pos], &rx_buffer_R[0], pos);                             
 1786              		.loc 1 1152 10 is_stmt 0 view .LVU445
 1787 0036 002C     		cmp	r4, #0
 1788 0038 EFD0     		beq	.L117
1153:Src/util.c    ****       }
 1789              		.loc 1 1153 9 is_stmt 1 view .LVU446
 1790 003a 2246     		mov	r2, r4
 1791 003c 0649     		ldr	r1, .L123+8
 1792 003e 0DEB0500 		add	r0, sp, r5
 1793 0042 FFF7FEFF 		bl	memcpy
 1794              	.LVL99:
1155:Src/util.c    ****     }
 1795              		.loc 1 1155 7 view .LVU447
 1796 0046 E8E7     		b	.L117
 1797              	.L122:
1199:Src/util.c    ****   }
 1798              		.loc 1 1199 5 view .LVU448
1199:Src/util.c    ****   }
 1799              		.loc 1 1199 13 is_stmt 0 view .LVU449
 1800 0048 0022     		movs	r2, #0
 1801 004a 1A60     		str	r2, [r3]
 1802              		.loc 1 1202 1 view .LVU450
 1803 004c E9E7     		b	.L116
 1804              	.L124:
 1805 004e 00BF     		.align	2
 1806              	.L123:
 1807 0050 00000000 		.word	huart3
 1808 0054 00000000 		.word	.LANCHOR24
 1809 0058 00000000 		.word	.LANCHOR13
 1810              		.cfi_endproc
 1811              	.LFE89:
 1813              		.section	.text.usart_process_debug,"ax",%progbits
 1814              		.align	1
 1815              		.global	usart_process_debug
 1816              		.syntax unified
 1817              		.thumb
 1818              		.thumb_func
 1819              		.fpu softvfp
 1821              	usart_process_debug:
 1822              	.LVL100:
 1823              	.LFB90:
1203:Src/util.c    **** 
1204:Src/util.c    **** /*
1205:Src/util.c    ****  * Process Rx debug user command input
1206:Src/util.c    ****  */
1207:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
1208:Src/util.c    **** void usart_process_debug(uint8_t *userCommand, uint32_t len)
1209:Src/util.c    **** {
 1824              		.loc 1 1209 1 is_stmt 1 view -0
 1825              		.cfi_startproc
 1826              		@ args = 0, pretend = 0, frame = 0
 1827              		@ frame_needed = 0, uses_anonymous_args = 0
 1828              		@ link register save eliminated.
1210:Src/util.c    ****   #ifdef DEBUG_SERIAL_PROTOCOL
1211:Src/util.c    ****     handle_input(userCommand, len);
1212:Src/util.c    ****   #endif
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 57


1213:Src/util.c    **** }
 1829              		.loc 1 1213 1 view .LVU452
 1830 0000 7047     		bx	lr
 1831              		.cfi_endproc
 1832              	.LFE90:
 1834              		.section	.text.sideboardLeds,"ax",%progbits
 1835              		.align	1
 1836              		.global	sideboardLeds
 1837              		.syntax unified
 1838              		.thumb
 1839              		.thumb_func
 1840              		.fpu softvfp
 1842              	sideboardLeds:
 1843              	.LVL101:
 1844              	.LFB91:
1214:Src/util.c    **** 
1215:Src/util.c    **** #endif // SERIAL_DEBUG
1216:Src/util.c    **** 
1217:Src/util.c    **** /*
1218:Src/util.c    ****  * Process command Rx data
1219:Src/util.c    ****  * - if the command_in data is valid (correct START_FRAME and checksum) copy the command_in to comm
1220:Src/util.c    ****  */
1221:Src/util.c    **** #if defined(CONTROL_SERIAL_USART2) || defined(CONTROL_SERIAL_USART3)
1222:Src/util.c    **** void usart_process_command(SerialCommand *command_in, SerialCommand *command_out, uint8_t usart_idx
1223:Src/util.c    **** {
1224:Src/util.c    ****   #ifdef CONTROL_IBUS
1225:Src/util.c    ****     uint16_t ibus_chksum;
1226:Src/util.c    ****     if (command_in->start == IBUS_LENGTH && command_in->type == IBUS_COMMAND) {
1227:Src/util.c    ****       ibus_chksum = 0xFFFF - IBUS_LENGTH - IBUS_COMMAND;
1228:Src/util.c    ****       for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i++) {
1229:Src/util.c    ****         ibus_chksum -= command_in->channels[i];
1230:Src/util.c    ****       }
1231:Src/util.c    ****       if (ibus_chksum == (uint16_t)((command_in->checksumh << 8) + command_in->checksuml)) {
1232:Src/util.c    ****         *command_out = *command_in;
1233:Src/util.c    ****         if (usart_idx == 2) {             // Sideboard USART2
1234:Src/util.c    ****           #ifdef CONTROL_SERIAL_USART2
1235:Src/util.c    ****           timeoutFlgSerial_L = 0;         // Clear timeout flag
1236:Src/util.c    ****           timeoutCntSerial_L = 0;         // Reset timeout counter
1237:Src/util.c    ****           #endif
1238:Src/util.c    ****         } else if (usart_idx == 3) {      // Sideboard USART3
1239:Src/util.c    ****           #ifdef CONTROL_SERIAL_USART3
1240:Src/util.c    ****           timeoutFlgSerial_R = 0;         // Clear timeout flag
1241:Src/util.c    ****           timeoutCntSerial_R = 0;         // Reset timeout counter
1242:Src/util.c    ****           #endif
1243:Src/util.c    ****         }
1244:Src/util.c    ****       }
1245:Src/util.c    ****     }
1246:Src/util.c    ****   #else
1247:Src/util.c    ****   uint16_t checksum;
1248:Src/util.c    ****   if (command_in->start == SERIAL_START_FRAME) {
1249:Src/util.c    ****     checksum = (uint16_t)(command_in->start ^ command_in->steer ^ command_in->speed);
1250:Src/util.c    ****     if (command_in->checksum == checksum) {
1251:Src/util.c    ****       *command_out = *command_in;
1252:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
1253:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART2
1254:Src/util.c    ****         timeoutFlgSerial_L = 0;         // Clear timeout flag
1255:Src/util.c    ****         timeoutCntSerial_L = 0;         // Reset timeout counter
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 58


1256:Src/util.c    ****         #endif
1257:Src/util.c    ****       } else if (usart_idx == 3) {      // Sideboard USART3
1258:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART3
1259:Src/util.c    ****         timeoutFlgSerial_R = 0;         // Clear timeout flag
1260:Src/util.c    ****         timeoutCntSerial_R = 0;         // Reset timeout counter
1261:Src/util.c    ****         #endif
1262:Src/util.c    ****       }
1263:Src/util.c    ****     }
1264:Src/util.c    ****   }
1265:Src/util.c    ****   #endif
1266:Src/util.c    **** }
1267:Src/util.c    **** #endif
1268:Src/util.c    **** 
1269:Src/util.c    **** /*
1270:Src/util.c    ****  * Process Sideboard Rx data
1271:Src/util.c    ****  * - if the Sideboard_in data is valid (correct START_FRAME and checksum) copy the Sideboard_in to 
1272:Src/util.c    ****  */
1273:Src/util.c    **** #if defined(SIDEBOARD_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART3)
1274:Src/util.c    **** void usart_process_sideboard(SerialSideboard *Sideboard_in, SerialSideboard *Sideboard_out, uint8_t
1275:Src/util.c    **** {
1276:Src/util.c    ****   uint16_t checksum;
1277:Src/util.c    ****   if (Sideboard_in->start == SERIAL_START_FRAME) {
1278:Src/util.c    ****     checksum = (uint16_t)(Sideboard_in->start ^ Sideboard_in->pitch ^ Sideboard_in->dPitch ^ Sidebo
1279:Src/util.c    ****     if (Sideboard_in->checksum == checksum) {
1280:Src/util.c    ****       *Sideboard_out = *Sideboard_in;
1281:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
1282:Src/util.c    ****         #ifdef SIDEBOARD_SERIAL_USART2
1283:Src/util.c    ****         timeoutCntSerial_L  = 0;        // Reset timeout counter
1284:Src/util.c    ****         timeoutFlgSerial_L = 0;         // Clear timeout flag
1285:Src/util.c    ****         #endif
1286:Src/util.c    ****       } else if (usart_idx == 3) {      // Sideboard USART3
1287:Src/util.c    ****         #ifdef SIDEBOARD_SERIAL_USART3
1288:Src/util.c    ****         timeoutCntSerial_R = 0;         // Reset timeout counter
1289:Src/util.c    ****         timeoutFlgSerial_R = 0;         // Clear timeout flag
1290:Src/util.c    ****         #endif
1291:Src/util.c    ****       }
1292:Src/util.c    ****     }
1293:Src/util.c    ****   }
1294:Src/util.c    **** }
1295:Src/util.c    **** #endif
1296:Src/util.c    **** 
1297:Src/util.c    **** 
1298:Src/util.c    **** /* =========================== Sideboard Functions =========================== */
1299:Src/util.c    **** 
1300:Src/util.c    **** /*
1301:Src/util.c    ****  * Sideboard LEDs Handling
1302:Src/util.c    ****  * This function manages the leds behavior connected to the sideboard
1303:Src/util.c    ****  */
1304:Src/util.c    **** void sideboardLeds(uint8_t *leds) {
 1845              		.loc 1 1304 35 view -0
 1846              		.cfi_startproc
 1847              		@ args = 0, pretend = 0, frame = 0
 1848              		@ frame_needed = 0, uses_anonymous_args = 0
 1849              		@ link register save eliminated.
1305:Src/util.c    ****   #if defined(SIDEBOARD_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART3)
1306:Src/util.c    ****     // Enable flag: use LED4 (bottom Blue)
1307:Src/util.c    ****     // enable == 1, turn on led
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 59


1308:Src/util.c    ****     // enable == 0, blink led
1309:Src/util.c    ****     if (enable) {
1310:Src/util.c    ****       *leds |= LED4_SET;
1311:Src/util.c    ****     } else if (!enable && (main_loop_counter % 20 == 0)) {
1312:Src/util.c    ****       *leds ^= LED4_SET;
1313:Src/util.c    ****     }
1314:Src/util.c    **** 
1315:Src/util.c    ****     // Backward Drive: use LED5 (upper Blue)
1316:Src/util.c    ****     // backwardDrive == 1, blink led
1317:Src/util.c    ****     // backwardDrive == 0, turn off led
1318:Src/util.c    ****     if (backwardDrive && (main_loop_counter % 50 == 0)) {
1319:Src/util.c    ****       *leds ^= LED5_SET;
1320:Src/util.c    ****     }
1321:Src/util.c    **** 
1322:Src/util.c    ****     // Brake: use LED5 (upper Blue)
1323:Src/util.c    ****     // brakePressed == 1, turn on led
1324:Src/util.c    ****     // brakePressed == 0, turn off led
1325:Src/util.c    ****     #ifdef VARIANT_HOVERCAR
1326:Src/util.c    ****       if (brakePressed) {
1327:Src/util.c    ****         *leds |= LED5_SET;
1328:Src/util.c    ****       } else if (!brakePressed && !backwardDrive) {
1329:Src/util.c    ****         *leds &= ~LED5_SET;
1330:Src/util.c    ****       }
1331:Src/util.c    ****     #endif
1332:Src/util.c    **** 
1333:Src/util.c    ****     // Battery Level Indicator: use LED1, LED2, LED3
1334:Src/util.c    ****     if (main_loop_counter % BAT_BLINK_INTERVAL == 0) {              //  | RED (LED1) | YELLOW (LED3
1335:Src/util.c    ****       if (batVoltage < BAT_DEAD) {                                  //  |     0      |       0     
1336:Src/util.c    ****         *leds &= ~LED1_SET & ~LED3_SET & ~LED2_SET;
1337:Src/util.c    ****       } else if (batVoltage < BAT_LVL1) {                           //  |     B      |       0     
1338:Src/util.c    ****         *leds ^= LED1_SET;
1339:Src/util.c    ****         *leds &= ~LED3_SET & ~LED2_SET;
1340:Src/util.c    ****       } else if (batVoltage < BAT_LVL2) {                           //  |     1      |       0     
1341:Src/util.c    ****         *leds |= LED1_SET;
1342:Src/util.c    ****         *leds &= ~LED3_SET & ~LED2_SET;
1343:Src/util.c    ****       } else if (batVoltage < BAT_LVL3) {                           //  |     0      |       B     
1344:Src/util.c    ****         *leds ^= LED3_SET;
1345:Src/util.c    ****         *leds &= ~LED1_SET & ~LED2_SET;
1346:Src/util.c    ****       } else if (batVoltage < BAT_LVL4) {                           //  |     0      |       1     
1347:Src/util.c    ****         *leds |= LED3_SET;
1348:Src/util.c    ****         *leds &= ~LED1_SET & ~LED2_SET;
1349:Src/util.c    ****       } else if (batVoltage < BAT_LVL5) {                           //  |     0      |       0     
1350:Src/util.c    ****         *leds ^= LED2_SET;
1351:Src/util.c    ****         *leds &= ~LED1_SET & ~LED3_SET;
1352:Src/util.c    ****       } else {                                                      //  |     0      |       0     
1353:Src/util.c    ****         *leds |= LED2_SET;
1354:Src/util.c    ****         *leds &= ~LED1_SET & ~LED3_SET;
1355:Src/util.c    ****       }
1356:Src/util.c    ****     }
1357:Src/util.c    **** 
1358:Src/util.c    ****     // Error handling
1359:Src/util.c    ****     // Critical error:  LED1 on (RED)     + high pitch beep (hadled in main)
1360:Src/util.c    ****     // Soft error:      LED3 on (YELLOW)  + low  pitch beep (hadled in main)
1361:Src/util.c    ****     if (rtY_Left.z_errCode || rtY_Right.z_errCode) {
1362:Src/util.c    ****       *leds |= LED1_SET;
1363:Src/util.c    ****       *leds &= ~LED3_SET & ~LED2_SET;
1364:Src/util.c    ****     }
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 60


1365:Src/util.c    ****     if (timeoutFlgADC || timeoutFlgSerial) {
1366:Src/util.c    ****       *leds |= LED3_SET;
1367:Src/util.c    ****       *leds &= ~LED1_SET & ~LED2_SET;
1368:Src/util.c    ****     }
1369:Src/util.c    ****   #endif
1370:Src/util.c    **** }
 1850              		.loc 1 1370 1 view .LVU454
 1851 0000 7047     		bx	lr
 1852              		.cfi_endproc
 1853              	.LFE91:
 1855              		.section	.text.sideboardSensors,"ax",%progbits
 1856              		.align	1
 1857              		.global	sideboardSensors
 1858              		.syntax unified
 1859              		.thumb
 1860              		.thumb_func
 1861              		.fpu softvfp
 1863              	sideboardSensors:
 1864              	.LVL102:
 1865              	.LFB92:
1371:Src/util.c    **** 
1372:Src/util.c    **** /*
1373:Src/util.c    ****  * Sideboard Sensor Handling
1374:Src/util.c    ****  * This function manages the sideboards photo sensors.
1375:Src/util.c    ****  * In non-hoverboard variants, the sensors are used as push buttons.
1376:Src/util.c    ****  */
1377:Src/util.c    **** void sideboardSensors(uint8_t sensors) {
 1866              		.loc 1 1377 40 view -0
 1867              		.cfi_startproc
 1868              		@ args = 0, pretend = 0, frame = 0
 1869              		@ frame_needed = 0, uses_anonymous_args = 0
 1870              		@ link register save eliminated.
1378:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && (defined(SIDEBOARD_SERIAL_USART2) || defined(SIDEBOARD_SERIAL
1379:Src/util.c    ****     static uint8_t sensor1_index;                                 // holds the press index number f
1380:Src/util.c    ****     static uint8_t sensor1_prev,  sensor2_prev;
1381:Src/util.c    ****     uint8_t sensor1_trig = 0, sensor2_trig = 0;
1382:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART2)
1383:Src/util.c    ****     uint8_t  sideboardIdx = SIDEBOARD_SERIAL_USART2;
1384:Src/util.c    ****     uint16_t sideboardSns = Sideboard_L.sensors;
1385:Src/util.c    ****     #else
1386:Src/util.c    ****     uint8_t  sideboardIdx = SIDEBOARD_SERIAL_USART3;
1387:Src/util.c    ****     uint16_t sideboardSns = Sideboard_R.sensors;
1388:Src/util.c    ****     #endif
1389:Src/util.c    **** 
1390:Src/util.c    ****     if (inIdx == sideboardIdx) {                                  // Use Sideboard data
1391:Src/util.c    ****       sensor1_index = 2 + ((sideboardSns & SWB_SET) >> 9);        // SWB on RC transmitter is used 
1392:Src/util.c    ****       if (sensor1_index == 2) {                                   // FOC control Type
1393:Src/util.c    ****         sensor1_index = (sideboardSns & SWC_SET) >> 11;           // SWC on RC transmitter is used 
1394:Src/util.c    ****       }
1395:Src/util.c    ****       sensor1_trig  = sensor1_index != sensor1_prev;              // rising or falling edge change 
1396:Src/util.c    ****       if (inIdx != inIdx_prev) {                                  // Force one update at Input idx 
1397:Src/util.c    ****         sensor1_trig  = 1;
1398:Src/util.c    ****       }
1399:Src/util.c    ****       sensor1_prev  = sensor1_index;
1400:Src/util.c    ****     } else {                                                      // Use Optical switches
1401:Src/util.c    ****       sensor1_trig  = (sensors & SENSOR1_SET) && !sensor1_prev;   // rising edge detection
1402:Src/util.c    ****       sensor2_trig  = (sensors & SENSOR2_SET) && !sensor2_prev;   // rising edge detection
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 61


1403:Src/util.c    ****       sensor1_prev  =  sensors & SENSOR1_SET;
1404:Src/util.c    ****       sensor2_prev  =  sensors & SENSOR2_SET;
1405:Src/util.c    ****     }
1406:Src/util.c    **** 
1407:Src/util.c    ****     // Control MODE and Control Type Handling
1408:Src/util.c    ****     if (sensor1_trig) {
1409:Src/util.c    ****       switch (sensor1_index) {
1410:Src/util.c    ****         case 0:     // FOC VOLTAGE
1411:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = FOC_CTRL;
1412:Src/util.c    ****           ctrlModReqRaw         = VLT_MODE;
1413:Src/util.c    ****           break;
1414:Src/util.c    ****         case 1:     // FOC SPEED
1415:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = FOC_CTRL;
1416:Src/util.c    ****           ctrlModReqRaw         = SPD_MODE;
1417:Src/util.c    ****           break;
1418:Src/util.c    ****         case 2:     // FOC TORQUE
1419:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = FOC_CTRL;
1420:Src/util.c    ****           ctrlModReqRaw         = TRQ_MODE;
1421:Src/util.c    ****           break;
1422:Src/util.c    ****         case 3:     // SINUSOIDAL
1423:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = SIN_CTRL;
1424:Src/util.c    ****           break;
1425:Src/util.c    ****         case 4:     // COMMUTATION
1426:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = COM_CTRL;
1427:Src/util.c    ****           break;
1428:Src/util.c    ****       }
1429:Src/util.c    ****       if (inIdx == inIdx_prev) { beepShortMany(sensor1_index + 1, 1); }
1430:Src/util.c    ****       if (++sensor1_index > 4) { sensor1_index = 0; }
1431:Src/util.c    ****     }
1432:Src/util.c    **** 
1433:Src/util.c    ****     #ifdef CRUISE_CONTROL_SUPPORT                                 // Cruise Control Activation/Deac
1434:Src/util.c    ****       if (sensor2_trig) {
1435:Src/util.c    ****         cruiseControl(sensor2_trig);
1436:Src/util.c    ****       }
1437:Src/util.c    ****     #else                                                         // Field Weakening Activation/Dea
1438:Src/util.c    ****       static uint8_t  sensor2_index = 1;                          // holds the press index number f
1439:Src/util.c    **** 
1440:Src/util.c    ****       // Override in case the Sideboard control is Active
1441:Src/util.c    ****       if (inIdx == sideboardIdx) {                                // Use Sideboard data
1442:Src/util.c    ****         sensor2_index = (sideboardSns & SWD_SET) >> 13;           // SWD on RC transmitter is used 
1443:Src/util.c    ****         sensor2_trig  = sensor2_index != sensor2_prev;            // rising or falling edge change 
1444:Src/util.c    ****         if (inIdx != inIdx_prev) {                                // Force one update at Input idx 
1445:Src/util.c    ****           sensor2_trig  = 1;
1446:Src/util.c    ****         }
1447:Src/util.c    ****         sensor2_prev  = sensor2_index;
1448:Src/util.c    ****       }
1449:Src/util.c    **** 
1450:Src/util.c    ****       if (sensor2_trig) {
1451:Src/util.c    ****         switch (sensor2_index) {
1452:Src/util.c    ****           case 0:     // FW Disabled
1453:Src/util.c    ****             rtP_Left.b_fieldWeakEna  = 0; 
1454:Src/util.c    ****             rtP_Right.b_fieldWeakEna = 0;
1455:Src/util.c    ****             Input_Lim_Init();
1456:Src/util.c    ****             break;
1457:Src/util.c    ****           case 1:     // FW Enabled
1458:Src/util.c    ****             rtP_Left.b_fieldWeakEna  = 1; 
1459:Src/util.c    ****             rtP_Right.b_fieldWeakEna = 1;
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 62


1460:Src/util.c    ****             Input_Lim_Init();
1461:Src/util.c    ****             break; 
1462:Src/util.c    ****         }
1463:Src/util.c    ****         if (inIdx == inIdx_prev) { beepShortMany(sensor2_index + 1, 1); }
1464:Src/util.c    ****         if (++sensor2_index > 1) { sensor2_index = 0; }
1465:Src/util.c    ****       }
1466:Src/util.c    ****     #endif  // CRUISE_CONTROL_SUPPORT
1467:Src/util.c    ****   #endif
1468:Src/util.c    **** }
 1871              		.loc 1 1468 1 view .LVU456
 1872 0000 7047     		bx	lr
 1873              		.cfi_endproc
 1874              	.LFE92:
 1876              		.section	.text.saveConfig,"ax",%progbits
 1877              		.align	1
 1878              		.global	saveConfig
 1879              		.syntax unified
 1880              		.thumb
 1881              		.thumb_func
 1882              		.fpu softvfp
 1884              	saveConfig:
 1885              	.LFB93:
1469:Src/util.c    **** 
1470:Src/util.c    **** 
1471:Src/util.c    **** 
1472:Src/util.c    **** /* =========================== Poweroff Functions =========================== */
1473:Src/util.c    **** 
1474:Src/util.c    ****  /*
1475:Src/util.c    ****  * Save Configuration to Flash
1476:Src/util.c    ****  * This function makes sure data is not lost after power-off
1477:Src/util.c    ****  */
1478:Src/util.c    **** void saveConfig() {
 1886              		.loc 1 1478 19 view -0
 1887              		.cfi_startproc
 1888              		@ args = 0, pretend = 0, frame = 0
 1889              		@ frame_needed = 0, uses_anonymous_args = 0
 1890 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 1891              	.LCFI21:
 1892              		.cfi_def_cfa_offset 32
 1893              		.cfi_offset 3, -32
 1894              		.cfi_offset 4, -28
 1895              		.cfi_offset 5, -24
 1896              		.cfi_offset 6, -20
 1897              		.cfi_offset 7, -16
 1898              		.cfi_offset 8, -12
 1899              		.cfi_offset 9, -8
 1900              		.cfi_offset 14, -4
1479:Src/util.c    ****   #ifdef VARIANT_TRANSPOTTER
1480:Src/util.c    ****     if (saveValue_valid) {
1481:Src/util.c    ****       HAL_FLASH_Unlock();
1482:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[0], saveValue);
1483:Src/util.c    ****       HAL_FLASH_Lock();
1484:Src/util.c    ****     }
1485:Src/util.c    ****   #endif
1486:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
1487:Src/util.c    ****     if (inp_cal_valid || cur_spd_valid) {
 1901              		.loc 1 1487 5 view .LVU458
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 63


 1902              		.loc 1 1487 9 is_stmt 0 view .LVU459
 1903 0004 374B     		ldr	r3, .L134
 1904 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1905              		.loc 1 1487 8 view .LVU460
 1906 0008 13B9     		cbnz	r3, .L129
 1907              		.loc 1 1487 23 discriminator 1 view .LVU461
 1908 000a 374B     		ldr	r3, .L134+4
 1909 000c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1910 000e C3B1     		cbz	r3, .L128
 1911              	.L129:
1488:Src/util.c    ****       HAL_FLASH_Unlock();
 1912              		.loc 1 1488 7 is_stmt 1 view .LVU462
 1913 0010 FFF7FEFF 		bl	HAL_FLASH_Unlock
 1914              	.LVL103:
1489:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[0] , (uint16_t)FLASH_WRITE_KEY);
 1915              		.loc 1 1489 7 view .LVU463
 1916 0014 354C     		ldr	r4, .L134+8
 1917 0016 41F20101 		movw	r1, #4097
 1918 001a 2088     		ldrh	r0, [r4]
 1919 001c FFF7FEFF 		bl	EE_WriteVariable
 1920              	.LVL104:
1490:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[1] , (uint16_t)rtP_Left.i_max);
 1921              		.loc 1 1490 7 view .LVU464
 1922              		.loc 1 1490 61 is_stmt 0 view .LVU465
 1923 0020 334D     		ldr	r5, .L134+12
 1924 0022 B5F9CE10 		ldrsh	r1, [r5, #206]
 1925              		.loc 1 1490 7 view .LVU466
 1926 0026 89B2     		uxth	r1, r1
 1927 0028 6088     		ldrh	r0, [r4, #2]
 1928 002a FFF7FEFF 		bl	EE_WriteVariable
 1929              	.LVL105:
1491:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[2] , (uint16_t)rtP_Left.n_max);
 1930              		.loc 1 1491 7 is_stmt 1 view .LVU467
 1931              		.loc 1 1491 61 is_stmt 0 view .LVU468
 1932 002e B5F9DA10 		ldrsh	r1, [r5, #218]
 1933              		.loc 1 1491 7 view .LVU469
 1934 0032 89B2     		uxth	r1, r1
 1935 0034 A088     		ldrh	r0, [r4, #4]
 1936 0036 FFF7FEFF 		bl	EE_WriteVariable
 1937              	.LVL106:
1492:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 1938              		.loc 1 1492 7 is_stmt 1 view .LVU470
 1939              	.LBB9:
 1940              		.loc 1 1492 12 view .LVU471
 1941              		.loc 1 1492 20 is_stmt 0 view .LVU472
 1942 003a 0025     		movs	r5, #0
 1943              	.LVL107:
 1944              	.L131:
 1945              		.loc 1 1492 25 is_stmt 1 discriminator 1 view .LVU473
 1946              		.loc 1 1492 7 is_stmt 0 discriminator 1 view .LVU474
 1947 003c 1DB1     		cbz	r5, .L132
 1948              	.LBE9:
1493:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
1494:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 4+8*i] , (uint16_t)input1[i].min);
1495:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
1496:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
1497:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 64


1498:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
1499:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
1500:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
1501:Src/util.c    ****       }
1502:Src/util.c    ****       HAL_FLASH_Lock();
 1949              		.loc 1 1502 7 is_stmt 1 view .LVU475
 1950 003e FFF7FEFF 		bl	HAL_FLASH_Lock
 1951              	.LVL108:
 1952              	.L128:
1503:Src/util.c    ****     }
1504:Src/util.c    ****   #endif 
1505:Src/util.c    **** }
 1953              		.loc 1 1505 1 is_stmt 0 view .LVU476
 1954 0042 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1955              	.LVL109:
 1956              	.L132:
 1957              	.LBB10:
1493:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1958              		.loc 1 1493 9 is_stmt 1 discriminator 3 view .LVU477
1493:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1959              		.loc 1 1493 44 is_stmt 0 discriminator 3 view .LVU478
 1960 0046 EC00     		lsls	r4, r5, #3
1493:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1961              		.loc 1 1493 42 discriminator 3 view .LVU479
 1962 0048 E01C     		adds	r0, r4, #3
1493:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1963              		.loc 1 1493 69 discriminator 3 view .LVU480
 1964 004a 621B     		subs	r2, r4, r5
 1965 004c 5300     		lsls	r3, r2, #1
 1966 004e 294F     		ldr	r7, .L134+16
 1967 0050 1F44     		add	r7, r7, r3
1493:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1968              		.loc 1 1493 9 discriminator 3 view .LVU481
 1969 0052 264E     		ldr	r6, .L134+8
 1970 0054 3979     		ldrb	r1, [r7, #4]	@ zero_extendqisi2
 1971 0056 36F81000 		ldrh	r0, [r6, r0, lsl #1]
 1972 005a FFF7FEFF 		bl	EE_WriteVariable
 1973              	.LVL110:
1494:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1974              		.loc 1 1494 9 is_stmt 1 discriminator 3 view .LVU482
1494:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1975              		.loc 1 1494 42 is_stmt 0 discriminator 3 view .LVU483
 1976 005e 231D     		adds	r3, r4, #4
1494:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1977              		.loc 1 1494 69 discriminator 3 view .LVU484
 1978 0060 B7F90610 		ldrsh	r1, [r7, #6]
1494:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1979              		.loc 1 1494 9 discriminator 3 view .LVU485
 1980 0064 89B2     		uxth	r1, r1
 1981 0066 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1982 006a FFF7FEFF 		bl	EE_WriteVariable
 1983              	.LVL111:
1495:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1984              		.loc 1 1495 9 is_stmt 1 discriminator 3 view .LVU486
1495:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1985              		.loc 1 1495 42 is_stmt 0 discriminator 3 view .LVU487
 1986 006e 631D     		adds	r3, r4, #5
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 65


1495:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1987              		.loc 1 1495 69 discriminator 3 view .LVU488
 1988 0070 B7F90810 		ldrsh	r1, [r7, #8]
1495:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1989              		.loc 1 1495 9 discriminator 3 view .LVU489
 1990 0074 89B2     		uxth	r1, r1
 1991 0076 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1992 007a FFF7FEFF 		bl	EE_WriteVariable
 1993              	.LVL112:
1496:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1994              		.loc 1 1496 9 is_stmt 1 discriminator 3 view .LVU490
1496:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1995              		.loc 1 1496 42 is_stmt 0 discriminator 3 view .LVU491
 1996 007e A31D     		adds	r3, r4, #6
1496:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1997              		.loc 1 1496 69 discriminator 3 view .LVU492
 1998 0080 B7F90A10 		ldrsh	r1, [r7, #10]
1496:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1999              		.loc 1 1496 9 discriminator 3 view .LVU493
 2000 0084 89B2     		uxth	r1, r1
 2001 0086 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 2002 008a FFF7FEFF 		bl	EE_WriteVariable
 2003              	.LVL113:
1497:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 2004              		.loc 1 1497 9 is_stmt 1 discriminator 3 view .LVU494
1497:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 2005              		.loc 1 1497 42 is_stmt 0 discriminator 3 view .LVU495
 2006 008e E21D     		adds	r2, r4, #7
1497:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 2007              		.loc 1 1497 69 discriminator 3 view .LVU496
 2008 0090 DFF86480 		ldr	r8, .L134+20
 2009 0094 631B     		subs	r3, r4, r5
 2010 0096 5F00     		lsls	r7, r3, #1
 2011 0098 4744     		add	r7, r7, r8
1497:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 2012              		.loc 1 1497 9 discriminator 3 view .LVU497
 2013 009a 3979     		ldrb	r1, [r7, #4]	@ zero_extendqisi2
 2014 009c 36F81200 		ldrh	r0, [r6, r2, lsl #1]
 2015 00a0 FFF7FEFF 		bl	EE_WriteVariable
 2016              	.LVL114:
1498:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 2017              		.loc 1 1498 9 is_stmt 1 discriminator 3 view .LVU498
1498:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 2018              		.loc 1 1498 42 is_stmt 0 discriminator 3 view .LVU499
 2019 00a4 05F10109 		add	r9, r5, #1
 2020 00a8 4FEAC903 		lsl	r3, r9, #3
1498:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 2021              		.loc 1 1498 69 discriminator 3 view .LVU500
 2022 00ac B7F90610 		ldrsh	r1, [r7, #6]
1498:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 2023              		.loc 1 1498 9 discriminator 3 view .LVU501
 2024 00b0 89B2     		uxth	r1, r1
 2025 00b2 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 2026 00b6 FFF7FEFF 		bl	EE_WriteVariable
 2027              	.LVL115:
1499:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 2028              		.loc 1 1499 9 is_stmt 1 discriminator 3 view .LVU502
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 66


1499:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 2029              		.loc 1 1499 42 is_stmt 0 discriminator 3 view .LVU503
 2030 00ba 04F10903 		add	r3, r4, #9
1499:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 2031              		.loc 1 1499 69 discriminator 3 view .LVU504
 2032 00be B7F90810 		ldrsh	r1, [r7, #8]
1499:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 2033              		.loc 1 1499 9 discriminator 3 view .LVU505
 2034 00c2 89B2     		uxth	r1, r1
 2035 00c4 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 2036 00c8 FFF7FEFF 		bl	EE_WriteVariable
 2037              	.LVL116:
1500:Src/util.c    ****       }
 2038              		.loc 1 1500 9 is_stmt 1 discriminator 3 view .LVU506
1500:Src/util.c    ****       }
 2039              		.loc 1 1500 42 is_stmt 0 discriminator 3 view .LVU507
 2040 00cc 04F10A02 		add	r2, r4, #10
1500:Src/util.c    ****       }
 2041              		.loc 1 1500 69 discriminator 3 view .LVU508
 2042 00d0 B7F90A10 		ldrsh	r1, [r7, #10]
1500:Src/util.c    ****       }
 2043              		.loc 1 1500 9 discriminator 3 view .LVU509
 2044 00d4 89B2     		uxth	r1, r1
 2045 00d6 36F81200 		ldrh	r0, [r6, r2, lsl #1]
 2046 00da FFF7FEFF 		bl	EE_WriteVariable
 2047              	.LVL117:
1492:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 2048              		.loc 1 1492 38 is_stmt 1 discriminator 3 view .LVU510
1492:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 2049              		.loc 1 1492 39 is_stmt 0 discriminator 3 view .LVU511
 2050 00de 5FFA89F5 		uxtb	r5, r9
 2051              	.LVL118:
1492:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 2052              		.loc 1 1492 39 discriminator 3 view .LVU512
 2053 00e2 ABE7     		b	.L131
 2054              	.L135:
 2055              		.align	2
 2056              	.L134:
 2057 00e4 00000000 		.word	.LANCHOR25
 2058 00e8 00000000 		.word	.LANCHOR26
 2059 00ec 00000000 		.word	.LANCHOR14
 2060 00f0 00000000 		.word	rtP_Left
 2061 00f4 00000000 		.word	.LANCHOR15
 2062 00f8 00000000 		.word	.LANCHOR16
 2063              	.LBE10:
 2064              		.cfi_endproc
 2065              	.LFE93:
 2067              		.section	.rodata.poweroff.str1.4,"aMS",%progbits,1
 2068              		.align	2
 2069              	.LC4:
 2070 0000 2D2D204D 		.ascii	"-- Motors disabled --\015\000"
 2070      6F746F72 
 2070      73206469 
 2070      7361626C 
 2070      6564202D 
 2071              		.section	.text.poweroff,"ax",%progbits
 2072              		.align	1
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 67


 2073              		.global	poweroff
 2074              		.syntax unified
 2075              		.thumb
 2076              		.thumb_func
 2077              		.fpu softvfp
 2079              	poweroff:
 2080              	.LFB94:
1506:Src/util.c    **** 
1507:Src/util.c    **** 
1508:Src/util.c    **** void poweroff(void) {
 2081              		.loc 1 1508 21 is_stmt 1 view -0
 2082              		.cfi_startproc
 2083              		@ args = 0, pretend = 0, frame = 0
 2084              		@ frame_needed = 0, uses_anonymous_args = 0
 2085 0000 10B5     		push	{r4, lr}
 2086              	.LCFI22:
 2087              		.cfi_def_cfa_offset 8
 2088              		.cfi_offset 4, -8
 2089              		.cfi_offset 14, -4
1509:Src/util.c    ****   enable = 0;
 2090              		.loc 1 1509 3 view .LVU514
 2091              		.loc 1 1509 10 is_stmt 0 view .LVU515
 2092 0002 0024     		movs	r4, #0
 2093 0004 0C4B     		ldr	r3, .L141
 2094 0006 1C70     		strb	r4, [r3]
1510:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
1511:Src/util.c    ****   printf("-- Motors disabled --\r\n");
 2095              		.loc 1 1511 3 is_stmt 1 view .LVU516
 2096 0008 0C48     		ldr	r0, .L141+4
 2097 000a FFF7FEFF 		bl	puts
 2098              	.LVL119:
1512:Src/util.c    ****   #endif
1513:Src/util.c    ****   buzzerCount = 0;  // prevent interraction with beep counter
 2099              		.loc 1 1513 3 view .LVU517
 2100              		.loc 1 1513 15 is_stmt 0 view .LVU518
 2101 000e 0C4B     		ldr	r3, .L141+8
 2102 0010 1C70     		strb	r4, [r3]
1514:Src/util.c    ****   buzzerPattern = 0;
 2103              		.loc 1 1514 3 is_stmt 1 view .LVU519
 2104              		.loc 1 1514 17 is_stmt 0 view .LVU520
 2105 0012 0C4B     		ldr	r3, .L141+12
 2106 0014 1C70     		strb	r4, [r3]
1515:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 2107              		.loc 1 1515 3 is_stmt 1 view .LVU521
 2108              	.LBB11:
 2109              		.loc 1 1515 8 view .LVU522
 2110              	.LVL120:
 2111              		.loc 1 1515 3 is_stmt 0 view .LVU523
 2112 0016 05E0     		b	.L137
 2113              	.LVL121:
 2114              	.L138:
1516:Src/util.c    ****     buzzerFreq = (uint8_t)i;
 2115              		.loc 1 1516 5 is_stmt 1 discriminator 3 view .LVU524
 2116              		.loc 1 1516 16 is_stmt 0 discriminator 3 view .LVU525
 2117 0018 0B4B     		ldr	r3, .L141+16
 2118 001a 1C70     		strb	r4, [r3]
1517:Src/util.c    ****     HAL_Delay(100);
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 68


 2119              		.loc 1 1517 5 is_stmt 1 discriminator 3 view .LVU526
 2120 001c 6420     		movs	r0, #100
 2121 001e FFF7FEFF 		bl	HAL_Delay
 2122              	.LVL122:
1515:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 2123              		.loc 1 1515 26 discriminator 3 view .LVU527
1515:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 2124              		.loc 1 1515 27 is_stmt 0 discriminator 3 view .LVU528
 2125 0022 0134     		adds	r4, r4, #1
 2126              	.LVL123:
 2127              	.L137:
1515:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 2128              		.loc 1 1515 19 is_stmt 1 discriminator 1 view .LVU529
1515:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 2129              		.loc 1 1515 3 is_stmt 0 discriminator 1 view .LVU530
 2130 0024 072C     		cmp	r4, #7
 2131 0026 F7DD     		ble	.L138
 2132              	.LBE11:
1518:Src/util.c    ****   }
1519:Src/util.c    ****   saveConfig();
 2133              		.loc 1 1519 3 is_stmt 1 view .LVU531
 2134 0028 FFF7FEFF 		bl	saveConfig
 2135              	.LVL124:
1520:Src/util.c    ****   HAL_GPIO_WritePin(OFF_PORT, OFF_PIN, GPIO_PIN_RESET);
 2136              		.loc 1 1520 3 view .LVU532
 2137 002c 0022     		movs	r2, #0
 2138 002e 2021     		movs	r1, #32
 2139 0030 0648     		ldr	r0, .L141+20
 2140 0032 FFF7FEFF 		bl	HAL_GPIO_WritePin
 2141              	.LVL125:
 2142              	.L139:
1521:Src/util.c    ****   while(1) {}
 2143              		.loc 1 1521 3 discriminator 1 view .LVU533
 2144              		.loc 1 1521 13 discriminator 1 view .LVU534
 2145              		.loc 1 1521 8 discriminator 1 view .LVU535
 2146 0036 FEE7     		b	.L139
 2147              	.L142:
 2148              		.align	2
 2149              	.L141:
 2150 0038 00000000 		.word	enable
 2151 003c 00000000 		.word	.LC4
 2152 0040 00000000 		.word	buzzerCount
 2153 0044 00000000 		.word	buzzerPattern
 2154 0048 00000000 		.word	buzzerFreq
 2155 004c 00080140 		.word	1073809408
 2156              		.cfi_endproc
 2157              	.LFE94:
 2159              		.section	.text.filtLowPass32,"ax",%progbits
 2160              		.align	1
 2161              		.global	filtLowPass32
 2162              		.syntax unified
 2163              		.thumb
 2164              		.thumb_func
 2165              		.fpu softvfp
 2167              	filtLowPass32:
 2168              	.LVL126:
 2169              	.LFB96:
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 69


1522:Src/util.c    **** }
1523:Src/util.c    **** 
1524:Src/util.c    **** 
1525:Src/util.c    **** void poweroffPressCheck(void) {
1526:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
1527:Src/util.c    ****     if(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1528:Src/util.c    ****       enable = 0;
1529:Src/util.c    ****       uint16_t cnt_press = 0;
1530:Src/util.c    ****       while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1531:Src/util.c    ****         HAL_Delay(10);
1532:Src/util.c    ****         if (cnt_press++ == 5 * 100) { beepShort(5); }
1533:Src/util.c    ****       }
1534:Src/util.c    ****       if (cnt_press >= 5 * 100) {                         // Check if press is more than 5 sec
1535:Src/util.c    ****         HAL_Delay(1000);
1536:Src/util.c    ****         if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {  // Double press: Adjust Max Current, Max 
1537:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
1538:Src/util.c    ****           beepLong(8);
1539:Src/util.c    ****           updateCurSpdLim();
1540:Src/util.c    ****           beepShort(5);
1541:Src/util.c    ****         } else {                                          // Long press: Calibrate ADC Limits
1542:Src/util.c    ****           #ifdef AUTO_CALIBRATION_ENA
1543:Src/util.c    ****           beepLong(16); 
1544:Src/util.c    ****           adcCalibLim();
1545:Src/util.c    ****           beepShort(5);
1546:Src/util.c    ****           #endif
1547:Src/util.c    ****         }
1548:Src/util.c    ****       } else if (cnt_press > 8) {                         // Short press: power off (80 ms debounce
1549:Src/util.c    ****         poweroff();
1550:Src/util.c    ****       }
1551:Src/util.c    ****     }
1552:Src/util.c    ****   #elif defined(VARIANT_TRANSPOTTER)
1553:Src/util.c    ****     if(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1554:Src/util.c    ****       enable = 0;
1555:Src/util.c    ****       while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
1556:Src/util.c    ****       beepShort(5);
1557:Src/util.c    ****       HAL_Delay(300);
1558:Src/util.c    ****       if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1559:Src/util.c    ****         while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
1560:Src/util.c    ****         beepLong(5);
1561:Src/util.c    ****         HAL_Delay(350);
1562:Src/util.c    ****         poweroff();
1563:Src/util.c    ****       } else {
1564:Src/util.c    ****         setDistance += 0.25;
1565:Src/util.c    ****         if (setDistance > 2.6) {
1566:Src/util.c    ****           setDistance = 0.5;
1567:Src/util.c    ****         }
1568:Src/util.c    ****         beepShort(setDistance / 0.25);
1569:Src/util.c    ****         saveValue = setDistance * 1000;
1570:Src/util.c    ****         saveValue_valid = 1;
1571:Src/util.c    ****       }
1572:Src/util.c    ****     }
1573:Src/util.c    ****   #else
1574:Src/util.c    ****     if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1575:Src/util.c    ****       enable = 0;                                             // disable motors
1576:Src/util.c    ****       while (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {}    // wait until button is released
1577:Src/util.c    ****       poweroff();                                             // release power-latch
1578:Src/util.c    ****     }
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 70


1579:Src/util.c    ****   #endif
1580:Src/util.c    **** }
1581:Src/util.c    **** 
1582:Src/util.c    **** 
1583:Src/util.c    **** 
1584:Src/util.c    **** /* =========================== Filtering Functions =========================== */
1585:Src/util.c    **** 
1586:Src/util.c    ****   /* Low pass filter fixed-point 32 bits: fixdt(1,32,16)
1587:Src/util.c    ****   * Max:  32767.99998474121
1588:Src/util.c    ****   * Min: -32768
1589:Src/util.c    ****   * Res:  1.52587890625e-05
1590:Src/util.c    ****   * 
1591:Src/util.c    ****   * Inputs:       u     = int16 or int32
1592:Src/util.c    ****   * Outputs:      y     = fixdt(1,32,16)
1593:Src/util.c    ****   * Parameters:   coef  = fixdt(0,16,16) = [0,65535U]
1594:Src/util.c    ****   * 
1595:Src/util.c    ****   * Example: 
1596:Src/util.c    ****   * If coef = 0.8 (in floating point), then coef = 0.8 * 2^16 = 52429 (in fixed-point)
1597:Src/util.c    ****   * filtLowPass16(u, 52429, &y);
1598:Src/util.c    ****   * yint = (int16_t)(y >> 16); // the integer output is the fixed-point ouput shifted by 16 bits
1599:Src/util.c    ****   */
1600:Src/util.c    **** void filtLowPass32(int32_t u, uint16_t coef, int32_t *y) {
 2170              		.loc 1 1600 58 view -0
 2171              		.cfi_startproc
 2172              		@ args = 0, pretend = 0, frame = 0
 2173              		@ frame_needed = 0, uses_anonymous_args = 0
 2174              		@ link register save eliminated.
 2175              		.loc 1 1600 58 is_stmt 0 view .LVU537
 2176 0000 10B4     		push	{r4}
 2177              	.LCFI23:
 2178              		.cfi_def_cfa_offset 4
 2179              		.cfi_offset 4, -4
1601:Src/util.c    ****   int64_t tmp;  
 2180              		.loc 1 1601 3 is_stmt 1 view .LVU538
1602:Src/util.c    ****   tmp = ((int64_t)((u << 4) - (*y >> 12)) * coef) >> 4;
 2181              		.loc 1 1602 3 view .LVU539
 2182              		.loc 1 1602 32 is_stmt 0 view .LVU540
 2183 0002 1468     		ldr	r4, [r2]
 2184              		.loc 1 1602 35 view .LVU541
 2185 0004 2313     		asrs	r3, r4, #12
 2186              		.loc 1 1602 29 view .LVU542
 2187 0006 C3EB0010 		rsb	r0, r3, r0, lsl #4
 2188              	.LVL127:
 2189              		.loc 1 1602 10 view .LVU543
 2190 000a 4FEAE07C 		asr	ip, r0, #31
 2191              		.loc 1 1602 43 view .LVU544
 2192 000e A1FB0003 		umull	r0, r3, r1, r0
 2193 0012 01FB0C31 		mla	r1, r1, ip, r3
 2194              	.LVL128:
 2195              		.loc 1 1602 7 view .LVU545
 2196 0016 0009     		lsrs	r0, r0, #4
 2197 0018 40EA0170 		orr	r0, r0, r1, lsl #28
 2198 001c 0911     		asrs	r1, r1, #4
 2199              	.LVL129:
1603:Src/util.c    ****   tmp = CLAMP(tmp, -2147483648LL, 2147483647LL);  // Overflow protection: 2147483647LL = 2^31 - 1
 2200              		.loc 1 1603 3 is_stmt 1 view .LVU546
 2201              		.loc 1 1603 9 is_stmt 0 view .LVU547
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 71


 2202 001e B0F1004F 		cmp	r0, #-2147483648
 2203 0022 71F10003 		sbcs	r3, r1, #0
 2204 0026 08DA     		bge	.L146
 2205              		.loc 1 1603 9 discriminator 1 view .LVU548
 2206 0028 0346     		mov	r3, r0
 2207 002a B0F1004F 		cmp	r0, #-2147483648
 2208 002e 71F1FF31 		sbcs	r1, r1, #-1
 2209              	.LVL130:
 2210              		.loc 1 1603 9 discriminator 1 view .LVU549
 2211 0032 04DA     		bge	.L144
 2212 0034 4FF00043 		mov	r3, #-2147483648
 2213 0038 01E0     		b	.L144
 2214              	.LVL131:
 2215              	.L146:
 2216              		.loc 1 1603 9 view .LVU550
 2217 003a 6FF00043 		mvn	r3, #-2147483648
 2218              	.LVL132:
 2219              	.L144:
1604:Src/util.c    ****   *y = (int32_t)tmp + (*y);
 2220              		.loc 1 1604 3 is_stmt 1 discriminator 4 view .LVU551
 2221              		.loc 1 1604 21 is_stmt 0 discriminator 4 view .LVU552
 2222 003e 1C44     		add	r4, r4, r3
 2223              		.loc 1 1604 6 discriminator 4 view .LVU553
 2224 0040 1460     		str	r4, [r2]
1605:Src/util.c    **** }
 2225              		.loc 1 1605 1 discriminator 4 view .LVU554
 2226 0042 10BC     		pop	{r4}
 2227              	.LCFI24:
 2228              		.cfi_restore 4
 2229              		.cfi_def_cfa_offset 0
 2230 0044 7047     		bx	lr
 2231              		.cfi_endproc
 2232              	.LFE96:
 2234              		.section	.rodata.adcCalibLim.str1.4,"aMS",%progbits,1
 2235              		.align	2
 2236              	.LC5:
 2237 0000 496E7075 		.ascii	"Input calibration started...\015\000"
 2237      74206361 
 2237      6C696272 
 2237      6174696F 
 2237      6E207374 
 2238 001e 0000     		.align	2
 2239              	.LC6:
 2240 0020 496E7075 		.ascii	"Input1 is \000"
 2240      74312069 
 2240      732000
 2241 002b 00       		.align	2
 2242              	.LC7:
 2243 002c 2E2E4F4B 		.ascii	"..OK\015\000"
 2243      0D00
 2244 0032 0000     		.align	2
 2245              	.LC8:
 2246 0034 2E2E4E4F 		.ascii	"..NOK\015\000"
 2246      4B0D00
 2247 003b 00       		.align	2
 2248              	.LC9:
 2249 003c 496E7075 		.ascii	"Input2 is \000"
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 72


 2249      74322069 
 2249      732000
 2250 0047 00       		.align	2
 2251              	.LC10:
 2252 0048 4C696D69 		.ascii	"Limits Input1: TYP:%i MIN:%i MID:%i MAX:%i\015\012L"
 2252      74732049 
 2252      6E707574 
 2252      313A2054 
 2252      59503A25 
 2253 0075 696D6974 		.ascii	"imits Input2: TYP:%i MIN:%i MID:%i MAX:%i\015\012\000"
 2253      7320496E 
 2253      70757432 
 2253      3A205459 
 2253      503A2569 
 2254              		.section	.text.adcCalibLim,"ax",%progbits
 2255              		.align	1
 2256              		.global	adcCalibLim
 2257              		.syntax unified
 2258              		.thumb
 2259              		.thumb_func
 2260              		.fpu softvfp
 2262              	adcCalibLim:
 2263              	.LFB78:
 485:Src/util.c    **** #ifdef AUTO_CALIBRATION_ENA
 2264              		.loc 1 485 24 is_stmt 1 view -0
 2265              		.cfi_startproc
 2266              		@ args = 0, pretend = 0, frame = 16
 2267              		@ frame_needed = 0, uses_anonymous_args = 0
 2268 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2269              	.LCFI25:
 2270              		.cfi_def_cfa_offset 36
 2271              		.cfi_offset 4, -36
 2272              		.cfi_offset 5, -32
 2273              		.cfi_offset 6, -28
 2274              		.cfi_offset 7, -24
 2275              		.cfi_offset 8, -20
 2276              		.cfi_offset 9, -16
 2277              		.cfi_offset 10, -12
 2278              		.cfi_offset 11, -8
 2279              		.cfi_offset 14, -4
 2280 0004 8BB0     		sub	sp, sp, #44
 2281              	.LCFI26:
 2282              		.cfi_def_cfa_offset 80
 487:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 2283              		.loc 1 487 3 view .LVU556
 2284 0006 FFF7FEFF 		bl	calcAvgSpeed
 2285              	.LVL133:
 488:Src/util.c    ****     return;
 2286              		.loc 1 488 3 view .LVU557
 488:Src/util.c    ****     return;
 2287              		.loc 1 488 19 is_stmt 0 view .LVU558
 2288 000a 774B     		ldr	r3, .L164
 2289 000c B3F90030 		ldrsh	r3, [r3]
 488:Src/util.c    ****     return;
 2290              		.loc 1 488 6 view .LVU559
 2291 0010 052B     		cmp	r3, #5
 2292 0012 02DD     		ble	.L163
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 73


 2293              	.L148:
 576:Src/util.c    ****  /*
 2294              		.loc 1 576 1 view .LVU560
 2295 0014 0BB0     		add	sp, sp, #44
 2296              	.LCFI27:
 2297              		.cfi_remember_state
 2298              		.cfi_def_cfa_offset 36
 2299              		@ sp needed
 2300 0016 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2301              	.L163:
 2302              	.LCFI28:
 2303              		.cfi_restore_state
 495:Src/util.c    ****   #endif
 2304              		.loc 1 495 3 is_stmt 1 view .LVU561
 2305 001a 7448     		ldr	r0, .L164+4
 2306 001c FFF7FEFF 		bl	puts
 2307              	.LVL134:
 498:Src/util.c    ****   // Inititalization: MIN = a high value, MAX = a low value
 2308              		.loc 1 498 3 view .LVU562
 2309 0020 FFF7FEFF 		bl	readInputRaw
 2310              	.LVL135:
 500:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2311              		.loc 1 500 3 view .LVU563
 500:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2312              		.loc 1 500 40 is_stmt 0 view .LVU564
 2313 0024 724B     		ldr	r3, .L164+8
 2314 0026 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2315 0028 C3EBC301 		rsb	r1, r3, r3, lsl #3
 2316 002c 714A     		ldr	r2, .L164+12
 2317 002e 32F91120 		ldrsh	r2, [r2, r1, lsl #1]
 500:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2318              		.loc 1 500 45 view .LVU565
 2319 0032 1204     		lsls	r2, r2, #16
 500:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2320              		.loc 1 500 12 view .LVU566
 2321 0034 0992     		str	r2, [sp, #36]
 501:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 2322              		.loc 1 501 3 is_stmt 1 view .LVU567
 501:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 2323              		.loc 1 501 40 is_stmt 0 view .LVU568
 2324 0036 704A     		ldr	r2, .L164+16
 2325 0038 32F91120 		ldrsh	r2, [r2, r1, lsl #1]
 501:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 2326              		.loc 1 501 45 view .LVU569
 2327 003c 1204     		lsls	r2, r2, #16
 501:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 2328              		.loc 1 501 12 view .LVU570
 2329 003e 0892     		str	r2, [sp, #32]
 502:Src/util.c    ****   int16_t  INPUT1_MID_temp = 0;
 2330              		.loc 1 502 3 is_stmt 1 view .LVU571
 2331              	.LVL136:
 503:Src/util.c    ****   int16_t  INPUT1_MAX_temp = MIN_int16_T;
 2332              		.loc 1 503 3 view .LVU572
 504:Src/util.c    ****   int16_t  INPUT2_MIN_temp = MAX_int16_T;
 2333              		.loc 1 504 3 view .LVU573
 505:Src/util.c    ****   int16_t  INPUT2_MID_temp = 0;
 2334              		.loc 1 505 3 view .LVU574
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 74


 506:Src/util.c    ****   int16_t  INPUT2_MAX_temp = MIN_int16_T;
 2335              		.loc 1 506 3 view .LVU575
 507:Src/util.c    ****   int16_t  input_margin    = 0;
 2336              		.loc 1 507 3 view .LVU576
 508:Src/util.c    ****   uint16_t input_cal_timeout = 0;
 2337              		.loc 1 508 3 view .LVU577
 509:Src/util.c    ****   
 2338              		.loc 1 509 3 view .LVU578
 512:Src/util.c    ****     input_margin = ADC_MARGIN;
 2339              		.loc 1 512 3 view .LVU579
 512:Src/util.c    ****     input_margin = ADC_MARGIN;
 2340              		.loc 1 512 6 is_stmt 0 view .LVU580
 2341 0040 5BB1     		cbz	r3, .L161
 508:Src/util.c    ****   uint16_t input_cal_timeout = 0;
 2342              		.loc 1 508 12 view .LVU581
 2343 0042 0023     		movs	r3, #0
 2344 0044 0793     		str	r3, [sp, #28]
 2345              	.L151:
 2346              	.LVL137:
 508:Src/util.c    ****   uint16_t input_cal_timeout = 0;
 2347              		.loc 1 508 12 view .LVU582
 2348 0046 0025     		movs	r5, #0
 2349 0048 DFF8B081 		ldr	r8, .L164+20
 2350 004c 2E46     		mov	r6, r5
 2351 004e 47F6FF79 		movw	r9, #32767
 2352 0052 C246     		mov	r10, r8
 2353 0054 2F46     		mov	r7, r5
 2354 0056 CB46     		mov	fp, r9
 2355 0058 2FE0     		b	.L152
 2356              	.LVL138:
 2357              	.L161:
 513:Src/util.c    ****   }
 2358              		.loc 1 513 18 view .LVU583
 2359 005a 6423     		movs	r3, #100
 2360 005c 0793     		str	r3, [sp, #28]
 2361 005e F2E7     		b	.L151
 2362              	.LVL139:
 2363              	.L154:
 519:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 2364              		.loc 1 519 5 is_stmt 1 view .LVU584
 2365 0060 FFF7FEFF 		bl	readInputRaw
 2366              	.LVL140:
 520:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2367              		.loc 1 520 5 view .LVU585
 520:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2368              		.loc 1 520 32 is_stmt 0 view .LVU586
 2369 0064 624D     		ldr	r5, .L164+8
 2370 0066 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 2371 0068 C3EBC303 		rsb	r3, r3, r3, lsl #3
 520:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2372              		.loc 1 520 5 view .LVU587
 2373 006c 09AA     		add	r2, sp, #36
 2374 006e 41F69911 		movw	r1, #6553
 2375 0072 6048     		ldr	r0, .L164+12
 2376 0074 30F91300 		ldrsh	r0, [r0, r3, lsl #1]
 2377 0078 FFF7FEFF 		bl	filtLowPass32
 2378              	.LVL141:
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 75


 521:Src/util.c    ****     
 2379              		.loc 1 521 5 is_stmt 1 view .LVU588
 521:Src/util.c    ****     
 2380              		.loc 1 521 32 is_stmt 0 view .LVU589
 2381 007c 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 2382 007e C3EBC303 		rsb	r3, r3, r3, lsl #3
 521:Src/util.c    ****     
 2383              		.loc 1 521 5 view .LVU590
 2384 0082 08AA     		add	r2, sp, #32
 2385 0084 41F69911 		movw	r1, #6553
 2386 0088 5B48     		ldr	r0, .L164+16
 2387 008a 30F91300 		ldrsh	r0, [r0, r3, lsl #1]
 2388 008e FFF7FEFF 		bl	filtLowPass32
 2389              	.LVL142:
 523:Src/util.c    ****     INPUT2_MID_temp = (int16_t)(input2_fixdt >> 16);// CLAMP(input2_fixdt >> 16, INPUT2_MIN, INPUT2
 2390              		.loc 1 523 5 is_stmt 1 view .LVU591
 523:Src/util.c    ****     INPUT2_MID_temp = (int16_t)(input2_fixdt >> 16);// CLAMP(input2_fixdt >> 16, INPUT2_MIN, INPUT2
 2391              		.loc 1 523 21 is_stmt 0 view .LVU592
 2392 0092 BDF92670 		ldrsh	r7, [sp, #38]
 2393              	.LVL143:
 524:Src/util.c    ****     INPUT1_MIN_temp = MIN(INPUT1_MIN_temp, INPUT1_MID_temp);
 2394              		.loc 1 524 5 is_stmt 1 view .LVU593
 524:Src/util.c    ****     INPUT1_MIN_temp = MIN(INPUT1_MIN_temp, INPUT1_MID_temp);
 2395              		.loc 1 524 21 is_stmt 0 view .LVU594
 2396 0096 BDF92260 		ldrsh	r6, [sp, #34]
 2397              	.LVL144:
 525:Src/util.c    ****     INPUT1_MAX_temp = MAX(INPUT1_MAX_temp, INPUT1_MID_temp);
 2398              		.loc 1 525 5 is_stmt 1 view .LVU595
 525:Src/util.c    ****     INPUT1_MAX_temp = MAX(INPUT1_MAX_temp, INPUT1_MID_temp);
 2399              		.loc 1 525 21 is_stmt 0 view .LVU596
 2400 009a BB45     		cmp	fp, r7
 2401 009c A8BF     		it	ge
 2402 009e BB46     		movge	fp, r7
 2403              	.LVL145:
 526:Src/util.c    ****     INPUT2_MIN_temp = MIN(INPUT2_MIN_temp, INPUT2_MID_temp);
 2404              		.loc 1 526 5 is_stmt 1 view .LVU597
 526:Src/util.c    ****     INPUT2_MIN_temp = MIN(INPUT2_MIN_temp, INPUT2_MID_temp);
 2405              		.loc 1 526 21 is_stmt 0 view .LVU598
 2406 00a0 BA45     		cmp	r10, r7
 2407 00a2 B8BF     		it	lt
 2408 00a4 BA46     		movlt	r10, r7
 2409              	.LVL146:
 527:Src/util.c    ****     INPUT2_MAX_temp = MAX(INPUT2_MAX_temp, INPUT2_MID_temp);
 2410              		.loc 1 527 5 is_stmt 1 view .LVU599
 527:Src/util.c    ****     INPUT2_MAX_temp = MAX(INPUT2_MAX_temp, INPUT2_MID_temp);
 2411              		.loc 1 527 21 is_stmt 0 view .LVU600
 2412 00a6 B145     		cmp	r9, r6
 2413 00a8 A8BF     		it	ge
 2414 00aa B146     		movge	r9, r6
 2415              	.LVL147:
 528:Src/util.c    ****     HAL_Delay(5);
 2416              		.loc 1 528 5 is_stmt 1 view .LVU601
 528:Src/util.c    ****     HAL_Delay(5);
 2417              		.loc 1 528 21 is_stmt 0 view .LVU602
 2418 00ac B045     		cmp	r8, r6
 2419 00ae B8BF     		it	lt
 2420 00b0 B046     		movlt	r8, r6
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 76


 2421              	.LVL148:
 529:Src/util.c    ****   }
 2422              		.loc 1 529 5 is_stmt 1 view .LVU603
 2423 00b2 0520     		movs	r0, #5
 2424 00b4 FFF7FEFF 		bl	HAL_Delay
 2425              	.LVL149:
 518:Src/util.c    ****     readInputRaw();
 2426              		.loc 1 518 73 is_stmt 0 view .LVU604
 2427 00b8 2546     		mov	r5, r4
 2428              	.LVL150:
 2429              	.L152:
 518:Src/util.c    ****     readInputRaw();
 2430              		.loc 1 518 9 is_stmt 1 view .LVU605
 518:Src/util.c    ****     readInputRaw();
 2431              		.loc 1 518 11 is_stmt 0 view .LVU606
 2432 00ba 0221     		movs	r1, #2
 2433 00bc 5048     		ldr	r0, .L164+24
 2434 00be FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2435              	.LVL151:
 518:Src/util.c    ****     readInputRaw();
 2436              		.loc 1 518 9 view .LVU607
 2437 00c2 20B9     		cbnz	r0, .L153
 518:Src/util.c    ****     readInputRaw();
 2438              		.loc 1 518 73 discriminator 1 view .LVU608
 2439 00c4 6C1C     		adds	r4, r5, #1
 2440 00c6 A4B2     		uxth	r4, r4
 2441              	.LVL152:
 518:Src/util.c    ****     readInputRaw();
 2442              		.loc 1 518 53 discriminator 1 view .LVU609
 2443 00c8 B5F57A6F 		cmp	r5, #4000
 2444 00cc C8D3     		bcc	.L154
 2445              	.LVL153:
 2446              	.L153:
 533:Src/util.c    ****   #endif
 2447              		.loc 1 533 3 is_stmt 1 view .LVU610
 2448 00ce 4D48     		ldr	r0, .L164+28
 2449 00d0 FFF7FEFF 		bl	printf
 2450              	.LVL154:
 535:Src/util.c    ****   if (input1[inIdx].typ == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibrat
 2451              		.loc 1 535 3 view .LVU611
 535:Src/util.c    ****   if (input1[inIdx].typ == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibrat
 2452              		.loc 1 535 23 is_stmt 0 view .LVU612
 2453 00d4 5246     		mov	r2, r10
 2454 00d6 3946     		mov	r1, r7
 2455 00d8 5846     		mov	r0, fp
 2456 00da FFF7FEFF 		bl	checkInputType
 2457              	.LVL155:
 535:Src/util.c    ****   if (input1[inIdx].typ == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibrat
 2458              		.loc 1 535 16 view .LVU613
 2459 00de 444B     		ldr	r3, .L164+8
 2460 00e0 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 535:Src/util.c    ****   if (input1[inIdx].typ == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibrat
 2461              		.loc 1 535 21 view .LVU614
 2462 00e2 C0B2     		uxtb	r0, r0
 2463 00e4 C3EBC301 		rsb	r1, r3, r3, lsl #3
 2464 00e8 424A     		ldr	r2, .L164+12
 2465 00ea 02EB4102 		add	r2, r2, r1, lsl #1
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 77


 2466 00ee 1071     		strb	r0, [r2, #4]
 536:Src/util.c    ****     input1[inIdx].min = INPUT1_MIN_temp + input_margin;
 2467              		.loc 1 536 3 is_stmt 1 view .LVU615
 536:Src/util.c    ****     input1[inIdx].min = INPUT1_MIN_temp + input_margin;
 2468              		.loc 1 536 41 is_stmt 0 view .LVU616
 2469 00f0 5279     		ldrb	r2, [r2, #5]	@ zero_extendqisi2
 536:Src/util.c    ****     input1[inIdx].min = INPUT1_MIN_temp + input_margin;
 2470              		.loc 1 536 6 view .LVU617
 2471 00f2 9042     		cmp	r0, r2
 2472 00f4 01D0     		beq	.L155
 536:Src/util.c    ****     input1[inIdx].min = INPUT1_MIN_temp + input_margin;
 2473              		.loc 1 536 49 discriminator 1 view .LVU618
 2474 00f6 032A     		cmp	r2, #3
 2475 00f8 5FD1     		bne	.L156
 2476              	.L155:
 537:Src/util.c    ****     input1[inIdx].mid = INPUT1_MID_temp;
 2477              		.loc 1 537 5 is_stmt 1 view .LVU619
 537:Src/util.c    ****     input1[inIdx].mid = INPUT1_MID_temp;
 2478              		.loc 1 537 41 is_stmt 0 view .LVU620
 2479 00fa 0798     		ldr	r0, [sp, #28]
 2480 00fc 8344     		add	fp, fp, r0
 2481              	.LVL156:
 537:Src/util.c    ****     input1[inIdx].mid = INPUT1_MID_temp;
 2482              		.loc 1 537 23 view .LVU621
 2483 00fe 3D4A     		ldr	r2, .L164+12
 2484 0100 C3EBC301 		rsb	r1, r3, r3, lsl #3
 2485 0104 02EB4101 		add	r1, r2, r1, lsl #1
 2486 0108 A1F806B0 		strh	fp, [r1, #6]	@ movhi
 538:Src/util.c    ****     input1[inIdx].max = INPUT1_MAX_temp - input_margin;
 2487              		.loc 1 538 5 is_stmt 1 view .LVU622
 538:Src/util.c    ****     input1[inIdx].max = INPUT1_MAX_temp - input_margin;
 2488              		.loc 1 538 23 is_stmt 0 view .LVU623
 2489 010c 0F81     		strh	r7, [r1, #8]	@ movhi
 539:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2490              		.loc 1 539 5 is_stmt 1 view .LVU624
 539:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2491              		.loc 1 539 41 is_stmt 0 view .LVU625
 2492 010e AAEB000A 		sub	r10, r10, r0
 2493              	.LVL157:
 539:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2494              		.loc 1 539 23 view .LVU626
 2495 0112 A1F80AA0 		strh	r10, [r1, #10]	@ movhi
 541:Src/util.c    ****     #endif
 2496              		.loc 1 541 5 is_stmt 1 view .LVU627
 2497 0116 3C48     		ldr	r0, .L164+32
 2498 0118 FFF7FEFF 		bl	puts
 2499              	.LVL158:
 2500              	.L157:
 551:Src/util.c    ****   #endif
 2501              		.loc 1 551 3 view .LVU628
 2502 011c 3B48     		ldr	r0, .L164+36
 2503 011e FFF7FEFF 		bl	printf
 2504              	.LVL159:
 553:Src/util.c    ****   if (input2[inIdx].typ == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibrat
 2505              		.loc 1 553 3 view .LVU629
 553:Src/util.c    ****   if (input2[inIdx].typ == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibrat
 2506              		.loc 1 553 23 is_stmt 0 view .LVU630
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 78


 2507 0122 4246     		mov	r2, r8
 2508 0124 3146     		mov	r1, r6
 2509 0126 4846     		mov	r0, r9
 2510 0128 FFF7FEFF 		bl	checkInputType
 2511              	.LVL160:
 553:Src/util.c    ****   if (input2[inIdx].typ == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibrat
 2512              		.loc 1 553 16 view .LVU631
 2513 012c 304B     		ldr	r3, .L164+8
 2514 012e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 553:Src/util.c    ****   if (input2[inIdx].typ == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibrat
 2515              		.loc 1 553 21 view .LVU632
 2516 0130 C0B2     		uxtb	r0, r0
 2517 0132 C3EBC301 		rsb	r1, r3, r3, lsl #3
 2518 0136 304A     		ldr	r2, .L164+16
 2519 0138 02EB4102 		add	r2, r2, r1, lsl #1
 2520 013c 1071     		strb	r0, [r2, #4]
 554:Src/util.c    ****     input2[inIdx].min = INPUT2_MIN_temp + input_margin;
 2521              		.loc 1 554 3 is_stmt 1 view .LVU633
 554:Src/util.c    ****     input2[inIdx].min = INPUT2_MIN_temp + input_margin;
 2522              		.loc 1 554 41 is_stmt 0 view .LVU634
 2523 013e 5279     		ldrb	r2, [r2, #5]	@ zero_extendqisi2
 554:Src/util.c    ****     input2[inIdx].min = INPUT2_MIN_temp + input_margin;
 2524              		.loc 1 554 6 view .LVU635
 2525 0140 9042     		cmp	r0, r2
 2526 0142 01D0     		beq	.L158
 554:Src/util.c    ****     input2[inIdx].min = INPUT2_MIN_temp + input_margin;
 2527              		.loc 1 554 49 discriminator 1 view .LVU636
 2528 0144 032A     		cmp	r2, #3
 2529 0146 43D1     		bne	.L159
 2530              	.L158:
 555:Src/util.c    ****     input2[inIdx].mid = INPUT2_MID_temp;
 2531              		.loc 1 555 5 is_stmt 1 view .LVU637
 555:Src/util.c    ****     input2[inIdx].mid = INPUT2_MID_temp;
 2532              		.loc 1 555 41 is_stmt 0 view .LVU638
 2533 0148 0798     		ldr	r0, [sp, #28]
 2534 014a 8144     		add	r9, r9, r0
 2535              	.LVL161:
 555:Src/util.c    ****     input2[inIdx].mid = INPUT2_MID_temp;
 2536              		.loc 1 555 23 view .LVU639
 2537 014c 2A4A     		ldr	r2, .L164+16
 2538 014e C3EBC301 		rsb	r1, r3, r3, lsl #3
 2539 0152 02EB4101 		add	r1, r2, r1, lsl #1
 2540 0156 A1F80690 		strh	r9, [r1, #6]	@ movhi
 556:Src/util.c    ****     input2[inIdx].max = INPUT2_MAX_temp - input_margin;
 2541              		.loc 1 556 5 is_stmt 1 view .LVU640
 556:Src/util.c    ****     input2[inIdx].max = INPUT2_MAX_temp - input_margin;
 2542              		.loc 1 556 23 is_stmt 0 view .LVU641
 2543 015a 0E81     		strh	r6, [r1, #8]	@ movhi
 557:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2544              		.loc 1 557 5 is_stmt 1 view .LVU642
 557:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2545              		.loc 1 557 41 is_stmt 0 view .LVU643
 2546 015c A8EB0008 		sub	r8, r8, r0
 2547              	.LVL162:
 557:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2548              		.loc 1 557 23 view .LVU644
 2549 0160 A1F80A80 		strh	r8, [r1, #10]	@ movhi
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 79


 559:Src/util.c    ****     #endif
 2550              		.loc 1 559 5 is_stmt 1 view .LVU645
 2551 0164 2848     		ldr	r0, .L164+32
 2552 0166 FFF7FEFF 		bl	puts
 2553              	.LVL163:
 2554              	.L160:
 567:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2555              		.loc 1 567 3 view .LVU646
 567:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2556              		.loc 1 567 17 is_stmt 0 view .LVU647
 2557 016a 294B     		ldr	r3, .L164+40
 2558 016c 0122     		movs	r2, #1
 2559 016e 1A70     		strb	r2, [r3]
 569:Src/util.c    ****           input1[inIdx].typ, input1[inIdx].min, input1[inIdx].mid, input1[inIdx].max,
 2560              		.loc 1 569 3 is_stmt 1 view .LVU648
 570:Src/util.c    ****           input2[inIdx].typ, input2[inIdx].min, input2[inIdx].mid, input2[inIdx].max);
 2561              		.loc 1 570 24 is_stmt 0 view .LVU649
 2562 0170 1F4B     		ldr	r3, .L164+8
 2563 0172 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2564 0174 C3EBC302 		rsb	r2, r3, r3, lsl #3
 2565 0178 1E49     		ldr	r1, .L164+12
 2566 017a 01EB4201 		add	r1, r1, r2, lsl #1
 570:Src/util.c    ****           input2[inIdx].typ, input2[inIdx].min, input2[inIdx].mid, input2[inIdx].max);
 2567              		.loc 1 570 81 view .LVU650
 2568 017e B1F90A40 		ldrsh	r4, [r1, #10]
 571:Src/util.c    ****   #endif
 2569              		.loc 1 571 24 view .LVU651
 2570 0182 1D48     		ldr	r0, .L164+16
 2571 0184 00EB4202 		add	r2, r0, r2, lsl #1
 2572 0188 1579     		ldrb	r5, [r2, #4]	@ zero_extendqisi2
 571:Src/util.c    ****   #endif
 2573              		.loc 1 571 43 view .LVU652
 2574 018a B2F90660 		ldrsh	r6, [r2, #6]
 2575              	.LVL164:
 571:Src/util.c    ****   #endif
 2576              		.loc 1 571 62 view .LVU653
 2577 018e B2F90820 		ldrsh	r2, [r2, #8]
 571:Src/util.c    ****   #endif
 2578              		.loc 1 571 81 view .LVU654
 2579 0192 C3EBC303 		rsb	r3, r3, r3, lsl #3
 2580 0196 00EB4303 		add	r3, r0, r3, lsl #1
 2581 019a B3F90A30 		ldrsh	r3, [r3, #10]
 569:Src/util.c    ****           input1[inIdx].typ, input1[inIdx].min, input1[inIdx].mid, input1[inIdx].max,
 2582              		.loc 1 569 3 view .LVU655
 2583 019e 0493     		str	r3, [sp, #16]
 2584 01a0 0392     		str	r2, [sp, #12]
 2585 01a2 0296     		str	r6, [sp, #8]
 2586 01a4 0195     		str	r5, [sp, #4]
 2587 01a6 0094     		str	r4, [sp]
 2588 01a8 B1F90830 		ldrsh	r3, [r1, #8]
 2589 01ac B1F90620 		ldrsh	r2, [r1, #6]
 2590 01b0 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 2591 01b2 1848     		ldr	r0, .L164+44
 2592 01b4 FFF7FEFF 		bl	printf
 2593              	.LVL165:
 2594 01b8 2CE7     		b	.L148
 2595              	.LVL166:
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 80


 2596              	.L156:
 544:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2597              		.loc 1 544 5 is_stmt 1 view .LVU656
 544:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2598              		.loc 1 544 23 is_stmt 0 view .LVU657
 2599 01ba C3EBC303 		rsb	r3, r3, r3, lsl #3
 2600 01be 0D4A     		ldr	r2, .L164+12
 2601 01c0 02EB4303 		add	r3, r2, r3, lsl #1
 2602 01c4 0022     		movs	r2, #0
 2603 01c6 1A71     		strb	r2, [r3, #4]
 546:Src/util.c    ****     #endif
 2604              		.loc 1 546 5 is_stmt 1 view .LVU658
 2605 01c8 1348     		ldr	r0, .L164+48
 2606 01ca FFF7FEFF 		bl	puts
 2607              	.LVL167:
 2608 01ce A5E7     		b	.L157
 2609              	.LVL168:
 2610              	.L159:
 562:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2611              		.loc 1 562 5 view .LVU659
 562:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2612              		.loc 1 562 23 is_stmt 0 view .LVU660
 2613 01d0 C3EBC303 		rsb	r3, r3, r3, lsl #3
 2614 01d4 084A     		ldr	r2, .L164+16
 2615 01d6 02EB4303 		add	r3, r2, r3, lsl #1
 2616 01da 0022     		movs	r2, #0
 2617 01dc 1A71     		strb	r2, [r3, #4]
 564:Src/util.c    ****     #endif
 2618              		.loc 1 564 5 is_stmt 1 view .LVU661
 2619 01de 0E48     		ldr	r0, .L164+48
 2620 01e0 FFF7FEFF 		bl	puts
 2621              	.LVL169:
 2622 01e4 C1E7     		b	.L160
 2623              	.L165:
 2624 01e6 00BF     		.align	2
 2625              	.L164:
 2626 01e8 00000000 		.word	.LANCHOR12
 2627 01ec 00000000 		.word	.LC5
 2628 01f0 00000000 		.word	.LANCHOR17
 2629 01f4 00000000 		.word	.LANCHOR15
 2630 01f8 00000000 		.word	.LANCHOR16
 2631 01fc 0080FFFF 		.word	-32768
 2632 0200 00080140 		.word	1073809408
 2633 0204 20000000 		.word	.LC6
 2634 0208 2C000000 		.word	.LC7
 2635 020c 3C000000 		.word	.LC9
 2636 0210 00000000 		.word	.LANCHOR25
 2637 0214 48000000 		.word	.LC10
 2638 0218 34000000 		.word	.LC8
 2639              		.cfi_endproc
 2640              	.LFE78:
 2642              		.section	.rodata.updateCurSpdLim.str1.4,"aMS",%progbits,1
 2643              		.align	2
 2644              	.LC11:
 2645 0000 546F7271 		.ascii	"Torque and Speed limits update started...\015\000"
 2645      75652061 
 2645      6E642053 
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 81


 2645      70656564 
 2645      206C696D 
 2646 002b 00       		.align	2
 2647              	.LC12:
 2648 002c 4C696D69 		.ascii	"Limits (%i)\015\012Current: fixdt:%li factor%i i_ma"
 2648      74732028 
 2648      2569290D 
 2648      0A437572 
 2648      72656E74 
 2649 0059 783A2569 		.ascii	"x:%i \015\012Speed: fixdt:%li factor:%i n_max:%i\015"
 2649      200D0A53 
 2649      70656564 
 2649      3A206669 
 2649      7864743A 
 2650 0084 0A00     		.ascii	"\012\000"
 2651              		.section	.text.updateCurSpdLim,"ax",%progbits
 2652              		.align	1
 2653              		.global	updateCurSpdLim
 2654              		.syntax unified
 2655              		.thumb
 2656              		.thumb_func
 2657              		.fpu softvfp
 2659              	updateCurSpdLim:
 2660              	.LFB79:
 584:Src/util.c    ****   calcAvgSpeed();
 2661              		.loc 1 584 28 view -0
 2662              		.cfi_startproc
 2663              		@ args = 0, pretend = 0, frame = 8
 2664              		@ frame_needed = 0, uses_anonymous_args = 0
 2665 0000 70B5     		push	{r4, r5, r6, lr}
 2666              	.LCFI29:
 2667              		.cfi_def_cfa_offset 16
 2668              		.cfi_offset 4, -16
 2669              		.cfi_offset 5, -12
 2670              		.cfi_offset 6, -8
 2671              		.cfi_offset 14, -4
 2672 0002 86B0     		sub	sp, sp, #24
 2673              	.LCFI30:
 2674              		.cfi_def_cfa_offset 40
 585:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 2675              		.loc 1 585 3 view .LVU663
 2676 0004 FFF7FEFF 		bl	calcAvgSpeed
 2677              	.LVL170:
 586:Src/util.c    ****     return;
 2678              		.loc 1 586 3 view .LVU664
 586:Src/util.c    ****     return;
 2679              		.loc 1 586 19 is_stmt 0 view .LVU665
 2680 0008 5A4B     		ldr	r3, .L180
 2681 000a B3F90030 		ldrsh	r3, [r3]
 586:Src/util.c    ****     return;
 2682              		.loc 1 586 6 view .LVU666
 2683 000e 052B     		cmp	r3, #5
 2684 0010 01DD     		ble	.L179
 2685              	.L166:
 633:Src/util.c    **** 
 2686              		.loc 1 633 1 view .LVU667
 2687 0012 06B0     		add	sp, sp, #24
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 82


 2688              	.LCFI31:
 2689              		.cfi_remember_state
 2690              		.cfi_def_cfa_offset 16
 2691              		@ sp needed
 2692 0014 70BD     		pop	{r4, r5, r6, pc}
 2693              	.L179:
 2694              	.LCFI32:
 2695              		.cfi_restore_state
 593:Src/util.c    ****   #endif
 2696              		.loc 1 593 3 is_stmt 1 view .LVU668
 2697 0016 5848     		ldr	r0, .L180+4
 2698 0018 FFF7FEFF 		bl	puts
 2699              	.LVL171:
 596:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2700              		.loc 1 596 3 view .LVU669
 596:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2701              		.loc 1 596 40 is_stmt 0 view .LVU670
 2702 001c 574B     		ldr	r3, .L180+8
 2703 001e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2704 0020 C3EBC301 		rsb	r1, r3, r3, lsl #3
 2705 0024 564A     		ldr	r2, .L180+12
 2706 0026 32F91120 		ldrsh	r2, [r2, r1, lsl #1]
 596:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2707              		.loc 1 596 45 view .LVU671
 2708 002a 1204     		lsls	r2, r2, #16
 596:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2709              		.loc 1 596 12 view .LVU672
 2710 002c 0592     		str	r2, [sp, #20]
 597:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2711              		.loc 1 597 3 is_stmt 1 view .LVU673
 597:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2712              		.loc 1 597 40 is_stmt 0 view .LVU674
 2713 002e 554A     		ldr	r2, .L180+16
 2714 0030 32F91130 		ldrsh	r3, [r2, r1, lsl #1]
 597:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2715              		.loc 1 597 45 view .LVU675
 2716 0034 1B04     		lsls	r3, r3, #16
 597:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2717              		.loc 1 597 12 view .LVU676
 2718 0036 0493     		str	r3, [sp, #16]
 598:Src/util.c    ****   uint16_t spd_factor;    // fixdt(0,16,16)
 2719              		.loc 1 598 3 is_stmt 1 view .LVU677
 599:Src/util.c    ****   uint16_t cur_spd_timeout = 0;
 2720              		.loc 1 599 3 view .LVU678
 600:Src/util.c    ****   cur_spd_valid = 0;
 2721              		.loc 1 600 3 view .LVU679
 2722              	.LVL172:
 601:Src/util.c    **** 
 2723              		.loc 1 601 3 view .LVU680
 601:Src/util.c    **** 
 2724              		.loc 1 601 17 is_stmt 0 view .LVU681
 2725 0038 0024     		movs	r4, #0
 2726 003a 534B     		ldr	r3, .L180+20
 2727 003c 1C70     		strb	r4, [r3]
 604:Src/util.c    ****     readInputRaw();
 2728              		.loc 1 604 3 is_stmt 1 view .LVU682
 604:Src/util.c    ****     readInputRaw();
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 83


 2729              		.loc 1 604 9 is_stmt 0 view .LVU683
 2730 003e 1CE0     		b	.L169
 2731              	.LVL173:
 2732              	.L171:
 605:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 2733              		.loc 1 605 5 is_stmt 1 view .LVU684
 2734 0040 FFF7FEFF 		bl	readInputRaw
 2735              	.LVL174:
 606:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2736              		.loc 1 606 5 view .LVU685
 606:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2737              		.loc 1 606 32 is_stmt 0 view .LVU686
 2738 0044 4D4C     		ldr	r4, .L180+8
 2739 0046 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 2740 0048 C3EBC303 		rsb	r3, r3, r3, lsl #3
 606:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2741              		.loc 1 606 5 view .LVU687
 2742 004c 05AA     		add	r2, sp, #20
 2743 004e 41F69911 		movw	r1, #6553
 2744 0052 4B48     		ldr	r0, .L180+12
 2745 0054 30F91300 		ldrsh	r0, [r0, r3, lsl #1]
 2746 0058 FFF7FEFF 		bl	filtLowPass32
 2747              	.LVL175:
 607:Src/util.c    ****     HAL_Delay(5);
 2748              		.loc 1 607 5 is_stmt 1 view .LVU688
 607:Src/util.c    ****     HAL_Delay(5);
 2749              		.loc 1 607 32 is_stmt 0 view .LVU689
 2750 005c 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 2751 005e C3EBC303 		rsb	r3, r3, r3, lsl #3
 607:Src/util.c    ****     HAL_Delay(5);
 2752              		.loc 1 607 5 view .LVU690
 2753 0062 04AA     		add	r2, sp, #16
 2754 0064 41F69911 		movw	r1, #6553
 2755 0068 4648     		ldr	r0, .L180+16
 2756 006a 30F91300 		ldrsh	r0, [r0, r3, lsl #1]
 2757 006e FFF7FEFF 		bl	filtLowPass32
 2758              	.LVL176:
 608:Src/util.c    ****   }
 2759              		.loc 1 608 5 is_stmt 1 view .LVU691
 2760 0072 0520     		movs	r0, #5
 2761 0074 FFF7FEFF 		bl	HAL_Delay
 2762              	.LVL177:
 604:Src/util.c    ****     readInputRaw();
 2763              		.loc 1 604 71 is_stmt 0 view .LVU692
 2764 0078 2C46     		mov	r4, r5
 2765              	.LVL178:
 2766              	.L169:
 604:Src/util.c    ****     readInputRaw();
 2767              		.loc 1 604 9 is_stmt 1 view .LVU693
 604:Src/util.c    ****     readInputRaw();
 2768              		.loc 1 604 11 is_stmt 0 view .LVU694
 2769 007a 0221     		movs	r1, #2
 2770 007c 4348     		ldr	r0, .L180+24
 2771 007e FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2772              	.LVL179:
 604:Src/util.c    ****     readInputRaw();
 2773              		.loc 1 604 9 view .LVU695
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 84


 2774 0082 20B9     		cbnz	r0, .L170
 604:Src/util.c    ****     readInputRaw();
 2775              		.loc 1 604 71 discriminator 1 view .LVU696
 2776 0084 631C     		adds	r3, r4, #1
 2777 0086 9DB2     		uxth	r5, r3
 2778              	.LVL180:
 604:Src/util.c    ****     readInputRaw();
 2779              		.loc 1 604 53 discriminator 1 view .LVU697
 2780 0088 B4F5FA6F 		cmp	r4, #2000
 2781 008c D8D3     		bcc	.L171
 2782              	.LVL181:
 2783              	.L170:
 611:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2784              		.loc 1 611 3 is_stmt 1 view .LVU698
 611:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2785              		.loc 1 611 16 is_stmt 0 view .LVU699
 2786 008e 059A     		ldr	r2, [sp, #20]
 2787 0090 3A4B     		ldr	r3, .L180+8
 2788 0092 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 2789 0094 C1EBC103 		rsb	r3, r1, r1, lsl #3
 2790 0098 3948     		ldr	r0, .L180+12
 2791 009a 00EB4300 		add	r0, r0, r3, lsl #1
 2792 009e B0F90640 		ldrsh	r4, [r0, #6]
 2793 00a2 A2EB0443 		sub	r3, r2, r4, lsl #16
 2794 00a6 B0F90A00 		ldrsh	r0, [r0, #10]
 2795 00aa 001B     		subs	r0, r0, r4
 2796 00ac 93FBF0F3 		sdiv	r3, r3, r0
 611:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2797              		.loc 1 611 14 view .LVU700
 2798 00b0 B3F5803F 		cmp	r3, #65536
 2799 00b4 57DA     		bge	.L176
 611:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2800              		.loc 1 611 16 discriminator 1 view .LVU701
 2801 00b6 41F69910 		movw	r0, #6553
 2802 00ba 8342     		cmp	r3, r0
 2803 00bc B8BF     		it	lt
 2804 00be 0346     		movlt	r3, r0
 611:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2805              		.loc 1 611 14 discriminator 1 view .LVU702
 2806 00c0 9BB2     		uxth	r3, r3
 2807              	.L172:
 2808              	.LVL182:
 612:Src/util.c    ****       
 2809              		.loc 1 612 3 is_stmt 1 discriminator 4 view .LVU703
 612:Src/util.c    ****       
 2810              		.loc 1 612 16 is_stmt 0 discriminator 4 view .LVU704
 2811 00c2 049D     		ldr	r5, [sp, #16]
 2812 00c4 C1EBC104 		rsb	r4, r1, r1, lsl #3
 2813 00c8 2E48     		ldr	r0, .L180+16
 2814 00ca 00EB4404 		add	r4, r0, r4, lsl #1
 2815 00ce B4F90660 		ldrsh	r6, [r4, #6]
 2816 00d2 A5EB0640 		sub	r0, r5, r6, lsl #16
 2817 00d6 B4F90A40 		ldrsh	r4, [r4, #10]
 2818 00da A41B     		subs	r4, r4, r6
 2819 00dc 90FBF4F0 		sdiv	r0, r0, r4
 612:Src/util.c    ****       
 2820              		.loc 1 612 14 discriminator 4 view .LVU705
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 85


 2821 00e0 B0F5803F 		cmp	r0, #65536
 2822 00e4 42DA     		bge	.L177
 612:Src/util.c    ****       
 2823              		.loc 1 612 16 discriminator 1 view .LVU706
 2824 00e6 40F6CC44 		movw	r4, #3276
 2825 00ea A042     		cmp	r0, r4
 2826 00ec B8BF     		it	lt
 2827 00ee 2046     		movlt	r0, r4
 612:Src/util.c    ****       
 2828              		.loc 1 612 14 discriminator 1 view .LVU707
 2829 00f0 80B2     		uxth	r0, r0
 2830              	.L173:
 2831              	.LVL183:
 614:Src/util.c    ****     // Update current limit
 2832              		.loc 1 614 3 is_stmt 1 discriminator 4 view .LVU708
 614:Src/util.c    ****     // Update current limit
 2833              		.loc 1 614 20 is_stmt 0 discriminator 4 view .LVU709
 2834 00f2 C1EBC104 		rsb	r4, r1, r1, lsl #3
 2835 00f6 224E     		ldr	r6, .L180+12
 2836 00f8 06EB4404 		add	r4, r6, r4, lsl #1
 2837 00fc 2479     		ldrb	r4, [r4, #4]	@ zero_extendqisi2
 614:Src/util.c    ****     // Update current limit
 2838              		.loc 1 614 6 discriminator 4 view .LVU710
 2839 00fe 6CB1     		cbz	r4, .L174
 616:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2840              		.loc 1 616 5 is_stmt 1 view .LVU711
 616:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2841              		.loc 1 616 75 is_stmt 0 view .LVU712
 2842 0100 40F2EE24 		movw	r4, #750
 2843 0104 03FB04F4 		mul	r4, r3, r4
 616:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2844              		.loc 1 616 41 view .LVU713
 2845 0108 2413     		asrs	r4, r4, #12
 616:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2846              		.loc 1 616 39 view .LVU714
 2847 010a 214E     		ldr	r6, .L180+28
 2848 010c A6F8CE40 		strh	r4, [r6, #206]	@ movhi
 616:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2849              		.loc 1 616 20 view .LVU715
 2850 0110 204E     		ldr	r6, .L180+32
 2851 0112 A6F8CE40 		strh	r4, [r6, #206]	@ movhi
 617:Src/util.c    ****   }
 2852              		.loc 1 617 5 is_stmt 1 view .LVU716
 617:Src/util.c    ****   }
 2853              		.loc 1 617 21 is_stmt 0 view .LVU717
 2854 0116 1C4C     		ldr	r4, .L180+20
 2855 0118 0126     		movs	r6, #1
 2856 011a 2670     		strb	r6, [r4]
 2857              	.L174:
 620:Src/util.c    ****     // Update speed limit
 2858              		.loc 1 620 3 is_stmt 1 view .LVU718
 620:Src/util.c    ****     // Update speed limit
 2859              		.loc 1 620 20 is_stmt 0 view .LVU719
 2860 011c C1EBC101 		rsb	r1, r1, r1, lsl #3
 2861 0120 184C     		ldr	r4, .L180+16
 2862 0122 04EB4101 		add	r1, r4, r1, lsl #1
 2863 0126 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 86


 620:Src/util.c    ****     // Update speed limit
 2864              		.loc 1 620 6 view .LVU720
 2865 0128 71B1     		cbz	r1, .L175
 622:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2866              		.loc 1 622 5 is_stmt 1 view .LVU721
 622:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2867              		.loc 1 622 62 is_stmt 0 view .LVU722
 2868 012a 4FF47A71 		mov	r1, #1000
 2869 012e 00FB01F1 		mul	r1, r0, r1
 622:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2870              		.loc 1 622 41 view .LVU723
 2871 0132 0913     		asrs	r1, r1, #12
 622:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2872              		.loc 1 622 39 view .LVU724
 2873 0134 164C     		ldr	r4, .L180+28
 2874 0136 A4F8DA10 		strh	r1, [r4, #218]	@ movhi
 622:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2875              		.loc 1 622 20 view .LVU725
 2876 013a 164C     		ldr	r4, .L180+32
 2877 013c A4F8DA10 		strh	r1, [r4, #218]	@ movhi
 623:Src/util.c    ****   }
 2878              		.loc 1 623 5 is_stmt 1 view .LVU726
 623:Src/util.c    ****   }
 2879              		.loc 1 623 20 is_stmt 0 view .LVU727
 2880 0140 114C     		ldr	r4, .L180+20
 2881 0142 2178     		ldrb	r1, [r4]	@ zero_extendqisi2
 2882 0144 0231     		adds	r1, r1, #2
 2883 0146 2170     		strb	r1, [r4]
 2884              	.L175:
 628:Src/util.c    ****           cur_spd_valid, input1_fixdt, cur_factor, rtP_Left.i_max, input2_fixdt, spd_factor, rtP_Le
 2885              		.loc 1 628 3 is_stmt 1 view .LVU728
 629:Src/util.c    ****   #endif
 2886              		.loc 1 629 60 is_stmt 0 view .LVU729
 2887 0148 1249     		ldr	r1, .L180+32
 2888 014a B1F9CE40 		ldrsh	r4, [r1, #206]
 629:Src/util.c    ****   #endif
 2889              		.loc 1 629 102 view .LVU730
 2890 014e B1F9DA10 		ldrsh	r1, [r1, #218]
 628:Src/util.c    ****           cur_spd_valid, input1_fixdt, cur_factor, rtP_Left.i_max, input2_fixdt, spd_factor, rtP_Le
 2891              		.loc 1 628 3 view .LVU731
 2892 0152 0391     		str	r1, [sp, #12]
 2893 0154 0290     		str	r0, [sp, #8]
 2894 0156 0195     		str	r5, [sp, #4]
 2895 0158 0094     		str	r4, [sp]
 2896 015a 0B49     		ldr	r1, .L180+20
 2897 015c 0978     		ldrb	r1, [r1]	@ zero_extendqisi2
 2898 015e 0E48     		ldr	r0, .L180+36
 2899              	.LVL184:
 628:Src/util.c    ****           cur_spd_valid, input1_fixdt, cur_factor, rtP_Left.i_max, input2_fixdt, spd_factor, rtP_Le
 2900              		.loc 1 628 3 view .LVU732
 2901 0160 FFF7FEFF 		bl	printf
 2902              	.LVL185:
 628:Src/util.c    ****           cur_spd_valid, input1_fixdt, cur_factor, rtP_Left.i_max, input2_fixdt, spd_factor, rtP_Le
 2903              		.loc 1 628 3 view .LVU733
 2904 0164 55E7     		b	.L166
 2905              	.L176:
 611:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 87


 2906              		.loc 1 611 14 view .LVU734
 2907 0166 4FF6FF73 		movw	r3, #65535
 2908 016a AAE7     		b	.L172
 2909              	.LVL186:
 2910              	.L177:
 612:Src/util.c    ****       
 2911              		.loc 1 612 14 view .LVU735
 2912 016c 4FF6FF70 		movw	r0, #65535
 2913 0170 BFE7     		b	.L173
 2914              	.L181:
 2915 0172 00BF     		.align	2
 2916              	.L180:
 2917 0174 00000000 		.word	.LANCHOR12
 2918 0178 00000000 		.word	.LC11
 2919 017c 00000000 		.word	.LANCHOR17
 2920 0180 00000000 		.word	.LANCHOR15
 2921 0184 00000000 		.word	.LANCHOR16
 2922 0188 00000000 		.word	.LANCHOR26
 2923 018c 00080140 		.word	1073809408
 2924 0190 00000000 		.word	.LANCHOR0
 2925 0194 00000000 		.word	rtP_Left
 2926 0198 2C000000 		.word	.LC12
 2927              		.cfi_endproc
 2928              	.LFE79:
 2930              		.section	.text.poweroffPressCheck,"ax",%progbits
 2931              		.align	1
 2932              		.global	poweroffPressCheck
 2933              		.syntax unified
 2934              		.thumb
 2935              		.thumb_func
 2936              		.fpu softvfp
 2938              	poweroffPressCheck:
 2939              	.LFB95:
1525:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 2940              		.loc 1 1525 31 is_stmt 1 view -0
 2941              		.cfi_startproc
 2942              		@ args = 0, pretend = 0, frame = 0
 2943              		@ frame_needed = 0, uses_anonymous_args = 0
 2944 0000 38B5     		push	{r3, r4, r5, lr}
 2945              	.LCFI33:
 2946              		.cfi_def_cfa_offset 16
 2947              		.cfi_offset 3, -16
 2948              		.cfi_offset 4, -12
 2949              		.cfi_offset 5, -8
 2950              		.cfi_offset 14, -4
1527:Src/util.c    ****       enable = 0;
 2951              		.loc 1 1527 5 view .LVU737
1527:Src/util.c    ****       enable = 0;
 2952              		.loc 1 1527 8 is_stmt 0 view .LVU738
 2953 0002 0221     		movs	r1, #2
 2954 0004 2248     		ldr	r0, .L196
 2955 0006 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2956              	.LVL187:
1527:Src/util.c    ****       enable = 0;
 2957              		.loc 1 1527 7 view .LVU739
 2958 000a D0B1     		cbz	r0, .L182
 2959              	.LBB12:
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 88


1528:Src/util.c    ****       uint16_t cnt_press = 0;
 2960              		.loc 1 1528 7 is_stmt 1 view .LVU740
1528:Src/util.c    ****       uint16_t cnt_press = 0;
 2961              		.loc 1 1528 14 is_stmt 0 view .LVU741
 2962 000c 0025     		movs	r5, #0
 2963 000e 214B     		ldr	r3, .L196+4
 2964 0010 1D70     		strb	r5, [r3]
1529:Src/util.c    ****       while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
 2965              		.loc 1 1529 7 is_stmt 1 view .LVU742
 2966              	.LVL188:
1530:Src/util.c    ****         HAL_Delay(10);
 2967              		.loc 1 1530 7 view .LVU743
1530:Src/util.c    ****         HAL_Delay(10);
 2968              		.loc 1 1530 12 is_stmt 0 view .LVU744
 2969 0012 00E0     		b	.L184
 2970              	.LVL189:
 2971              	.L185:
1530:Src/util.c    ****         HAL_Delay(10);
 2972              		.loc 1 1530 12 view .LVU745
 2973              	.LBE12:
1525:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 2974              		.loc 1 1525 31 view .LVU746
 2975 0014 2546     		mov	r5, r4
 2976              	.LVL190:
 2977              	.L184:
 2978              	.LBB13:
1530:Src/util.c    ****         HAL_Delay(10);
 2979              		.loc 1 1530 12 is_stmt 1 view .LVU747
1530:Src/util.c    ****         HAL_Delay(10);
 2980              		.loc 1 1530 13 is_stmt 0 view .LVU748
 2981 0016 0221     		movs	r1, #2
 2982 0018 1D48     		ldr	r0, .L196
 2983 001a FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2984              	.LVL191:
1530:Src/util.c    ****         HAL_Delay(10);
 2985              		.loc 1 1530 12 view .LVU749
 2986 001e 58B1     		cbz	r0, .L193
1531:Src/util.c    ****         if (cnt_press++ == 5 * 100) { beepShort(5); }
 2987              		.loc 1 1531 9 is_stmt 1 view .LVU750
 2988 0020 0A20     		movs	r0, #10
 2989 0022 FFF7FEFF 		bl	HAL_Delay
 2990              	.LVL192:
1532:Src/util.c    ****       }
 2991              		.loc 1 1532 9 view .LVU751
1532:Src/util.c    ****       }
 2992              		.loc 1 1532 22 is_stmt 0 view .LVU752
 2993 0026 6C1C     		adds	r4, r5, #1
 2994 0028 A4B2     		uxth	r4, r4
 2995              	.LVL193:
1532:Src/util.c    ****       }
 2996              		.loc 1 1532 12 view .LVU753
 2997 002a B5F5FA7F 		cmp	r5, #500
 2998 002e F1D1     		bne	.L185
1532:Src/util.c    ****       }
 2999              		.loc 1 1532 39 is_stmt 1 discriminator 1 view .LVU754
 3000 0030 0520     		movs	r0, #5
 3001 0032 FFF7FEFF 		bl	beepShort
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 89


 3002              	.LVL194:
 3003 0036 EDE7     		b	.L185
 3004              	.LVL195:
 3005              	.L193:
1534:Src/util.c    ****         HAL_Delay(1000);
 3006              		.loc 1 1534 7 view .LVU755
1534:Src/util.c    ****         HAL_Delay(1000);
 3007              		.loc 1 1534 10 is_stmt 0 view .LVU756
 3008 0038 B5F5FA7F 		cmp	r5, #500
 3009 003c 02D2     		bcs	.L194
1548:Src/util.c    ****         poweroff();
 3010              		.loc 1 1548 14 is_stmt 1 view .LVU757
1548:Src/util.c    ****         poweroff();
 3011              		.loc 1 1548 17 is_stmt 0 view .LVU758
 3012 003e 082D     		cmp	r5, #8
 3013 0040 24D8     		bhi	.L195
 3014              	.LVL196:
 3015              	.L182:
1548:Src/util.c    ****         poweroff();
 3016              		.loc 1 1548 17 view .LVU759
 3017              	.LBE13:
1580:Src/util.c    **** 
 3018              		.loc 1 1580 1 view .LVU760
 3019 0042 38BD     		pop	{r3, r4, r5, pc}
 3020              	.LVL197:
 3021              	.L194:
 3022              	.LBB14:
1535:Src/util.c    ****         if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {  // Double press: Adjust Max Current, Max 
 3023              		.loc 1 1535 9 is_stmt 1 view .LVU761
 3024 0044 4FF47A70 		mov	r0, #1000
 3025 0048 FFF7FEFF 		bl	HAL_Delay
 3026              	.LVL198:
1536:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
 3027              		.loc 1 1536 9 view .LVU762
1536:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
 3028              		.loc 1 1536 13 is_stmt 0 view .LVU763
 3029 004c 0221     		movs	r1, #2
 3030 004e 1048     		ldr	r0, .L196
 3031 0050 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 3032              	.LVL199:
1536:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
 3033              		.loc 1 1536 12 view .LVU764
 3034 0054 58B9     		cbnz	r0, .L188
1543:Src/util.c    ****           adcCalibLim();
 3035              		.loc 1 1543 11 is_stmt 1 view .LVU765
 3036 0056 1020     		movs	r0, #16
 3037 0058 FFF7FEFF 		bl	beepLong
 3038              	.LVL200:
1544:Src/util.c    ****           beepShort(5);
 3039              		.loc 1 1544 11 view .LVU766
 3040 005c FFF7FEFF 		bl	adcCalibLim
 3041              	.LVL201:
1545:Src/util.c    ****           #endif
 3042              		.loc 1 1545 11 view .LVU767
 3043 0060 0520     		movs	r0, #5
 3044 0062 FFF7FEFF 		bl	beepShort
 3045              	.LVL202:
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 90


 3046 0066 ECE7     		b	.L182
 3047              	.L190:
1537:Src/util.c    ****           beepLong(8);
 3048              		.loc 1 1537 62 discriminator 2 view .LVU768
 3049 0068 0A20     		movs	r0, #10
 3050 006a FFF7FEFF 		bl	HAL_Delay
 3051              	.LVL203:
 3052              	.L188:
1537:Src/util.c    ****           beepLong(8);
 3053              		.loc 1 1537 16 discriminator 1 view .LVU769
1537:Src/util.c    ****           beepLong(8);
 3054              		.loc 1 1537 17 is_stmt 0 discriminator 1 view .LVU770
 3055 006e 0221     		movs	r1, #2
 3056 0070 0748     		ldr	r0, .L196
 3057 0072 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 3058              	.LVL204:
1537:Src/util.c    ****           beepLong(8);
 3059              		.loc 1 1537 16 discriminator 1 view .LVU771
 3060 0076 0028     		cmp	r0, #0
 3061 0078 F6D1     		bne	.L190
1538:Src/util.c    ****           updateCurSpdLim();
 3062              		.loc 1 1538 11 is_stmt 1 view .LVU772
 3063 007a 0820     		movs	r0, #8
 3064 007c FFF7FEFF 		bl	beepLong
 3065              	.LVL205:
1539:Src/util.c    ****           beepShort(5);
 3066              		.loc 1 1539 11 view .LVU773
 3067 0080 FFF7FEFF 		bl	updateCurSpdLim
 3068              	.LVL206:
1540:Src/util.c    ****         } else {                                          // Long press: Calibrate ADC Limits
 3069              		.loc 1 1540 11 view .LVU774
 3070 0084 0520     		movs	r0, #5
 3071 0086 FFF7FEFF 		bl	beepShort
 3072              	.LVL207:
 3073 008a DAE7     		b	.L182
 3074              	.L195:
1549:Src/util.c    ****       }
 3075              		.loc 1 1549 9 view .LVU775
 3076 008c FFF7FEFF 		bl	poweroff
 3077              	.LVL208:
 3078              	.L197:
 3079              		.align	2
 3080              	.L196:
 3081 0090 00080140 		.word	1073809408
 3082 0094 00000000 		.word	enable
 3083              	.LBE14:
 3084              		.cfi_endproc
 3085              	.LFE95:
 3087              		.section	.text.rateLimiter16,"ax",%progbits
 3088              		.align	1
 3089              		.global	rateLimiter16
 3090              		.syntax unified
 3091              		.thumb
 3092              		.thumb_func
 3093              		.fpu softvfp
 3095              	rateLimiter16:
 3096              	.LVL209:
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 91


 3097              	.LFB97:
1606:Src/util.c    ****   // Old filter
1607:Src/util.c    ****   // Inputs:       u     = int16
1608:Src/util.c    ****   // Outputs:      y     = fixdt(1,32,20)
1609:Src/util.c    ****   // Parameters:   coef  = fixdt(0,16,16) = [0,65535U]
1610:Src/util.c    ****   // yint = (int16_t)(y >> 20); // the integer output is the fixed-point ouput shifted by 20 bits
1611:Src/util.c    ****   // void filtLowPass32(int16_t u, uint16_t coef, int32_t *y) {
1612:Src/util.c    ****   //   int32_t tmp;  
1613:Src/util.c    ****   //   tmp = (int16_t)(u << 4) - (*y >> 16);  
1614:Src/util.c    ****   //   tmp = CLAMP(tmp, -32768, 32767);  // Overflow protection  
1615:Src/util.c    ****   //   *y  = coef * tmp + (*y);
1616:Src/util.c    ****   // }
1617:Src/util.c    **** 
1618:Src/util.c    **** 
1619:Src/util.c    ****   /* rateLimiter16(int16_t u, int16_t rate, int16_t *y);
1620:Src/util.c    ****   * Inputs:       u     = int16
1621:Src/util.c    ****   * Outputs:      y     = fixdt(1,16,4)
1622:Src/util.c    ****   * Parameters:   rate  = fixdt(1,16,4) = [0, 32767] Do NOT make rate negative (>32767)
1623:Src/util.c    ****   */
1624:Src/util.c    **** void rateLimiter16(int16_t u, int16_t rate, int16_t *y) {
 3098              		.loc 1 1624 57 view -0
 3099              		.cfi_startproc
 3100              		@ args = 0, pretend = 0, frame = 0
 3101              		@ frame_needed = 0, uses_anonymous_args = 0
 3102              		@ link register save eliminated.
1625:Src/util.c    ****   int16_t q0;
 3103              		.loc 1 1625 3 view .LVU777
1626:Src/util.c    ****   int16_t q1;
 3104              		.loc 1 1626 3 view .LVU778
1627:Src/util.c    **** 
1628:Src/util.c    ****   q0 = (u << 4)  - *y;
 3105              		.loc 1 1628 3 view .LVU779
 3106              		.loc 1 1628 11 is_stmt 0 view .LVU780
 3107 0000 0301     		lsls	r3, r0, #4
 3108 0002 9BB2     		uxth	r3, r3
 3109              		.loc 1 1628 20 view .LVU781
 3110 0004 1088     		ldrh	r0, [r2]
 3111              	.LVL210:
 3112              		.loc 1 1628 18 view .LVU782
 3113 0006 1B1A     		subs	r3, r3, r0
 3114              		.loc 1 1628 6 view .LVU783
 3115 0008 1BB2     		sxth	r3, r3
 3116              	.LVL211:
1629:Src/util.c    **** 
1630:Src/util.c    ****   if (q0 > rate) {
 3117              		.loc 1 1630 3 is_stmt 1 view .LVU784
 3118              		.loc 1 1630 6 is_stmt 0 view .LVU785
 3119 000a 8B42     		cmp	r3, r1
 3120 000c 04DC     		bgt	.L199
1631:Src/util.c    ****     q0 = rate;
1632:Src/util.c    ****   } else {
1633:Src/util.c    ****     q1 = -rate;
 3121              		.loc 1 1633 5 is_stmt 1 view .LVU786
 3122              		.loc 1 1633 8 is_stmt 0 view .LVU787
 3123 000e 4942     		rsbs	r1, r1, #0
 3124              	.LVL212:
 3125              		.loc 1 1633 8 view .LVU788
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 92


 3126 0010 09B2     		sxth	r1, r1
 3127              	.LVL213:
1634:Src/util.c    ****     if (q0 < q1) {
 3128              		.loc 1 1634 5 is_stmt 1 view .LVU789
 3129              		.loc 1 1634 8 is_stmt 0 view .LVU790
 3130 0012 8B42     		cmp	r3, r1
 3131 0014 00DB     		blt	.L199
1628:Src/util.c    **** 
 3132              		.loc 1 1628 6 view .LVU791
 3133 0016 1946     		mov	r1, r3
 3134              	.LVL214:
 3135              	.L199:
1635:Src/util.c    ****       q0 = q1;
1636:Src/util.c    ****     }
1637:Src/util.c    ****   }
1638:Src/util.c    **** 
1639:Src/util.c    ****   *y = q0 + *y;
 3136              		.loc 1 1639 3 is_stmt 1 view .LVU792
 3137              		.loc 1 1639 11 is_stmt 0 view .LVU793
 3138 0018 0144     		add	r1, r1, r0
 3139              	.LVL215:
 3140              		.loc 1 1639 6 view .LVU794
 3141 001a 1180     		strh	r1, [r2]	@ movhi
1640:Src/util.c    **** }
 3142              		.loc 1 1640 1 view .LVU795
 3143 001c 7047     		bx	lr
 3144              		.cfi_endproc
 3145              	.LFE97:
 3147              		.section	.text.mixerFcn,"ax",%progbits
 3148              		.align	1
 3149              		.global	mixerFcn
 3150              		.syntax unified
 3151              		.thumb
 3152              		.thumb_func
 3153              		.fpu softvfp
 3155              	mixerFcn:
 3156              	.LVL216:
 3157              	.LFB98:
1641:Src/util.c    **** 
1642:Src/util.c    **** 
1643:Src/util.c    ****   /* mixerFcn(rtu_speed, rtu_steer, &rty_speedR, &rty_speedL); 
1644:Src/util.c    ****   * Inputs:       rtu_speed, rtu_steer                  = fixdt(1,16,4)
1645:Src/util.c    ****   * Outputs:      rty_speedR, rty_speedL                = int16_t
1646:Src/util.c    ****   * Parameters:   SPEED_COEFFICIENT, STEER_COEFFICIENT  = fixdt(0,16,14)
1647:Src/util.c    ****   */
1648:Src/util.c    **** void mixerFcn(int16_t rtu_speed, int16_t rtu_steer, int16_t *rty_speedR, int16_t *rty_speedL) {
 3158              		.loc 1 1648 95 is_stmt 1 view -0
 3159              		.cfi_startproc
 3160              		@ args = 0, pretend = 0, frame = 0
 3161              		@ frame_needed = 0, uses_anonymous_args = 0
 3162              		.loc 1 1648 95 is_stmt 0 view .LVU797
 3163 0000 10B5     		push	{r4, lr}
 3164              	.LCFI34:
 3165              		.cfi_def_cfa_offset 8
 3166              		.cfi_offset 4, -8
 3167              		.cfi_offset 14, -4
1649:Src/util.c    ****   int16_t prodSpeed;
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 93


 3168              		.loc 1 1649 3 is_stmt 1 view .LVU798
1650:Src/util.c    ****   int16_t prodSteer;
 3169              		.loc 1 1650 3 view .LVU799
1651:Src/util.c    ****   int32_t tmp;
 3170              		.loc 1 1651 3 view .LVU800
1652:Src/util.c    **** 
1653:Src/util.c    ****   prodSpeed   = (int16_t)((rtu_speed * (int16_t)SPEED_COEFFICIENT) >> 14);
 3171              		.loc 1 1653 3 view .LVU801
 3172              		.loc 1 1653 38 is_stmt 0 view .LVU802
 3173 0002 4FF47A6E 		mov	lr, #4000
 3174 0006 0EFB00F0 		mul	r0, lr, r0
 3175              	.LVL217:
 3176              		.loc 1 1653 15 view .LVU803
 3177 000a 4FEAA03C 		asr	ip, r0, #14
 3178              	.LVL218:
1654:Src/util.c    ****   prodSteer   = (int16_t)((rtu_steer * (int16_t)STEER_COEFFICIENT) >> 14);
 3179              		.loc 1 1654 3 is_stmt 1 view .LVU804
 3180              		.loc 1 1654 38 is_stmt 0 view .LVU805
 3181 000e 0EFB01F1 		mul	r1, lr, r1
 3182              	.LVL219:
 3183              		.loc 1 1654 15 view .LVU806
 3184 0012 4FEAA13E 		asr	lr, r1, #14
 3185              	.LVL220:
1655:Src/util.c    **** 
1656:Src/util.c    ****   tmp         = prodSpeed - prodSteer;  
 3186              		.loc 1 1656 3 is_stmt 1 view .LVU807
 3187              		.loc 1 1656 15 is_stmt 0 view .LVU808
 3188 0016 CEEBA030 		rsb	r0, lr, r0, asr #14
 3189              	.LVL221:
1657:Src/util.c    ****   tmp         = CLAMP(tmp, -32768, 32767);  // Overflow protection
 3190              		.loc 1 1657 3 is_stmt 1 view .LVU809
 3191              		.loc 1 1657 17 is_stmt 0 view .LVU810
 3192 001a B0F5004F 		cmp	r0, #32768
 3193 001e 26DA     		bge	.L205
 3194              		.loc 1 1657 17 discriminator 1 view .LVU811
 3195 0020 1749     		ldr	r1, .L209
 3196 0022 8842     		cmp	r0, r1
 3197 0024 B8BF     		it	lt
 3198 0026 0846     		movlt	r0, r1
 3199              	.LVL222:
 3200              	.L201:
1658:Src/util.c    ****   *rty_speedR = (int16_t)(tmp >> 4);        // Convert from fixed-point to int 
 3201              		.loc 1 1658 3 is_stmt 1 discriminator 4 view .LVU812
 3202              		.loc 1 1658 17 is_stmt 0 discriminator 4 view .LVU813
 3203 0028 0111     		asrs	r1, r0, #4
 3204              		.loc 1 1658 15 discriminator 4 view .LVU814
 3205 002a 1180     		strh	r1, [r2]	@ movhi
1659:Src/util.c    ****   *rty_speedR = CLAMP(*rty_speedR, INPUT_MIN, INPUT_MAX);
 3206              		.loc 1 1659 3 is_stmt 1 discriminator 4 view .LVU815
 3207              		.loc 1 1659 17 is_stmt 0 discriminator 4 view .LVU816
 3208 002c 1548     		ldr	r0, .L209+4
 3209              	.LVL223:
 3210              		.loc 1 1659 17 discriminator 4 view .LVU817
 3211 002e B0F90000 		ldrsh	r0, [r0]
 3212              		.loc 1 1659 15 discriminator 4 view .LVU818
 3213 0032 8142     		cmp	r1, r0
 3214 0034 1EDC     		bgt	.L206
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 94


 3215              		.loc 1 1659 17 discriminator 1 view .LVU819
 3216 0036 144C     		ldr	r4, .L209+8
 3217 0038 B4F90040 		ldrsh	r4, [r4]
 3218              		.loc 1 1659 15 discriminator 1 view .LVU820
 3219 003c A142     		cmp	r1, r4
 3220 003e B8BF     		it	lt
 3221 0040 2146     		movlt	r1, r4
 3222              	.L202:
 3223              		.loc 1 1659 15 discriminator 4 view .LVU821
 3224 0042 1180     		strh	r1, [r2]	@ movhi
1660:Src/util.c    **** 
1661:Src/util.c    ****   tmp         = prodSpeed + prodSteer;
 3225              		.loc 1 1661 3 is_stmt 1 discriminator 4 view .LVU822
 3226              		.loc 1 1661 15 is_stmt 0 discriminator 4 view .LVU823
 3227 0044 0CEB0E02 		add	r2, ip, lr
 3228              	.LVL224:
1662:Src/util.c    ****   tmp         = CLAMP(tmp, -32768, 32767);  // Overflow protection
 3229              		.loc 1 1662 3 is_stmt 1 discriminator 4 view .LVU824
 3230              		.loc 1 1662 17 is_stmt 0 discriminator 4 view .LVU825
 3231 0048 B2F5004F 		cmp	r2, #32768
 3232 004c 14DA     		bge	.L207
 3233              		.loc 1 1662 17 discriminator 1 view .LVU826
 3234 004e 0C49     		ldr	r1, .L209
 3235 0050 8A42     		cmp	r2, r1
 3236 0052 B8BF     		it	lt
 3237 0054 0A46     		movlt	r2, r1
 3238              	.LVL225:
 3239              	.L203:
1663:Src/util.c    ****   *rty_speedL = (int16_t)(tmp >> 4);        // Convert from fixed-point to int
 3240              		.loc 1 1663 3 is_stmt 1 discriminator 4 view .LVU827
 3241              		.loc 1 1663 17 is_stmt 0 discriminator 4 view .LVU828
 3242 0056 1211     		asrs	r2, r2, #4
 3243              	.LVL226:
 3244              		.loc 1 1663 15 discriminator 4 view .LVU829
 3245 0058 1A80     		strh	r2, [r3]	@ movhi
1664:Src/util.c    ****   *rty_speedL = CLAMP(*rty_speedL, INPUT_MIN, INPUT_MAX);
 3246              		.loc 1 1664 3 is_stmt 1 discriminator 4 view .LVU830
 3247              		.loc 1 1664 15 is_stmt 0 discriminator 4 view .LVU831
 3248 005a 9042     		cmp	r0, r2
 3249 005c 05DB     		blt	.L204
 3250              		.loc 1 1664 17 discriminator 1 view .LVU832
 3251 005e 0A49     		ldr	r1, .L209+8
 3252 0060 B1F90000 		ldrsh	r0, [r1]
 3253              		.loc 1 1664 15 discriminator 1 view .LVU833
 3254 0064 9042     		cmp	r0, r2
 3255 0066 B8BF     		it	lt
 3256 0068 1046     		movlt	r0, r2
 3257              	.L204:
 3258              		.loc 1 1664 15 discriminator 4 view .LVU834
 3259 006a 1880     		strh	r0, [r3]	@ movhi
1665:Src/util.c    **** }
 3260              		.loc 1 1665 1 discriminator 4 view .LVU835
 3261 006c 10BD     		pop	{r4, pc}
 3262              	.LVL227:
 3263              	.L205:
1657:Src/util.c    ****   *rty_speedR = (int16_t)(tmp >> 4);        // Convert from fixed-point to int 
 3264              		.loc 1 1657 17 view .LVU836
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 95


 3265 006e 47F6FF70 		movw	r0, #32767
 3266              	.LVL228:
1657:Src/util.c    ****   *rty_speedR = (int16_t)(tmp >> 4);        // Convert from fixed-point to int 
 3267              		.loc 1 1657 17 view .LVU837
 3268 0072 D9E7     		b	.L201
 3269              	.L206:
1659:Src/util.c    **** 
 3270              		.loc 1 1659 15 view .LVU838
 3271 0074 0146     		mov	r1, r0
 3272 0076 E4E7     		b	.L202
 3273              	.LVL229:
 3274              	.L207:
1662:Src/util.c    ****   *rty_speedL = (int16_t)(tmp >> 4);        // Convert from fixed-point to int
 3275              		.loc 1 1662 17 view .LVU839
 3276 0078 47F6FF72 		movw	r2, #32767
 3277              	.LVL230:
1662:Src/util.c    ****   *rty_speedL = (int16_t)(tmp >> 4);        // Convert from fixed-point to int
 3278              		.loc 1 1662 17 view .LVU840
 3279 007c EBE7     		b	.L203
 3280              	.L210:
 3281 007e 00BF     		.align	2
 3282              	.L209:
 3283 0080 0080FFFF 		.word	-32768
 3284 0084 00000000 		.word	.LANCHOR9
 3285 0088 00000000 		.word	.LANCHOR10
 3286              		.cfi_endproc
 3287              	.LFE98:
 3289              		.section	.text.multipleTapDet,"ax",%progbits
 3290              		.align	1
 3291              		.global	multipleTapDet
 3292              		.syntax unified
 3293              		.thumb
 3294              		.thumb_func
 3295              		.fpu softvfp
 3297              	multipleTapDet:
 3298              	.LVL231:
 3299              	.LFB99:
1666:Src/util.c    **** 
1667:Src/util.c    **** 
1668:Src/util.c    **** 
1669:Src/util.c    **** /* =========================== Multiple Tap Function =========================== */
1670:Src/util.c    **** 
1671:Src/util.c    ****   /* multipleTapDet(int16_t u, uint32_t timeNow, MultipleTap *x)
1672:Src/util.c    ****   * This function detects multiple tap presses, such as double tapping, triple tapping, etc.
1673:Src/util.c    ****   * Inputs:       u = int16_t (input signal); timeNow = uint32_t (current time)  
1674:Src/util.c    ****   * Outputs:      x->b_multipleTap (get the output here)
1675:Src/util.c    ****   */
1676:Src/util.c    **** void multipleTapDet(int16_t u, uint32_t timeNow, MultipleTap *x) {
 3300              		.loc 1 1676 66 is_stmt 1 view -0
 3301              		.cfi_startproc
 3302              		@ args = 0, pretend = 0, frame = 0
 3303              		@ frame_needed = 0, uses_anonymous_args = 0
 3304              		@ link register save eliminated.
 3305              		.loc 1 1676 66 is_stmt 0 view .LVU842
 3306 0000 30B4     		push	{r4, r5}
 3307              	.LCFI35:
 3308              		.cfi_def_cfa_offset 8
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 96


 3309              		.cfi_offset 4, -8
 3310              		.cfi_offset 5, -4
1677:Src/util.c    ****   uint8_t 	b_timeout;
 3311              		.loc 1 1677 3 is_stmt 1 view .LVU843
1678:Src/util.c    ****   uint8_t 	b_hyst;
 3312              		.loc 1 1678 3 view .LVU844
1679:Src/util.c    ****   uint8_t 	b_pulse;
 3313              		.loc 1 1679 3 view .LVU845
1680:Src/util.c    ****   uint8_t 	z_pulseCnt;
 3314              		.loc 1 1680 3 view .LVU846
1681:Src/util.c    ****   uint8_t   z_pulseCntRst;
 3315              		.loc 1 1681 3 view .LVU847
1682:Src/util.c    ****   uint32_t 	t_time; 
 3316              		.loc 1 1682 3 view .LVU848
1683:Src/util.c    **** 
1684:Src/util.c    ****   // Detect hysteresis
1685:Src/util.c    ****   if (x->b_hysteresis) {
 3317              		.loc 1 1685 3 view .LVU849
 3318              		.loc 1 1685 8 is_stmt 0 view .LVU850
 3319 0002 5479     		ldrb	r4, [r2, #5]	@ zero_extendqisi2
 3320              		.loc 1 1685 6 view .LVU851
 3321 0004 E4B1     		cbz	r4, .L212
1686:Src/util.c    ****     b_hyst = (u > MULTIPLE_TAP_LO);
 3322              		.loc 1 1686 5 is_stmt 1 view .LVU852
 3323              		.loc 1 1686 17 is_stmt 0 view .LVU853
 3324 0006 C828     		cmp	r0, #200
 3325 0008 D4BF     		ite	le
 3326 000a 0020     		movle	r0, #0
 3327              	.LVL232:
 3328              		.loc 1 1686 17 view .LVU854
 3329 000c 0120     		movgt	r0, #1
 3330              	.LVL233:
 3331              	.L213:
1687:Src/util.c    ****   } else {
1688:Src/util.c    ****     b_hyst = (u > MULTIPLE_TAP_HI);
1689:Src/util.c    ****   }
1690:Src/util.c    **** 
1691:Src/util.c    ****   // Detect pulse
1692:Src/util.c    ****   b_pulse = (b_hyst != x->b_hysteresis);
 3332              		.loc 1 1692 3 is_stmt 1 view .LVU855
 3333              		.loc 1 1692 21 is_stmt 0 view .LVU856
 3334 000e 231A     		subs	r3, r4, r0
 3335 0010 18BF     		it	ne
 3336 0012 0123     		movne	r3, #1
 3337              	.LVL234:
1693:Src/util.c    **** 
1694:Src/util.c    ****   // Save time when first pulse is detected
1695:Src/util.c    ****   if (b_hyst && b_pulse && (x->z_pulseCntPrev == 0)) {
 3338              		.loc 1 1695 3 is_stmt 1 view .LVU857
 3339              		.loc 1 1695 6 is_stmt 0 view .LVU858
 3340 0014 18B1     		cbz	r0, .L214
 3341              		.loc 1 1695 14 discriminator 1 view .LVU859
 3342 0016 8442     		cmp	r4, r0
 3343 0018 01D0     		beq	.L214
 3344              		.loc 1 1695 30 discriminator 2 view .LVU860
 3345 001a 1479     		ldrb	r4, [r2, #4]	@ zero_extendqisi2
 3346              		.loc 1 1695 25 discriminator 2 view .LVU861
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 97


 3347 001c B4B1     		cbz	r4, .L219
 3348              	.L214:
1696:Src/util.c    ****     t_time = timeNow;
1697:Src/util.c    ****   } else {
1698:Src/util.c    ****     t_time = x->t_timePrev;
 3349              		.loc 1 1698 5 is_stmt 1 view .LVU862
 3350              		.loc 1 1698 12 is_stmt 0 view .LVU863
 3351 001e 1468     		ldr	r4, [r2]
 3352              	.LVL235:
 3353              	.L215:
1699:Src/util.c    ****   }
1700:Src/util.c    **** 
1701:Src/util.c    ****   // Create timeout boolean
1702:Src/util.c    ****   b_timeout = (timeNow - t_time > MULTIPLE_TAP_TIMEOUT);
 3354              		.loc 1 1702 3 is_stmt 1 view .LVU864
 3355              		.loc 1 1702 24 is_stmt 0 view .LVU865
 3356 0020 091B     		subs	r1, r1, r4
 3357              	.LVL236:
1703:Src/util.c    **** 
1704:Src/util.c    ****   // Create pulse counter
1705:Src/util.c    ****   if ((!b_hyst) && (x->z_pulseCntPrev == 0)) {
 3358              		.loc 1 1705 3 is_stmt 1 view .LVU866
 3359              		.loc 1 1705 6 is_stmt 0 view .LVU867
 3360 0022 10B9     		cbnz	r0, .L216
 3361              		.loc 1 1705 22 discriminator 1 view .LVU868
 3362 0024 1579     		ldrb	r5, [r2, #4]	@ zero_extendqisi2
 3363              		.loc 1 1705 17 discriminator 1 view .LVU869
 3364 0026 05B9     		cbnz	r5, .L216
1706:Src/util.c    ****     z_pulseCnt = 0U;
 3365              		.loc 1 1706 16 view .LVU870
 3366 0028 2B46     		mov	r3, r5
 3367              	.LVL237:
 3368              	.L216:
1707:Src/util.c    ****   } else {
1708:Src/util.c    ****     z_pulseCnt = b_pulse;
1709:Src/util.c    ****   }
1710:Src/util.c    **** 
1711:Src/util.c    ****   // Reset counter if we detected complete tap presses OR there is a timeout
1712:Src/util.c    ****   if ((x->z_pulseCntPrev >= MULTIPLE_TAP_NR) || b_timeout) {
 3369              		.loc 1 1712 3 is_stmt 1 view .LVU871
 3370              		.loc 1 1712 9 is_stmt 0 view .LVU872
 3371 002a 92F804C0 		ldrb	ip, [r2, #4]	@ zero_extendqisi2
 3372              		.loc 1 1712 6 view .LVU873
 3373 002e BCF1030F 		cmp	ip, #3
 3374 0032 0DD8     		bhi	.L221
 3375              		.loc 1 1712 46 discriminator 1 view .LVU874
 3376 0034 B1F5FA6F 		cmp	r1, #2000
 3377 0038 0CD9     		bls	.L217
1713:Src/util.c    ****     z_pulseCntRst = 0U;
 3378              		.loc 1 1713 19 view .LVU875
 3379 003a 4FF0000C 		mov	ip, #0
 3380 003e 09E0     		b	.L217
 3381              	.LVL238:
 3382              	.L212:
1688:Src/util.c    ****   }
 3383              		.loc 1 1688 5 is_stmt 1 view .LVU876
1688:Src/util.c    ****   }
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 98


 3384              		.loc 1 1688 17 is_stmt 0 view .LVU877
 3385 0040 B0F5167F 		cmp	r0, #600
 3386 0044 D4BF     		ite	le
 3387 0046 0020     		movle	r0, #0
 3388              	.LVL239:
1688:Src/util.c    ****   }
 3389              		.loc 1 1688 17 view .LVU878
 3390 0048 0120     		movgt	r0, #1
 3391              	.LVL240:
1688:Src/util.c    ****   }
 3392              		.loc 1 1688 17 view .LVU879
 3393 004a E0E7     		b	.L213
 3394              	.LVL241:
 3395              	.L219:
1696:Src/util.c    ****   } else {
 3396              		.loc 1 1696 12 view .LVU880
 3397 004c 0C46     		mov	r4, r1
 3398 004e E7E7     		b	.L215
 3399              	.LVL242:
 3400              	.L221:
 3401              		.loc 1 1713 19 view .LVU881
 3402 0050 4FF0000C 		mov	ip, #0
 3403              	.L217:
 3404              	.LVL243:
1714:Src/util.c    ****   } else {
1715:Src/util.c    ****     z_pulseCntRst = x->z_pulseCntPrev;
1716:Src/util.c    ****   }
1717:Src/util.c    ****   z_pulseCnt = z_pulseCnt + z_pulseCntRst;
 3405              		.loc 1 1717 3 is_stmt 1 view .LVU882
 3406              		.loc 1 1717 14 is_stmt 0 view .LVU883
 3407 0054 6344     		add	r3, r3, ip
 3408              	.LVL244:
 3409              		.loc 1 1717 14 view .LVU884
 3410 0056 DBB2     		uxtb	r3, r3
 3411              	.LVL245:
1718:Src/util.c    **** 
1719:Src/util.c    ****   // Check if complete tap presses are detected AND no timeout
1720:Src/util.c    ****   if ((z_pulseCnt >= MULTIPLE_TAP_NR) && (!b_timeout)) {
 3412              		.loc 1 1720 3 is_stmt 1 view .LVU885
 3413              		.loc 1 1720 6 is_stmt 0 view .LVU886
 3414 0058 032B     		cmp	r3, #3
 3415 005a 07D9     		bls	.L218
 3416              		.loc 1 1720 39 discriminator 1 view .LVU887
 3417 005c B1F5FA6F 		cmp	r1, #2000
 3418 0060 04D8     		bhi	.L218
1721:Src/util.c    ****     x->b_multipleTap = !x->b_multipleTap;	// Toggle output
 3419              		.loc 1 1721 5 is_stmt 1 view .LVU888
 3420              		.loc 1 1721 26 is_stmt 0 view .LVU889
 3421 0062 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 3422              	.LVL246:
 3423              		.loc 1 1721 24 view .LVU890
 3424 0064 B1FA81F1 		clz	r1, r1
 3425 0068 4909     		lsrs	r1, r1, #5
 3426              		.loc 1 1721 22 view .LVU891
 3427 006a 9171     		strb	r1, [r2, #6]
 3428              	.L218:
1722:Src/util.c    ****   }
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 99


1723:Src/util.c    **** 
1724:Src/util.c    ****   // Update states
1725:Src/util.c    ****   x->z_pulseCntPrev = z_pulseCnt;
 3429              		.loc 1 1725 3 is_stmt 1 view .LVU892
 3430              		.loc 1 1725 21 is_stmt 0 view .LVU893
 3431 006c 1371     		strb	r3, [r2, #4]
1726:Src/util.c    ****   x->b_hysteresis 	= b_hyst;
 3432              		.loc 1 1726 3 is_stmt 1 view .LVU894
 3433              		.loc 1 1726 20 is_stmt 0 view .LVU895
 3434 006e 5071     		strb	r0, [r2, #5]
 3435              	.LVL247:
1727:Src/util.c    ****   x->t_timePrev 	  = t_time;
 3436              		.loc 1 1727 3 is_stmt 1 view .LVU896
 3437              		.loc 1 1727 20 is_stmt 0 view .LVU897
 3438 0070 1460     		str	r4, [r2]
1728:Src/util.c    **** }
 3439              		.loc 1 1728 1 view .LVU898
 3440 0072 30BC     		pop	{r4, r5}
 3441              	.LCFI36:
 3442              		.cfi_restore 5
 3443              		.cfi_restore 4
 3444              		.cfi_def_cfa_offset 0
 3445              	.LVL248:
 3446              		.loc 1 1728 1 view .LVU899
 3447 0074 7047     		bx	lr
 3448              		.cfi_endproc
 3449              	.LFE99:
 3451              		.global	VirtAddVarTab
 3452              		.global	nunchuk_connected
 3453              		.global	ctrlModReq
 3454              		.global	ctrlModReqRaw
 3455              		.global	timeoutFlgSerial
 3456              		.global	timeoutFlgADC
 3457              		.global	speedAvgAbs
 3458              		.global	speedAvg
 3459              		.global	input2
 3460              		.global	input1
 3461              		.global	inIdx_prev
 3462              		.global	inIdx
 3463              		.global	rtY_Right
 3464              		.global	rtU_Right
 3465              		.global	rtDW_Right
 3466              		.global	rtP_Right
 3467              		.global	rtY_Left
 3468              		.global	rtU_Left
 3469              		.global	rtDW_Left
 3470              		.global	rtM_Right
 3471              		.global	rtM_Left
 3472              		.global	rtM_Right_
 3473              		.global	rtM_Left_
 3474              		.section	.bss.INPUT_MAX,"aw",%nobits
 3475              		.align	1
 3476              		.set	.LANCHOR9,. + 0
 3479              	INPUT_MAX:
 3480 0000 0000     		.space	2
 3481              		.section	.bss.INPUT_MIN,"aw",%nobits
 3482              		.align	1
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 100


 3483              		.set	.LANCHOR10,. + 0
 3486              	INPUT_MIN:
 3487 0000 0000     		.space	2
 3488              		.section	.bss.cur_spd_valid,"aw",%nobits
 3489              		.set	.LANCHOR26,. + 0
 3492              	cur_spd_valid:
 3493 0000 00       		.space	1
 3494              		.section	.bss.inIdx,"aw",%nobits
 3495              		.set	.LANCHOR17,. + 0
 3498              	inIdx:
 3499 0000 00       		.space	1
 3500              		.section	.bss.inIdx_prev,"aw",%nobits
 3501              		.set	.LANCHOR23,. + 0
 3504              	inIdx_prev:
 3505 0000 00       		.space	1
 3506              		.section	.bss.inp_cal_valid,"aw",%nobits
 3507              		.set	.LANCHOR25,. + 0
 3510              	inp_cal_valid:
 3511 0000 00       		.space	1
 3512              		.section	.bss.nunchuk_connected,"aw",%nobits
 3515              	nunchuk_connected:
 3516 0000 00       		.space	1
 3517              		.section	.bss.old_pos.0,"aw",%nobits
 3518              		.align	2
 3519              		.set	.LANCHOR24,. + 0
 3522              	old_pos.0:
 3523 0000 00000000 		.space	4
 3524              		.section	.bss.rtDW_Left,"aw",%nobits
 3525              		.align	2
 3526              		.set	.LANCHOR2,. + 0
 3529              	rtDW_Left:
 3530 0000 00000000 		.space	172
 3530      00000000 
 3530      00000000 
 3530      00000000 
 3530      00000000 
 3531              		.section	.bss.rtDW_Right,"aw",%nobits
 3532              		.align	2
 3533              		.set	.LANCHOR6,. + 0
 3536              	rtDW_Right:
 3537 0000 00000000 		.space	172
 3537      00000000 
 3537      00000000 
 3537      00000000 
 3537      00000000 
 3538              		.section	.bss.rtM_Left_,"aw",%nobits
 3539              		.align	2
 3540              		.set	.LANCHOR1,. + 0
 3543              	rtM_Left_:
 3544 0000 00000000 		.space	16
 3544      00000000 
 3544      00000000 
 3544      00000000 
 3545              		.section	.bss.rtM_Right_,"aw",%nobits
 3546              		.align	2
 3547              		.set	.LANCHOR5,. + 0
 3550              	rtM_Right_:
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 101


 3551 0000 00000000 		.space	16
 3551      00000000 
 3551      00000000 
 3551      00000000 
 3552              		.section	.bss.rtP_Right,"aw",%nobits
 3553              		.align	2
 3554              		.set	.LANCHOR0,. + 0
 3557              	rtP_Right:
 3558 0000 00000000 		.space	256
 3558      00000000 
 3558      00000000 
 3558      00000000 
 3558      00000000 
 3559              		.section	.bss.rtU_Left,"aw",%nobits
 3560              		.align	2
 3561              		.set	.LANCHOR3,. + 0
 3564              	rtU_Left:
 3565 0000 00000000 		.space	16
 3565      00000000 
 3565      00000000 
 3565      00000000 
 3566              		.section	.bss.rtU_Right,"aw",%nobits
 3567              		.align	2
 3568              		.set	.LANCHOR7,. + 0
 3571              	rtU_Right:
 3572 0000 00000000 		.space	16
 3572      00000000 
 3572      00000000 
 3572      00000000 
 3573              		.section	.bss.rtY_Left,"aw",%nobits
 3574              		.align	2
 3575              		.set	.LANCHOR4,. + 0
 3578              	rtY_Left:
 3579 0000 00000000 		.space	16
 3579      00000000 
 3579      00000000 
 3579      00000000 
 3580              		.section	.bss.rtY_Right,"aw",%nobits
 3581              		.align	2
 3582              		.set	.LANCHOR8,. + 0
 3585              	rtY_Right:
 3586 0000 00000000 		.space	16
 3586      00000000 
 3586      00000000 
 3586      00000000 
 3587              		.section	.bss.rx_buffer_R,"aw",%nobits
 3588              		.align	2
 3589              		.set	.LANCHOR13,. + 0
 3592              	rx_buffer_R:
 3593 0000 00000000 		.space	64
 3593      00000000 
 3593      00000000 
 3593      00000000 
 3593      00000000 
 3594              		.section	.bss.speedAvg,"aw",%nobits
 3595              		.align	1
 3596              		.set	.LANCHOR11,. + 0
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 102


 3599              	speedAvg:
 3600 0000 0000     		.space	2
 3601              		.section	.bss.speedAvgAbs,"aw",%nobits
 3602              		.align	1
 3603              		.set	.LANCHOR12,. + 0
 3606              	speedAvgAbs:
 3607 0000 0000     		.space	2
 3608              		.section	.bss.timeoutFlgADC,"aw",%nobits
 3609              		.set	.LANCHOR18,. + 0
 3612              	timeoutFlgADC:
 3613 0000 00       		.space	1
 3614              		.section	.bss.timeoutFlgSerial,"aw",%nobits
 3615              		.set	.LANCHOR20,. + 0
 3618              	timeoutFlgSerial:
 3619 0000 00       		.space	1
 3620              		.section	.data.VirtAddVarTab,"aw"
 3621              		.align	2
 3622              		.set	.LANCHOR14,. + 0
 3625              	VirtAddVarTab:
 3626 0000 E803     		.short	1000
 3627 0002 E903     		.short	1001
 3628 0004 EA03     		.short	1002
 3629 0006 EB03     		.short	1003
 3630 0008 EC03     		.short	1004
 3631 000a ED03     		.short	1005
 3632 000c EE03     		.short	1006
 3633 000e EF03     		.short	1007
 3634 0010 F003     		.short	1008
 3635 0012 F103     		.short	1009
 3636 0014 F203     		.short	1010
 3637 0016 F303     		.short	1011
 3638 0018 F403     		.short	1012
 3639 001a F503     		.short	1013
 3640 001c F603     		.short	1014
 3641 001e F703     		.short	1015
 3642 0020 F803     		.short	1016
 3643 0022 F903     		.short	1017
 3644 0024 FA03     		.short	1018
 3645              		.section	.data.ctrlModReq,"aw"
 3646              		.set	.LANCHOR21,. + 0
 3649              	ctrlModReq:
 3650 0000 03       		.byte	3
 3651              		.section	.data.ctrlModReqRaw,"aw"
 3652              		.set	.LANCHOR22,. + 0
 3655              	ctrlModReqRaw:
 3656 0000 03       		.byte	3
 3657              		.section	.data.input1,"aw"
 3658              		.align	2
 3659              		.set	.LANCHOR15,. + 0
 3662              	input1:
 3663 0000 0000     		.short	0
 3664 0002 0000     		.short	0
 3665 0004 00       		.byte	0
 3666 0005 02       		.byte	2
 3667 0006 0000     		.short	0
 3668 0008 0208     		.short	2050
 3669 000a FF0F     		.short	4095
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 103


 3670 000c 6400     		.short	100
 3671              		.section	.data.input2,"aw"
 3672              		.align	2
 3673              		.set	.LANCHOR16,. + 0
 3676              	input2:
 3677 0000 0000     		.short	0
 3678 0002 0000     		.short	0
 3679 0004 00       		.byte	0
 3680 0005 02       		.byte	2
 3681 0006 0000     		.short	0
 3682 0008 D007     		.short	2000
 3683 000a FF0F     		.short	4095
 3684 000c 6400     		.short	100
 3685              		.section	.data.timeoutCntADC,"aw"
 3686              		.align	1
 3687              		.set	.LANCHOR19,. + 0
 3690              	timeoutCntADC:
 3691 0000 6400     		.short	100
 3692              		.section	.rodata.rtM_Left,"a"
 3693              		.align	2
 3696              	rtM_Left:
 3697 0000 00000000 		.word	rtM_Left_
 3698              		.section	.rodata.rtM_Right,"a"
 3699              		.align	2
 3702              	rtM_Right:
 3703 0000 00000000 		.word	rtM_Right_
 3704              		.text
 3705              	.Letext0:
 3706              		.file 2 "/usr/local/Caskroom/gcc-arm-embedded/10-2020-q4-major/gcc-arm-none-eabi-10-2020-q4-major/
 3707              		.file 3 "/usr/local/Caskroom/gcc-arm-embedded/10-2020-q4-major/gcc-arm-none-eabi-10-2020-q4-major/
 3708              		.file 4 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xe.h"
 3709              		.file 5 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_def.h"
 3710              		.file 6 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_gpio.h"
 3711              		.file 7 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_dma.h"
 3712              		.file 8 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_uart.h"
 3713              		.file 9 "Inc/defines.h"
 3714              		.file 10 "Inc/util.h"
 3715              		.file 11 "Inc/rtwtypes.h"
 3716              		.file 12 "Inc/BLDC_controller.h"
 3717              		.file 13 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal.h"
 3718              		.file 14 "Inc/eeprom.h"
 3719              		.file 15 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_flash.h"
 3720              		.file 16 "<built-in>"
 3721              		.file 17 "/usr/local/Caskroom/gcc-arm-embedded/10-2020-q4-major/gcc-arm-none-eabi-10-2020-q4-major
 3722              		.file 18 "Inc/setup.h"
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 104


DEFINED SYMBOLS
                            *ABS*:0000000000000000 util.c
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:16     .text.__io_putchar:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:24     .text.__io_putchar:0000000000000000 __io_putchar
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:61     .text.__io_putchar:000000000000001c $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:66     .text._write:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:73     .text._write:0000000000000000 _write
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:124    .text.BLDC_Init:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:131    .text.BLDC_Init:0000000000000000 BLDC_Init
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:240    .text.BLDC_Init:0000000000000084 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:254    .text.Input_Lim_Init:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:261    .text.Input_Lim_Init:0000000000000000 Input_Lim_Init
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:307    .text.Input_Lim_Init:0000000000000034 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:315    .text.UART_DisableRxErrors:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:322    .text.UART_DisableRxErrors:0000000000000000 UART_DisableRxErrors
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:346    .text.poweronMelody:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:353    .text.poweronMelody:0000000000000000 poweronMelody
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:409    .text.poweronMelody:0000000000000024 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:415    .text.beepCount:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:422    .text.beepCount:0000000000000000 beepCount
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:447    .text.beepCount:0000000000000010 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:454    .text.beepLong:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:461    .text.beepLong:0000000000000000 beepLong
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:499    .text.beepLong:0000000000000018 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:505    .text.beepShort:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:512    .text.beepShort:0000000000000000 beepShort
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:550    .text.beepShort:0000000000000018 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:556    .text.beepShortMany:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:563    .text.beepShortMany:0000000000000000 beepShortMany
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:648    .text.calcAvgSpeed:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:655    .text.calcAvgSpeed:0000000000000000 calcAvgSpeed
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:691    .text.calcAvgSpeed:0000000000000028 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:699    .text.standstillHold:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:706    .text.standstillHold:0000000000000000 standstillHold
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:719    .text.electricBrake:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:726    .text.electricBrake:0000000000000000 electricBrake
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:740    .text.cruiseControl:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:747    .text.cruiseControl:0000000000000000 cruiseControl
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:761    .rodata.checkInputType.str1.4:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:774    .text.checkInputType:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:781    .text.checkInputType:0000000000000000 checkInputType
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:891    .text.checkInputType:0000000000000074 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:900    .text.Input_Init:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:907    .text.Input_Init:0000000000000000 Input_Init
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1226   .text.Input_Init:00000000000001b8 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1238   .text.calcInputCmd:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1245   .text.calcInputCmd:0000000000000000 calcInputCmd
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1385   .text.readInputRaw:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1392   .text.readInputRaw:0000000000000000 readInputRaw
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1428   .text.readInputRaw:0000000000000028 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1436   .text.handleTimeout:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1443   .text.handleTimeout:0000000000000000 handleTimeout
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1609   .text.handleTimeout:00000000000000d8 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1623   .text.readCommand:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1630   .text.readCommand:0000000000000000 readCommand
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1681   .text.readCommand:0000000000000044 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1690   .text.usart2_rx_check:0000000000000000 $t
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 105


/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1697   .text.usart2_rx_check:0000000000000000 usart2_rx_check
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1710   .text.usart3_rx_check:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1717   .text.usart3_rx_check:0000000000000000 usart3_rx_check
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1807   .text.usart3_rx_check:0000000000000050 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1814   .text.usart_process_debug:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1821   .text.usart_process_debug:0000000000000000 usart_process_debug
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1835   .text.sideboardLeds:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1842   .text.sideboardLeds:0000000000000000 sideboardLeds
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1856   .text.sideboardSensors:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1863   .text.sideboardSensors:0000000000000000 sideboardSensors
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1877   .text.saveConfig:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:1884   .text.saveConfig:0000000000000000 saveConfig
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:2057   .text.saveConfig:00000000000000e4 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:2068   .rodata.poweroff.str1.4:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:2072   .text.poweroff:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:2079   .text.poweroff:0000000000000000 poweroff
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:2150   .text.poweroff:0000000000000038 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:2160   .text.filtLowPass32:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:2167   .text.filtLowPass32:0000000000000000 filtLowPass32
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:2235   .rodata.adcCalibLim.str1.4:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:2255   .text.adcCalibLim:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:2262   .text.adcCalibLim:0000000000000000 adcCalibLim
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:2626   .text.adcCalibLim:00000000000001e8 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:2643   .rodata.updateCurSpdLim.str1.4:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:2652   .text.updateCurSpdLim:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:2659   .text.updateCurSpdLim:0000000000000000 updateCurSpdLim
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:2917   .text.updateCurSpdLim:0000000000000174 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:2931   .text.poweroffPressCheck:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:2938   .text.poweroffPressCheck:0000000000000000 poweroffPressCheck
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3081   .text.poweroffPressCheck:0000000000000090 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3088   .text.rateLimiter16:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3095   .text.rateLimiter16:0000000000000000 rateLimiter16
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3148   .text.mixerFcn:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3155   .text.mixerFcn:0000000000000000 mixerFcn
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3283   .text.mixerFcn:0000000000000080 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3290   .text.multipleTapDet:0000000000000000 $t
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3297   .text.multipleTapDet:0000000000000000 multipleTapDet
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3625   .data.VirtAddVarTab:0000000000000000 VirtAddVarTab
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3515   .bss.nunchuk_connected:0000000000000000 nunchuk_connected
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3649   .data.ctrlModReq:0000000000000000 ctrlModReq
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3655   .data.ctrlModReqRaw:0000000000000000 ctrlModReqRaw
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3618   .bss.timeoutFlgSerial:0000000000000000 timeoutFlgSerial
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3612   .bss.timeoutFlgADC:0000000000000000 timeoutFlgADC
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3606   .bss.speedAvgAbs:0000000000000000 speedAvgAbs
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3599   .bss.speedAvg:0000000000000000 speedAvg
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3676   .data.input2:0000000000000000 input2
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3662   .data.input1:0000000000000000 input1
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3504   .bss.inIdx_prev:0000000000000000 inIdx_prev
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3498   .bss.inIdx:0000000000000000 inIdx
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3585   .bss.rtY_Right:0000000000000000 rtY_Right
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3571   .bss.rtU_Right:0000000000000000 rtU_Right
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3536   .bss.rtDW_Right:0000000000000000 rtDW_Right
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3557   .bss.rtP_Right:0000000000000000 rtP_Right
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3578   .bss.rtY_Left:0000000000000000 rtY_Left
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3564   .bss.rtU_Left:0000000000000000 rtU_Left
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3529   .bss.rtDW_Left:0000000000000000 rtDW_Left
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3702   .rodata.rtM_Right:0000000000000000 rtM_Right
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 106


/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3696   .rodata.rtM_Left:0000000000000000 rtM_Left
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3550   .bss.rtM_Right_:0000000000000000 rtM_Right_
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3543   .bss.rtM_Left_:0000000000000000 rtM_Left_
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3475   .bss.INPUT_MAX:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3479   .bss.INPUT_MAX:0000000000000000 INPUT_MAX
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3482   .bss.INPUT_MIN:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3486   .bss.INPUT_MIN:0000000000000000 INPUT_MIN
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3492   .bss.cur_spd_valid:0000000000000000 cur_spd_valid
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3493   .bss.cur_spd_valid:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3499   .bss.inIdx:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3505   .bss.inIdx_prev:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3510   .bss.inp_cal_valid:0000000000000000 inp_cal_valid
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3511   .bss.inp_cal_valid:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3516   .bss.nunchuk_connected:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3518   .bss.old_pos.0:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3522   .bss.old_pos.0:0000000000000000 old_pos.0
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3525   .bss.rtDW_Left:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3532   .bss.rtDW_Right:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3539   .bss.rtM_Left_:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3546   .bss.rtM_Right_:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3553   .bss.rtP_Right:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3560   .bss.rtU_Left:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3567   .bss.rtU_Right:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3574   .bss.rtY_Left:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3581   .bss.rtY_Right:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3588   .bss.rx_buffer_R:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3592   .bss.rx_buffer_R:0000000000000000 rx_buffer_R
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3595   .bss.speedAvg:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3602   .bss.speedAvgAbs:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3613   .bss.timeoutFlgADC:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3619   .bss.timeoutFlgSerial:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3621   .data.VirtAddVarTab:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3658   .data.input1:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3672   .data.input2:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3686   .data.timeoutCntADC:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3690   .data.timeoutCntADC:0000000000000000 timeoutCntADC
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3693   .rodata.rtM_Left:0000000000000000 $d
/var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s:3699   .rodata.rtM_Right:0000000000000000 $d

UNDEFINED SYMBOLS
HAL_UART_Transmit
huart3
memcpy
BLDC_controller_initialize
rtP_Left
HAL_Delay
buzzerCount
buzzerFreq
buzzerPattern
printf
UART3_Init
HAL_UART_Receive_DMA
HAL_FLASH_Unlock
EE_Init
EE_ReadVariable
HAL_FLASH_Lock
adc_buffer
ARM GAS  /var/folders/95/w0y5d13j6379kd25_hkgs4sr0000gn/T//ccyG29Ms.s 			page 107


timeoutFlgGen
EE_WriteVariable
puts
HAL_GPIO_WritePin
enable
HAL_GPIO_ReadPin
